<!DOCTYPE html>
<!-- saved from url=(0083)https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm -->
<html class="" data-reactroot=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="./392.算法 - 搜狗科学百科_files/analytics.js.download" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app224.us.archive.org';v.server_ms=208;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="./392.算法 - 搜狗科学百科_files/bundle-playback.js.download" charset="utf-8"></script>
<script type="text/javascript" src="./392.算法 - 搜狗科学百科_files/wombat.js.download" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("https://baike.sogou.com/kexue/d10392.htm","20221025113656","https://web.archive.org/","web","/_static/",
	      "1666697816");
</script>
<link rel="stylesheet" type="text/css" href="./392.算法 - 搜狗科学百科_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./392.算法 - 搜狗科学百科_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<meta name="save" content="history"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="VWGb6TyYx8"><meta content="算法 - 搜狗科学百科" name="keywords"><meta content="搜狗科学百科是一部有着平等、协作、分享、自由理念的网络科学全书，为每一个互联网用户创造一个涵盖所有领域知识、服务的中文知识性平台。" name="description"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="server" baike="235" ip="210" env="online"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://cache.soso.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://hhy.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://pic.baike.soso.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://ugc.qpic.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://xui.ptlogin2.qq.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://q1.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://q2.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://q3.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://q4.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://q.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://img01.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/"><link rel="Shortcut Icon" href="https://web.archive.org/web/20221025113656im_/https://www.sogou.com/images/logo/new/favicon.ico?v=4"><link rel="Bookmark" href="https://www.sogou.com/images/logo/new/favicon.ico?v=4"><link href="./392.算法 - 搜狗科学百科_files/base_b849887.css" rel="stylesheet"><link href="./392.算法 - 搜狗科学百科_files/detail_378aed5.css" rel="stylesheet"><link href="./392.算法 - 搜狗科学百科_files/inviteAudit_7894507.css" rel="stylesheet"><link rel="stylesheet" href="./392.算法 - 搜狗科学百科_files/highlight.min.css"><title>算法 - 搜狗科学百科</title><style>.onekey-close {
	position: absolute;
	top: 16px;
	right: 16px;
	width: 24px;
	height: 24px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	text-indent: -999em;
	background-size: 84px;
	background-position: -63px 0;
}

.onekey-login {
	position: absolute;
	top: 16.4%;
	left: 0;
	right: 0;
	width: 100%;
}

/* .onekey-login-img {
    width: 75px;
    height: 75px;
    background: url("https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/images/sprite_wap_baike.png") no-repeat;
    background-size: 100px 91px;
    background-position: 0 0;
    background-repeat: no-repeat;
    margin: 0 auto;
} */

.onekey-login-title {
	text-align: center;
	padding-bottom: 3px;
	font-size: 21px;
	font-weight: bold;
	line-height: 30px;
	color: #000;
}

.onekey-login-txt {
	text-align: center;
	font-family: PingFangSC;
	font-size: 14px;
	line-height: 20px;
	color: #8f8f8f;
}

.onekey-login-qq,
.onekey-login-wx,
.onekey-login-phone {
	display: block;
	width: 245px;
	height: 54px;
	border-radius: 45px;
	text-align: center;

	margin: 0 auto;
	font-size: 17px;
	line-height: 24px;
	color: #000;
	/* padding: 16px 77px; */
	border-radius: 12px;
	border: solid 1px #e0e0e0;
}
.onekey-qq-content,
.onekey-vx-content,
.onekey-phone-content {
	display: inline-block;
	margin-top: 16px;
}
.onekey-qq-content {
	padding: 0 5px;
}

.onekey-login-qq {
	margin-top: 48px;
	margin-bottom: 24px;
}

.onekey-login-qq:before {
	display: inline-block;
	content: "";
	width: 20px;
	height: 20px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 80px;
	background-position: -20px 0;
	vertical-align: top;
	margin: 17px 8px 0 0;
}

.onekey-login-wx {
	margin-bottom: 24px;
}

.onekey-login-wx:before {
	display: inline-block;
	content: "";
	width: 21px;
	height: 21px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 84px;
	background-position: 0 0;
	vertical-align: top;
	margin: 17px 10px 0 0;
}

.onekey-login-phone {
}

.onekey-login-phone:before {
	display: inline-block;
	content: "";
	width: 21px;
	height: 21px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 84px;
	background-position: -42px 0;
	vertical-align: top;
	margin: 17px 10px 0 0;
}

.onekey-fixed {
	z-index: 100;
	position: fixed;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
	background: #fff;
	width: 100%;
	height: 100%;
}

.onekey-fixed.forbid {
	z-index: 100;
	position: fixed;
	top: auto;
	bottom: 68px;
	left: 9%;
	right: 0;
	background: rgba(0, 0, 0, 0.7);
	width: 82%;
	height: 43px;
	border-radius: 25px;
	color: #ffffff;
}
.onekey-login-title.forbid {
	text-align: center;
	padding-bottom: 3px;
	font-size: 14px;
	font-weight: normal;
	line-height: 30px;
	color: white;
}
</style><style>#login_mask {
  background: #000;
  opacity: 0.5;
  filter: alpha(opacity=50);
  position: fixed;
  /*fixed好像在哪个IE上有BUG，先用用*/
  left: 0;
  top: 0;
  z-index: 999;
  height: 100%;
}

#login_iframe_container {
  position: fixed;
  width: 550px;
  height: 360px;
  z-index: 1020;
  background-color: #ffffff;
}

@media screen and (max-width: 828px) {
  #login_iframe_container {
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%);
  }
}

#login_iframe_container.new-login {
  width: 550px;
  height: 360px;
  background-image: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/background_2a4a8a6.png);
}

#login_iframe_container.new-login.no-bg {
  background: #fff;
}

#login_iframe_container.new-login .login-title {
  width: 100%;
  height: 42px;
  line-height: 42px;
  text-align: center;
  font-size: 30px;
  letter-spacing: 0.19px;
  color: #ffffff;
  margin-top: 62px;
}
#login_iframe_container.new-login .forbid-title {
  width: 100%;
  height: 42px;
  line-height: 42px;
  text-align: center;
  font-size: 24px;
  letter-spacing: 0.19px;
  color: #333333;
  margin-top: 150px;
}

#login_iframe_container.new-login.no-bg .login-title {
  color: #333333;
}

#login_iframe_container.new-login .login-subtitle {
  width: 100%;
  height: 18px;
  line-height: 18px;
  font-size: 13px;
  letter-spacing: 0.08px;
  color: #ffffff;
  text-align: center;
  margin-top: 9px;
  margin-bottom: 43px;
}

#login_iframe_container.new-login.no-bg .login-subtitle {
  color: #999999;
}

#login_iframe_container.new-login .login-subtitle::before {
  content: '';
  display: inline-block;
  width: 10px;
  height: 1px;
  background-color: #ffffff;
  position: relative;
  top: -4px;
  left: -5px;
}

#login_iframe_container.new-login .login-subtitle::after {
  content: '';
  display: inline-block;
  width: 10px;
  height: 1px;
  background-color: #ffffff;
  position: relative;
  top: -4px;
  left: 5px;
}

#login_iframe_container.new-login.no-bg .login-subtitle::before {
  background-color: #999999;
}

#login_iframe_container.new-login.no-bg .login-subtitle::after {
  background-color: #999999;
}

#login_iframe_container.new-login .close-btn {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 12px;
  height: 12px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -59px -10px;
  background-size: 81px 91px;
  cursor: pointer;
}

#login_iframe_container.new-login .login-btn {
  width: 220px;
  height: 47px;
  border-radius: 24px;
  border: solid 1px #dddddd;
  background-color: #ffffff;
  margin: 0 auto;
  margin-top: 28px;
  position: relative;
  display: block;
}

#login_iframe_container.new-login .login-btn .login-icon {
  position: absolute;
}

#login_iframe_container.new-login .login-btn .login-text {
  width: 61px;
  height: 47px;
  line-height: 47px;
  vertical-align: middle;
  font-size: 15px;
  letter-spacing: 0.1px;
  color: #666666;
  position: absolute;
  right: 62px;
}

#login_iframe_container.new-login .login-btn.qq-btn .login-icon {
  width: 22px;
  height: 27px;
  top: 10px;
  left: 67px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -10px -54px;
  background-size: 81px 91px;
}

#login_iframe_container.new-login .login-btn.qq-btn .login-text {
  right: 59px;
}

#login_iframe_container.new-login .login-btn.wechat-btn .login-icon {
  width: 29px;
  height: 24px;
  top: 12px;
  left: 62px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -10px -10px;
  background-size: 81px 91px;
}</style><style>/* -- container -- */
.rodal,
.rodal-mask {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
}

.rodal {
    position: fixed;
}

/* -- mask -- */
.rodal-mask {
    position: fixed;
    background: rgba(0, 0, 0, .5);
}

/* -- dialog -- */
.rodal-dialog {
    position: absolute;
    z-index: 101;
    background: #fff;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, .2);
}

.rodal-center {
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    right: 0;
    margin: 0 auto;
}

.rodal-bottom {
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

.rodal-top {
    left: 0;
    right: 0;
    top: 0;
    margin: auto;
}

.rodal-left {
    top: 0;
    left: 0;
    bottom: 0;
    margin: auto;
}

.rodal-right {
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

/* -- close button -- */
.rodal-close {
    position: absolute;
    cursor: pointer;
    top: 16px;
    right: 16px;
    width: 16px;
    height: 16px;
}

.rodal-close:before,
.rodal-close:after {
    position: absolute;
    content: '';
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: #999;
    border-radius: 100%;
    -webkit-transition: background .2s;
    transition: background .2s;
}

.rodal-close:before {
    -webkit-transform: rotate(45deg);
    transform: rotate(45deg);
}

.rodal-close:after {
    -webkit-transform: rotate(-45deg);
    transform: rotate(-45deg);
}

.rodal-close:hover:before,
.rodal-close:hover:after {
    background: #333;
}

/* -- fade -- */
/* @-webkit-keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

@keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

.rodal-fade-enter {
    -webkit-animation: rodal-fade-enter both ease-in;
    animation: rodal-fade-enter both ease-in;
} */

@-webkit-keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

@keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

.rodal-fade-leave {
    -webkit-animation: rodal-fade-leave both ease-out;
    animation: rodal-fade-leave both ease-out;
}

/* -- zoom -- */
@-webkit-keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-enter {
    -webkit-animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-leave {
    -webkit-animation: rodal-zoom-leave both;
    animation: rodal-zoom-leave both;
}

/* -- slideDown -- */
@-webkit-keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-enter {
    -webkit-animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-leave {
    -webkit-animation: rodal-slideDown-leave both;
    animation: rodal-slideDown-leave both;
}

/* -- slideLeft -- */
@-webkit-keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-enter {
    -webkit-animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-leave {
    -webkit-animation: rodal-slideLeft-leave both;
    animation: rodal-slideLeft-leave both;
}

/* -- slideRight -- */
@-webkit-keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-enter {
    -webkit-animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-leave {
    -webkit-animation: rodal-slideRight-leave both;
    animation: rodal-slideRight-leave both;
}

/* -- slideUp -- */
@-webkit-keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-enter {
    -webkit-animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
    animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
}

@-webkit-keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-leave {
    -webkit-animation: rodal-slideUp-leave both;
    animation: rodal-slideUp-leave both;
}

/* -- flip -- */
@-webkit-keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.rodal-flip-enter {
    -webkit-animation: rodal-flip-enter both ease-in;
    animation: rodal-flip-enter both ease-in;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

@-webkit-keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

@keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

.rodal-flip-leave {
    -webkit-animation: rodal-flip-leave both;
    animation: rodal-flip-leave both;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

/* -- rotate -- */
@-webkit-keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-enter {
    -webkit-animation: rodal-rotate-enter both;
    animation: rodal-rotate-enter both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

@-webkit-keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-leave {
    -webkit-animation: rodal-rotate-leave both;
    animation: rodal-rotate-leave both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

/* -- door -- */
@-webkit-keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

@keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

.rodal-door-enter {
    -webkit-animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

@keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

.rodal-door-leave {
    -webkit-animation: rodal-door-leave both;
    animation: rodal-door-leave both;
}</style><style>/* -- container -- */
.rodal,
.rodal-mask {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
}

.rodal {
    position: fixed;
}

/* -- mask -- */
.rodal-mask {
    position: fixed;
    background: rgba(0, 0, 0, .5);
}

/* -- dialog -- */
.rodal-dialog {
    position: absolute;
    z-index: 101;
    background: #fff;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, .2);
}

.rodal-center {
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    right: 0;
    margin: 0 auto;
}

.rodal-bottom {
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

.rodal-top {
    left: 0;
    right: 0;
    top: 0;
    margin: auto;
}

.rodal-left {
    top: 0;
    left: 0;
    bottom: 0;
    margin: auto;
}

.rodal-right {
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

/* -- close button -- */
.rodal-close {
    position: absolute;
    cursor: pointer;
    top: 16px;
    right: 16px;
    width: 16px;
    height: 16px;
}

.rodal-close:before,
.rodal-close:after {
    position: absolute;
    content: '';
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: #999;
    border-radius: 100%;
    -webkit-transition: background .2s;
    transition: background .2s;
}

.rodal-close:before {
    -webkit-transform: rotate(45deg);
    transform: rotate(45deg);
}

.rodal-close:after {
    -webkit-transform: rotate(-45deg);
    transform: rotate(-45deg);
}

.rodal-close:hover:before,
.rodal-close:hover:after {
    background: #333;
}

/* -- fade -- */
/* @-webkit-keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

@keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

.rodal-fade-enter {
    -webkit-animation: rodal-fade-enter both ease-in;
    animation: rodal-fade-enter both ease-in;
} */

@-webkit-keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

@keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

.rodal-fade-leave {
    -webkit-animation: rodal-fade-leave both ease-out;
    animation: rodal-fade-leave both ease-out;
}

/* -- zoom -- */
@-webkit-keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-enter {
    -webkit-animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-leave {
    -webkit-animation: rodal-zoom-leave both;
    animation: rodal-zoom-leave both;
}

/* -- slideDown -- */
@-webkit-keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-enter {
    -webkit-animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-leave {
    -webkit-animation: rodal-slideDown-leave both;
    animation: rodal-slideDown-leave both;
}

/* -- slideLeft -- */
@-webkit-keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-enter {
    -webkit-animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-leave {
    -webkit-animation: rodal-slideLeft-leave both;
    animation: rodal-slideLeft-leave both;
}

/* -- slideRight -- */
@-webkit-keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-enter {
    -webkit-animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-leave {
    -webkit-animation: rodal-slideRight-leave both;
    animation: rodal-slideRight-leave both;
}

/* -- slideUp -- */
@-webkit-keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-enter {
    -webkit-animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
    animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
}

@-webkit-keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-leave {
    -webkit-animation: rodal-slideUp-leave both;
    animation: rodal-slideUp-leave both;
}

/* -- flip -- */
@-webkit-keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.rodal-flip-enter {
    -webkit-animation: rodal-flip-enter both ease-in;
    animation: rodal-flip-enter both ease-in;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

@-webkit-keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

@keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

.rodal-flip-leave {
    -webkit-animation: rodal-flip-leave both;
    animation: rodal-flip-leave both;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

/* -- rotate -- */
@-webkit-keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-enter {
    -webkit-animation: rodal-rotate-enter both;
    animation: rodal-rotate-enter both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

@-webkit-keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-leave {
    -webkit-animation: rodal-rotate-leave both;
    animation: rodal-rotate-leave both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

/* -- door -- */
@-webkit-keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

@keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

.rodal-door-enter {
    -webkit-animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

@keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

.rodal-door-leave {
    -webkit-animation: rodal-door-leave both;
    animation: rodal-door-leave both;
}</style>
<!--百度统计-->
<script>
   var _hmt = _hmt || [];
   (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c7614be3026469d5a60f41ab30b5082";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
      })();
</script>
</head>
<body class=""><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(675,27,25,2,"web","https://baike.sogou.com/kexue/d10392.htm","20221025113656",1996,"/_static/",["/_static/css/banner-styles.css?v=S1zqJCYt","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT --><script>window._gtag=window._gtag||{};window._gtag.shouldGrayed = false;if ('f9bc09561c1a40cca221680e566d855e') window._gtag.traceId = 'f9bc09561c1a40cca221680e566d855e';if ({"illegality":true}) window.userInfo = {"illegality":true};</script><div class="topnavbox"><ul class="topnav"><li><a href="https://web.archive.org/web/20221025113656/https://www.sogou.com/web?query=">网页</a></li><li><a href="https://web.archive.org/web/20221025113656/https://weixin.sogou.com/weixin?p=75351201">微信</a></li><li><a href="https://web.archive.org/web/20221025113656/https://zhihu.sogou.com/zhihu?p=75351218">知乎</a></li><li><a href="https://web.archive.org/web/20221025113656/https://pic.sogou.com/pics?query=">图片</a></li><li><a href="https://web.archive.org/web/20221025113656/https://v.sogou.com/v?query=">视频</a></li><li><a href="https://web.archive.org/web/20221025113656/https://mingyi.sogou.com/">医疗</a></li><li class="cur"><strong>科学</strong></li><li><a href="https://web.archive.org/web/20221025113656/https://hanyu.sogou.com/">汉语</a></li><li><a href="https://web.archive.org/web/20221025113656/https://wenwen.sogou.com/">问问</a></li><li><a href="https://web.archive.org/web/20221025113656/https://www.sogou.com/docs/more.htm">更多<span class="topraquo">»</span></a></li></ul></div><div id="header"><div class="header-wrap"><a class="header-logo" href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue"></a><div class="header-search"><div class="querybox" id="suggBox"><form><input id="searchInput" class="query" type="text" placeholder="搜科学领域专业百科词条" name="query" autocomplete="off" value=""><a href="javascript:;" class="query-search"></a></form></div></div><div class="header-rgt"><span class="btn-header-rgt btn-edit" id="editLemma">创建</span><div class="header-user no-login"></div></div></div></div><div class="fixed-placeholder" style="visibility:none"></div><div id="container" class=""><div class="content lemma-level1"><div class="detail-title" id="abstract-title"><h1>算法</h1><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#!" class="detail-edit">编辑</a></div><div class="section_content" data-id="53964833581752086"><div class="text_img ed_imgfloat_right"><a class="ed_image_link" data-src="https://img04.sogoucdn.com/app/a/200698/sogou_science_4716" data-bigsrc="https://img04.sogoucdn.com/app/a/200698/sogou_science_4716?width=231&amp;height=174&amp;titlename=Flowchart%20of%20an%20algorithm%20(Euclid&#39;s%20algorithm)%20for%20calculating%20the%20greatest%20common%20divisor%20(g.c.d.)%20of%20two%20numbers%20a%20and%20b%20in%20locations%20named%20A%20and%20B.%20The%20algorithm%20proceeds%20by%20successive%20subtractions%20in%20two%20loops:%20IF%20the%20test%20B%20%E2%89%A5%20A%20yields%20%22yes%22%20(or%20true)%20(more%20accurately%20the%20number%20b%20in%20location%20B%20is%20greater%20than%20or%20equal%20to%20the%20number%20a%20in%20location%20A)%20THEN,%20the%20algorithm%20specifies%20B%20%E2%86%90%20B%20%E2%88%92%20A%20(meaning%20the%20number%20b%20%E2%88%92%20a%20replaces%20the%20old%20b).%20Similarly,%20IF%20A%20%3E%20B,%20THEN%20A%20%E2%86%90%20A%20%E2%88%92%20B.%20The%20process%20terminates%20when%20(the%20contents%20of)%20B%20is%200,%20yielding%20the%20g.c.d.%20in%20A.%20(Algorithm%20derived%20from%20Scott%202009:13;%20symbols%20and%20drawing%20style%20from%20Tausworthe%201977).&amp;w=300&amp;h=675" title="点击查看大图" data-w="300" data-h="675" style="background-image:url(https://web.archive.org/web/20221025113656im_/https://img04.sogoucdn.com/app/a/200698/sogou_science_4716)" href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#!"></a><div class="text_img_title">Flowchart of an algorithm (Euclid's algorithm) for calculating the greatest common divisor (g.c.d.) of two numbers a and b in locations named A and B. The algorithm proceeds by successive subtractions in two loops: IF the test B ≥ A yields "yes" (or true) (more accurately the number b in location B is greater than or equal to the number a in location A) THEN, the algorithm specifies B ← B − A (meaning the number b − a replaces the old b). Similarly, IF A &gt; B, THEN A ← A − B. The process terminates when (the contents of) B is 0, yielding the g.c.d. in A. (Algorithm derived from Scott 2009:13; symbols and drawing style from Tausworthe 1977).</div></div><div><p>在数学和计算机科学中，算法是如何解决一类问题的明确规范。算法可以执行计算、数据处理、自动推理和其他任务。</p>
<p>作为一种有效的方法，算法可以在有限的空间和时间内用定义明确的形式语言<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_1" class="kx_ref">[1]</a></sup> 来表示，以计算函数<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_2" class="kx_ref">[2]</a></sup> <sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_3" class="kx_ref">[3]</a></sup> 。从初始状态和初始输入(可能为空)开始，<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_4" class="kx_ref">[4]</a></sup> 指令描述了一种计算，当执行该计算时，该计算通过有限的<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_5" class="kx_ref">[5]</a></sup> 数量的明确定义的连续状态，最终产生的“输出”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_6" class="kx_ref">[6]</a></sup> 并终止于最终结束状态。从一种状态到下一种状态的转变不一定是 明确的；一些被称为随机算法的算法包含随机输入。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_7" class="kx_ref">[7]</a></sup> </p>
<p>算法的概念已经存在了几个世纪。希腊数学家使用 Eratosthenes筛子中的算法寻找素数，欧几里德算法寻找两个数的最大公约数。 </p>
<p>“算法”一词本身源自9世纪数学家muḥammad· ibn Mūsā al-Khwārizmī的拉丁化算法。后来成为现代算法概念的部分 规范化始于1928年 David Hilbert提出的解决判定问题 (决策问题)的尝试。后来的 规范化被 看作试图定义“有效可计算性”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_8" class="kx_ref">[8]</a></sup> 或“有效方法”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_9" class="kx_ref">[9]</a></sup> 这些 规范化包括1930年、1934年和1935年的 Gödel–Herbrand–Kleene递归函数，1936年的 Alonzo Church的λ微积分，1936年的 Emil Post公式1，以及1936-37年和1939年 Alan Turing的图灵机。</p></div></div><div id="catalog"><h2 class="title2">目录<a href="javascript:" class="detail-edit">编辑</a></h2><div class="catalog_wrap" style=""><ul class="catalog_list col4"><li><span class="order">1</span><a href="javascript:" data-level="1" data-id="14995099515617542">词源</a></li><li><span class="order">2</span><a href="javascript:" data-level="1" data-id="14995099515617543">非正式定义</a></li><li><span class="order">3</span><a href="javascript:" data-level="1" data-id="14995099515617544">形式化</a></li><li class="secondary_catalog"><span>3.1 </span><a href="javascript:" data-id="14995099515617544">表达算法</a></li><li><span class="order">4</span><a href="javascript:" data-level="1" data-id="14995099532394758">设计</a></li><li><span class="order">5</span><a href="javascript:" data-level="1" data-id="14995099532394759">履行</a></li><li><span class="order">6</span><a href="javascript:" data-level="1" data-id="14995099532394760">计算机算法</a></li><li><span class="order">7</span><a href="javascript:" data-level="1" data-id="14995099532394761">例子</a></li><li class="secondary_catalog"><span>7.1 </span><a href="javascript:" data-id="14995099532394761">算法示例</a></li><li class="secondary_catalog"><span>7.2 </span><a href="javascript:" data-id="14995099532394761">欧几里得算法</a></li><li class="secondary_catalog"><span>7.3 </span><a href="javascript:" data-id="14995099532394761">测试欧几里得算法</a></li><li class="secondary_catalog"><span>7.4 </span><a href="javascript:" data-id="14995099532394761">欧几里得算法的度量和改进</a></li></ul><ul class="catalog_list col4"><li><span class="order">8</span><a href="javascript:" data-level="1" data-id="14995099549171979">算法分析</a></li><li class="secondary_catalog"><span>8.1 </span><a href="javascript:" data-id="14995099549171979">形式化方法 与 经验方法</a></li><li class="secondary_catalog"><span>8.2 </span><a href="javascript:" data-id="14995099549171979">执行效率</a></li><li><span class="order">9</span><a href="javascript:" data-level="1" data-id="14995099549171980">分类</a></li><li class="secondary_catalog"><span>9.1 </span><a href="javascript:" data-id="14995099549171980">通过实现方法</a></li><li class="secondary_catalog"><span>9.2 </span><a href="javascript:" data-id="14995099549171980">通过设计 范例</a></li><li class="secondary_catalog"><span>9.3 </span><a href="javascript:" data-id="14995099549171980">优化问题</a></li><li class="secondary_catalog"><span>9.4 </span><a href="javascript:" data-id="14995099549171980">按研究领域</a></li><li class="secondary_catalog"><span>9.5 </span><a href="javascript:" data-id="14995099549171980">按复杂性</a></li><li><span class="order">10</span><a href="javascript:" data-level="1" data-id="14995099549171981">连续算法</a></li><li><span class="order">11</span><a href="javascript:" data-level="1" data-id="14995099549171982">法律问题</a></li></ul><ul class="catalog_list col4"><li><span class="order">12</span><a href="javascript:" data-level="1" data-id="14995099549171983">历史:“算法”概念的发展</a></li><li class="secondary_catalog"><span>12.1 </span><a href="javascript:" data-id="14995099549171983">古代近东</a></li><li class="secondary_catalog"><span>12.2 </span><a href="javascript:" data-id="14995099549171983">离散和可区分的符号</a></li><li class="secondary_catalog"><span>12.3 </span><a href="javascript:" data-id="14995099549171983">作为数字“占位符”的符号操作:代数</a></li><li class="secondary_catalog"><span>12.4 </span><a href="javascript:" data-id="14995099549171983">具有离散状态的机械装置</a></li><li class="secondary_catalog"><span>12.5 </span><a href="javascript:" data-id="14995099549171983">从19世纪到20世纪中期的数学</a></li><li class="secondary_catalog"><span>12.6 </span><a href="javascript:" data-id="14995099549171983">Emil Post (1936)和 Alan Turing (1936-37，1939)</a></li></ul><ul class="catalog_list col4"><li class="secondary_catalog"><span>12.7 </span><a href="javascript:" data-id="14995099549171983">J.B. Rosser (1939)和S.C. Kleene&nbsp; (1943)</a></li><li class="secondary_catalog"><span>12.8 </span><a href="javascript:" data-id="14995099549171983">1950年后的历史</a></li><li><span class="order">13</span><a href="javascript:" data-level="1" data-id="14995099565949198">笔记</a></li><li><span class="order">14</span><a href="javascript:" data-level="1" data-id="14995099565949199">文献学</a></li><li><span class="order">15</span><a href="javascript:" data-level="1" data-id="references">参考文献</a></li></ul></div></div><div id="paragraphs"><div><div id="par_14995099515617542"><h2 class="title">1 词源<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>“算法”一词起源于将 Muhammad ibn Musa al-Khwarizmi的名字拉丁化，这是 算法书的第一步。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_10" class="kx_ref">[10]</a></sup><sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_11" class="kx_ref">[11]</a></sup>Al-Khwārizmī(阿拉伯语:الخوارزمي‎，波斯语:خوارزمی‎，约780-850年)是巴格达智慧宫的波斯数学家、天文学家、地理学家和学者，他的名字的意思是“Khwarazm的本地人”， Khwarazm是大伊朗的一部分，现在在乌兹别克斯坦。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_12" class="kx_ref">[12]</a></sup><sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_13" class="kx_ref">[13]</a></sup> </p><p>大约在825年， al-Khwarizmi写了一篇关于印度-阿拉伯数字系统的阿拉伯语论文，该论文在12世纪被翻译成拉丁文，题目是《 Algoritmi de numero Indorum》。这个标题的意思是“印第安人数字上的 Algoritmi”，其中“ Algoritmi”是译者对 Al-Khwarizmi名字的拉丁化。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_14" class="kx_ref">[14]</a></sup>Al-Khwarizmi是中世纪晚期被 欧洲阅读最广泛的数学家，主要是通过他的另一本书《代数》。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_15" class="kx_ref">[15]</a></sup> 在中世纪晚期的拉丁语中，algorismus，英语中的“algorism”，都是他的名字的 传讹，仅仅意味着“十进制数字系统”。在15世纪，在希腊单词ἀριθμός“number”(参见“算术”)的影响下，拉丁语单词被改为algorithmus，相应的英语术语“algorithm”在17世纪首次得到证实；现代意义是在19世纪引入的。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_16" class="kx_ref">[16]</a></sup> </p><p>在英语中，它首先在1230年左右 被使用，然后在1391年被乔叟使用。英语采用了法语术语，但是直到19世纪末，“算法”才具有现代英语中的含义。</p><p>这个词的另一个早期用法是从1240年开始的，在 Alexandre de Villedieu撰写的一本名为《 Carmen de Algorismo》的手册中。它是这样开始的:</p><p><i>Haec algorismus ars praesens dicitur, in qua / Talibus Indorum fruimur bis quinque figuris.</i></p><p>其翻译为:</p><p>算法是一门通过现在我们使用印度数字的艺术， 数字是2乘以5。</p><p>这首诗有几百行长，总结了用印度骰子或印度数字的新风格计算的艺术。</p></div></div><div id="par_14995099515617543"><h2 class="title">2 非正式定义<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>有关“算法”定义的各种观点的详细介绍，请参见算法特性。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_17" class="kx_ref">[17]</a></sup> 非正式定义可以是“一组精确定义操作序列的规则”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_18" class="kx_ref">[18]</a></sup>这将包括所有计算机程序，包括不执行数值计算的程序。一般来说，程序只有在最终停止时才是算法。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_19" class="kx_ref">[19]</a></sup> </p><p>算法的一个典型例子是欧几里德算法，用于确定两个整数的最大公约数；上面的流程图描述了一个示例(还有其他示例),并且在后面的部分中作为一个示例。</p><p>Boolos，Jeffrey &amp; 1974，1999在下面的引文中给出了这个词的非正式含义:</p><p>没有人能写得足够快、足够长或足够小...（小得没有限度， 你会试图写在分子、原子、电子上)，通过用某种符号一个接一个地写出它们的名字来列出一个可列举的无限集合的所有成员。但是人类可以做一些同样有用的事情，在某些可列举的无限集合的情况下:对于任意有限的n，他们可以给出明确的指令来确定集合的第n个成员。这样的指令可以非常明确地给出，其形式是计算机或者只能对符号进行非常基本的运算的人可以 做到的。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_20" class="kx_ref">[20]</a></sup></p><p>“可枚举无限集合”是指其元素可以与整数一一对应的集合。因此， Boolos和 Jeffrey说，一个算法意味着一个过程的指令，该过程从任意的“输入”整数或者理论上可以任意大的整数“创建”输出整数 。因此，一个算法可以是一个代数方程，比如y = m+n——两个任意的“输入变量”m和n，它们产生一个输出y。但是，不同作者对这个概念的定义表明，这个词隐含的意义远远不止于此，大约是(对于加法例子):</p><p>
 </p><dl>
  <dd>
   精确的指令(以“计算机”理解的语言) &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_21" class="kx_ref">[21]</a></sup> 用于快速、高效的“良好” &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_22" class="kx_ref">[22]</a></sup> 过程，该过程指定“计算机”(机器或人类，配备有必要的内部包含的信息和能力)的“移动”， &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_23" class="kx_ref">[23]</a></sup> 来查找、解码，然后处理任意输入的整数/符号m和n，符号+和=...和“有效地” &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_24" class="kx_ref">[24]</a></sup> 在“合理”时间内，在指定地点以指定格式&nbsp; 生成 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_25" class="kx_ref">[25]</a></sup> 输出整数y。
  </dd>
 </dl><p></p><p>算法的概念也被用来定义可判定性的概念。这个概念对于解释 正式系统是如何从一小组公理和规则开始形成的至关重要。在逻辑上，一个算法完成所需的时间是无法测量的，因为它显然与我们习惯的物理维度无关。这种不确定性是正在进行的工作的特征，这种不确定性导致无法找到既适合具体(在某种意义上)又适合抽象术语使用的算法定义。</p></div></div><div id="par_14995099515617544"><h2 class="title">3 形式化<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>算法对计算机处理数据的方式至关重要。许多计算机程序都包含算法，这些算法详细说明了计算机执行特定任务(以特定顺序)应该执行的特定指令，例如计算员工工资或打印学生成绩单。因此，算法可以被认为是图灵完备系统可以模拟的任何操作序列。主张这一论点的作者包括 Minsky (1967)、 Savage (1987)和 Gurevich (2000):</p><p>Minsky:“但我们也会坚持，图灵...任何可以“自然地”被称为有效的程序，实际上可以通过(简单的)机器来实现。尽管这看起来有些极端，但争论...对它有利是很难反驳的”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_26" class="kx_ref">[26]</a></sup></p><p>Gurevich:"...图灵支持他论文的非正式论点证明了一个更强有力的论点:每种算法都可以由图灵机模拟...根据 Savage [1987)，算法是由图灵机定义的计算过程。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_27" class="kx_ref">[27]</a></sup></p><p>通常，当算法与处理信息相关联时，数据可以从输入源读取，写入输出设备并存储以供进一步处理。存储的数据被视为执行算法的实体的内部状态的一部分。实际上，状态存储在一个或多个数据结构中。</p><p>对于一些这样的计算过程，算法必须被严格定义:在所有可能出现的情况下以其应用的方式指定。也就是说，任何有条件的步骤都必须系统地 逐一处理；每个案例的标准必须清晰(并且是可计算的)。</p><p>因为算法是精确步骤的精确列表，所以计算顺序对于算法的运行总是至关重要的。指令通常被认为是明确列出的，并且被描述为从“顶部”开始到“底部”，这种思想被更正式地描述为控制流。</p><p>到目前为止，关于算法形式化的讨论已经假定了命令式编程的前提。这是最常见的概念，它试图以离散的“机械”方式描述一项任务。这种形式化算法概念的独特之处在于赋值操作，它设置变量的值。它源于“记忆”作为便笺簿的直觉。下面有一个这样的例子。</p><p>关于算法构成的一些替代概念，请参见函数编程和逻辑编程。</p><p></p><h3>3.1 <span>表达算法</span></h3><p></p><p>算法可以用多种符号表示，包括自然语言、伪代码、流程图、drakon图表、编程语言或控制表(由解释器处理)。算法的自然语言表达往往冗长而模糊，很少用于复杂或技术性的算法。伪代码、流程图、drakon图表和控制表是表达算法的结构化方式，避免了自然语言语句中常见的许多歧义。编程语言主要用于以计算机可以执行的形式表达算法，但通常被用作定义或记录算法的一种方式。</p><p>有很多种可能的表示，可以将一个给定的图灵机程序表示为一系列的机器表(见有限状态机、状态转换表和控制表)，流程图和drakon图(见状态图)，或者表示为一种称为“四元组”的基本机器代码或汇编代码(见图灵机)。</p><p>算法的表示可以分为图灵机描述的三个公认的层次:<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_28" class="kx_ref">[28]</a></sup> </p><p>
 </p><dl>
  <dt>
   1高级描述
  </dt>
  <dd>
   "...散文来描述算法，忽略实现细节。在这个级别上，我们不需要提及机器是如何管理其磁带或磁头的。”
  </dd>
  <dt>
   2实施说明
  </dt>
  <dd>
   "...散文用来定义图灵机使用磁头的方式和在磁带上存储数据的方式。在这个层次上，我们不给出状态或转换函数的细节。”
  </dd>
  <dt>
   3 形式化描述
  </dt>
  <dd>
   最详细的“最低级别”给出了图灵机的“状态表”。 有关在所有三个级别中描述的简单算法“添加m+n”的示例，请参见算法#示例。
  </dd>
 </dl><p></p></div></div><div id="par_14995099532394758"><h2 class="title">4 设计<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>算法设计是指解决问题和工程算法的方法或数学过程。算法设计是运筹学中许多求解理论的一部分，如动态规划和分治法。设计和实现算法设计的技术也被称为算法设计模式，<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_29" class="kx_ref">[29]</a></sup> 例如模板方法模式和装饰模式。</p><p>算法设计的一个最重要的方面是创建一个具有高效运行时间的算法，也称为“大 O”</p><p>算法开发的典型步骤:</p><p>1.问题定义</p><p>2.模型的开发</p><p>3.算法说明</p><p>4.设计算法</p><p>5.检查算法的正确性</p><p>6.算法分析</p><p>7.算法的实现</p><p>8.程序测试</p><p>9.文件准备</p></div></div><div id="par_14995099532394759"><h2 class="title">5 履行<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img03.sogoucdn.com/app/a/200698/sogou_science_4717" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">Logical NAND algorithm implemented electronically in 7400 chip</div>   
        </div> <p></p><p>实现大多数算法都是以计算机程序的形式实现的。然而，算法也可以通过其他方式实现，例如在生物神经网络(例如，人类大脑实现算法或昆虫寻找食物)、电路或机械设备中。</p></div></div><div id="par_14995099532394760"><h2 class="title">6 计算机算法<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img04.sogoucdn.com/app/a/200698/sogou_science_136" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">Flowchart examples of the canonical Böhm-Jacopini structures: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (IF test=true THEN GOTO step xxx) (a diamond), the unconditional GOTO (rectangle), various assignment operators (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100, 114).</div>   
        </div> <p></p><p>在计算机系统中，算法基本上是软件开发人员用软件编写的逻辑实例， 使预定的“目标”计算机能够有效地从给定(可能为空)输入生成输出。一个最优算法，即使在旧硬件中运行，也会比在更高效的硬件中运行的非最优(时间复杂度更高)算法产生更快的结果；这就是为什么算法，像计算机硬件一样 ，被认为是技术的原因 。</p><p>“优雅”(紧凑)程序，“良好”(快速)程序:“简单和优雅”的概念非正式地产生 于 Knuth， 准确的产生于Chaitin:</p><p>Knuth:"...我们想要一些定义松散的美学意义上的好算法。一个标准...执行算法所花费的时间长度....其他标准是算法对计算机的适应性、简单性和优雅性等”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_30" class="kx_ref">[30]</a></sup> </p><p>
 </p><dl>
  <dd>
   Chaitin: "...一个程序是“优雅的”，我的意思是它是产生输出的最小可能的程序&nbsp; 。” &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_31" class="kx_ref">[31]</a></sup> 
  </dd>
 </dl><p></p><p>Chaitin在他的定义前写道:“我会证明你不能证明一个程序是‘优雅的’”——这样的证明可以解决&nbsp; 停机问题(同上)。</p><p>算法与可由算法计算的函数:对于给定的函数，可能存在多种算法。这是真的，即使没有扩展程序员可用的指令集。 Rogers观察到“是的...区分算法概念(即过程)和可由算法计算的函数概念(即过程产生的映射)很重要。同一函数可能有几种不同的算法”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_32" class="kx_ref">[32]</a></sup> </p><p>不幸的是，在好(速度)和优雅(紧凑)之间可能会有一个折衷——一个优雅的程序可能比一个不那么优雅的程序需要更多的步骤来完成一个计算。下面是一个使用欧几里德算法的例子。</p><p>计算机 ，计算模型:计算机(或人类“计算机”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_33" class="kx_ref">[33]</a></sup>)是一种受限制的机器，一种盲目遵循指令的“离散确定性机械装置”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_34" class="kx_ref">[34]</a></sup> <sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_35" class="kx_ref">[35]</a></sup> Melzak和 Lambek的原始模型<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_36" class="kx_ref">[36]</a></sup> 将这一概念简化为四个要素:(1)离散的、可区分的位置，(2)离散的、不可区分的计数器<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_37" class="kx_ref">[37]</a></sup> (3)代理，以及(4)相对于代理能力有效的指令列表。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_38" class="kx_ref">[38]</a></sup> </p><p>Minsky在他的《可计算性的非常简单的基础》中描述了 Lambek的“算盘”模型的一个更相似的变体。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_39" class="kx_ref">[39]</a></sup> Minsky的机器通过它的五条(或六条，取决于如何计数)指令按顺序运行，除非有条件的“ IF–THEN GOTO”或无条件的“ GOTO”改变了程序的顺序。除了 停止， Minsky的机器还包括三个赋值(替换， 置换)<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_40" class="kx_ref">[40]</a></sup> 操作:零(例如位置内容被0: L←0替换)、后继(例如 L← L+1)和递减(例如 L ← L − 1)。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_41" class="kx_ref">[41]</a></sup> 程序员很少用如此有限的指令集编写“代码”。但是 Minsky (像 Melzak和Lambek一样)表明，他的机器是只包括 四种通用类型的指令的图灵机:条件GOTO、无条件GOTO、赋值/替换/替换和 停止。然而，为了 图灵机完整性，还需要一些不同的赋值指令(例如， Minsky机器的减量、增量和零/清除/空指令)；他们的具体规格多少取决于 设计者。无条件的GOTO是一种便利；它可以通过将专用位置初始化为零来构建，例如指令“Z←0”；此后，指令如果Z=0，那么转到xxx是无条件的。</p><p>算法模拟:计算机 语言:Knuth建议读者，“学习算法的最好方法是尝试一下 ……立即拿起笔和纸，举一个例子”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_42" class="kx_ref">[42]</a></sup> 但是真实事物的模拟或执行呢？程序员必须将算法翻译成模拟器/计算机 能够有效执行的语言。 Stone举了一个例子:当计算二次方程的根时，计算机必须知道如何求平方根。如果没有，那么算法要想有效，就必须提供一套提取平方根的规则。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_43" class="kx_ref">[43]</a></sup> </p><p>这意味着程序员必须知道一种相对于目标计算代理(计算机 )有效的“语言”。</p><p>但是模拟应该使用什么模型呢？ Van Emde Boas观察到，“即使我们把复杂性理论建立在抽象而不是具体的机器上，模型选择的任意性仍然存在。正是在这一点上，模拟的概念出现了”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_44" class="kx_ref">[44]</a></sup> 当测量速度时，指令集很重要。例如，欧几里德算法中计算余数的子程序，如果程序员有一条“模数”指令可用，而不仅仅是减法(或者更糟的是，只有 Minsky的“减量”)，执行起来会快得多。</p><p>结构化编程，规范结构:根据 Church–Turing理论，任何算法都可以通过已知的图灵完全模型来计算，根据 Minsky的演示，图灵 完备只需要四种指令类型——条件GOTO，无条件GOTO，赋值， 停止。Kemeny和Kurtz观察到，虽然无条件GOTOs和有条件IF-THEN GOTOs的“无纪律”使用会导致“意大利面代码”，但程序员可以只使用这些指令编写结构化程序；另一方面，“用结构化语言编写结构不良的程序也是可能的，而且不会太难”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_45" class="kx_ref">[45]</a></sup> Tausworthe增加了三个Böhm-Jacopini规范 结构:<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_46" class="kx_ref">[46]</a></sup> 序列， IF-THEN-ELSE，和 WHILE-DO，还有两个: DO-WHILE和案例。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_47" class="kx_ref">[47]</a></sup> 结构化程序的另一个好处是它有助于用数学归纳法证明正确性。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_48" class="kx_ref">[48]</a></sup> </p><p><i>标准流程图符号<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_49" class="kx_ref">[49]</a></sup></i>:称为流程图的图形助手，提供了一种描述和记录算法(和一个计算机程序)的方法。就像 Minsky机器的程序流程一样，流程图总是从页面的顶部开始向下进行。它的主要符号只有四个:显示程序流的有向箭头、矩形(序列、 GOTO)、菱形( IF-THEN-ELSE)和点( OR-tie)。 Böhm–Jacopini规范结构是由这些原始形状组成的。子结构可以“嵌套”在矩形中，但前提是上部结构只有一个出口。图中显示了这些符号及其用于构建规范结构的用途。</p></div></div><div id="par_14995099532394761"><h2 class="title">7 例子<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p></p><h3>7.1 <span>算法示例</span></h3><p></p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img02.sogoucdn.com/app/a/200698/sogou_science_4718" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">An animation of the quicksort algorithm sorting an array of randomized values. The red bars mark the pivot element; at the start of the animation, the element farthest to the right-hand side is chosen as the pivot.</div>   
        </div> <p></p><p>最简单的算法之一是在随机顺序的数字列表中找到最大的数字。找到解决方案需要查看列表中的每个数字。由此可以得出一个简单的算法，可以用英语散文的高级描述来表述:</p><p><i>高级描述:</i> </p><p>
 </p><ol>
  <li>如果集合中没有数字，那么就没有最高的数字。</li>
  <li>假设集合中的第一个数字是集合中最大的数字。</li>
  <li>对于集合中的每个剩余数:如果该数大于当前最大数，则认为该数是集合中的最大数。</li>
  <li>当集合中没有剩余要迭代的数时，将当前最大的数视为集合中最大的数。</li>
 </ol><p></p><p><i>(准)形式描述:</i> 以下是更正式的伪代码语句编码或洋泾浜编码:</p><p></p><pre class="kx_code"><b>Algorithm</b> LargestNumber
  输入:数字列表 <i>L²</i>。
  输出:列表中最大的数字 <i>L²</i>。</pre><p></p><p></p><pre class="kx_code">  如果 <i>l .尺寸</i> = 0返回null  <i>最大的</i> ⅲ <i>L²</i>[0]
  对于每一个 <i>项目</i> 在 <i>L²</i>，做
    如果 <i>项目</i> &gt; <i>最大的</i>那么      <i>最大的</i> ⅲ <i>项目</i>
  返回 <i>最大的</i></pre><p></p><p>
 </p><ul>
  <li>"←" denotes assignment. For instance, "<i>largest</i> ← <i>item</i>" means that the value of <i>largest</i> changes to the value of <i>item</i>.</li>
  <li>"<b>return</b>" terminates the algorithm and outputs the following value.</li>
 </ul><p></p><p></p><h3>7.2 <span>欧几里得算法</span></h3><p></p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img04.sogoucdn.com/app/a/200698/sogou_science_134" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">The example-diagram of Euclid's algorithm from T.L. Heath (1908), with more detail added. Euclid does not go beyond a third measuring and gives no numerical examples. Nicomachus gives the example of 49 and 21: "I subtract the less from the greater; 28 is left; then again I subtract from this the same 21 (for this is possible); 7 is left; I subtract this from 21, 14 is left; from which I again subtract 7 (for this is possible); 7 is left, but 7 cannot be subtracted from 7." Heath comments that "The last phrase is curious, but the meaning of it is obvious enough, as also the meaning of the phrase about ending 'at one and the same number'."(Heath 1908:300).</div>   
        </div> <p></p><p>欧几里得计算两个数的最大公约数算法在他的第七卷《初等数论》中作为命题二出现 <i>元素</i>。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_50" class="kx_ref">[50]</a></sup> 欧几里得这样提出了这个问题:“给定两个互不质数，找到它们最大的公共测度”。他将“[数”定义为]由单位组成的群体:计数数，不包括零的正整数。“测量”是放置较短的测量长度 <i>s</i> 连续(<i>q</i> 时间)沿着更长的长度 <i>l</i> 直到剩余部分 <i>r</i> 小于较短的长度 <i>s</i>。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_51" class="kx_ref">[51]</a></sup> 用现代话说，余数 <i>r</i> = <i>l</i> − <i>q</i>×<i>s</i>, <i>q</i> 是商，或余数 <i>r</i> 是“模数”，除法之后剩下的整数分数部分。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_52" class="kx_ref">[52]</a></sup> </p><p>欧几里得方法要成功，起始长度必须满足两个要求:(1)长度不能为零，(2)减法必须“正确”；也就是说，一个测试必须保证两个数字中较小的那个被从较大的那个中减去(或者，两个可以相等，所以它们的相减得到零)。</p><p>欧几里得的原始证明增加了第三个要求:两个长度不能互相质数。欧几里得这样规定是为了构造一个归谬反证法证明，证明两个数的共同测度实际上是 <i>最好的</i>。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_53" class="kx_ref">[53]</a></sup> 虽然尼科马库斯算法与欧几里得算法相同，但当这些数互为质数时，它们的公共测度会得到数“1”。所以，准确地说，下面是真正的尼科马库斯算法。</p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img03.sogoucdn.com/app/a/200698/sogou_science_138" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">A graphical expression of Euclid's algorithm to find the greatest common divisor for 1599 and 650.  1599 = 650×2 + 299
 650 = 299×2 + 52
 299 = 52×5 + 39
 52 = 39×1 + 13
 39 = 13×3 + 0</div>   
        </div> <p></p><p><strong>欧几里得算法的计算机语言</strong></p><p>只有几条指令 <i>类型</i> 需要执行欧几里得算法——一些逻辑测试(条件GOTO)、无条件GOTO、赋值(替换)和减法。</p><p>
 </p><ul>
  <li>A <i>位置</i> 用大写字母表示，如S、A等。</li>
  <li>位置中的变化量(数字)用小写字母书写，并且(通常)与位置名称相关联。例如，起始位置L可能包含数字 <i>l</i> = 3009。</li>
 </ul><p></p><p><strong>欧几里得算法的一个不雅程序</strong></p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img02.sogoucdn.com/app/a/200698/sogou_science_135" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">"Inelegant" is a translation of Knuth's version of the algorithm with a subtraction-based remainder-loop replacing his use of division (or a "modulus" instruction). Derived from Knuth 1973:2–4. Depending on the two numbers "Inelegant" may compute the g.c.d. in fewer steps than "Elegant".</div>   
        </div> <p></p><p>下面的算法被构造成克努特的欧几里得和尼科马库斯的四步版本，但是它没有使用除法来寻找余数，而是使用较短长度的连续减法 <i>s</i> 从剩余长度 <i>r</i> 直到 <i>r</i> 小于 <i>s</i>。粗体显示的高级描述改编自克努特1973:2–4:</p><p>输入:</p><p></p><pre class="kx_code">1 [分成两个位置，L和S把数字 <i>l</i> 和 <i>s</i> 代表两个长度]:
  输入L，S
2 [初始化R:剩下的长度 <i>r</i> 等于起始/初始/输入长度 <i>l</i>]:
  R ← L</pre><p></p><p>E0:[确保 <i>r</i> ≥ <i>s</i>。]</p><p></p><pre class="kx_code">3 [确保两个数字中较小的在S中，较大的在R中]:
  如果R &gt; S，则
    L的内容是更大的数字，所以略过交换-步骤4，5和6:
    转到步骤6
  其他
    交换R和s的内容。
4   L ← R(第一步是多余的，但对后面的讨论很有用)。
5   R ← S
6   S ← L</pre><p></p><p>E1:[找到余数]:直到剩余长度 <i>r</i> 在R小于较短的长度 <i>s</i> 在S中，重复减去测量数 <i>s</i> 剩余长度的S <i>r</i> 在r区</p><p></p><pre class="kx_code">7 如果S &gt; R，则
    完成测量
    GOTO 10
  其他
    再次测量，
8   R←R-S
9   [余数循环]:
    GOTO 7。</pre><p></p><p>E2:[余数为零吗？]:要么(I)最后一个度量是精确的，R中的余数为零，程序可以停止，要么(ii)算法必须继续:最后一个度量在R中留下的余数小于s中的度量数。</p><p></p><pre class="kx_code">10 如果R = 0，则
     这样做
     转到步骤15
   其他
     继续到步骤11，</pre><p></p><p>E3:[互通 <i>s</i> 和 <i>r</i>]:欧几里得算法的难点。使用余数 <i>r</i> 来测量以前较小的数字 <i>s</i>；我只是一个临时位置。</p><p></p><pre class="kx_code">11  L ← R
12  R ← S
13  S ← L
14  [重复测量过程]:
    GOTO 7</pre><p></p><p>输出:</p><p></p><pre class="kx_code">15 [完成。s包含最大公约数]:
   打印</pre><p></p><p>完成:</p><p></p><pre class="kx_code">16 停止，结束，停止。</pre><p></p><p><strong>欧几里得算法的优美程序</strong></p><p>The following version of Euclid's algorithm requires only six core instructions to do what thirteen are required to do by "Inelegant"; worse, "Inelegant" requires more <i>types</i> of instructions.<sup class="noprint Inline-Template">[需要解释]</sup> “优雅”的流程图可以在本文的顶部找到。在(非结构化)基础语言中，步骤被编号，指令 <code class="mw-highlight" dir="ltr"><span>LET</span> <span>[]</span> <span>=</span> <span>[]</span></code> 是用←符号表示的赋值指令。</p><p></p><pre class="kx_code"><code class="C"> &nbsp;5 REM Euclid's algorithm for greatest common divisor
 &nbsp;6 PRINT "Type two integers greater than 0"
 &nbsp;10 INPUT A,B
 &nbsp;20 IF B=0 THEN GOTO 80
 &nbsp;30 IF A &gt; B THEN GOTO 60
 &nbsp;40 LET B=B-A
 &nbsp;50 GOTO 20
 &nbsp;60 LET A=A-B
 &nbsp;70 GOTO 20
 &nbsp;80 PRINT A
 &nbsp;90 END</code></pre><p></p><p><i>“优雅”是如何运作的</i>:代替外部的“欧几里得环”，“优雅”在两个“共环”之间来回移动，A &gt; B环计算A←A-B，B ≤ A环计算B←B-A。 <i>s</i> (新的测量长度)和减数可以成为新的 <i>r</i> (要测量的长度)；换句话说，减法的“意义”颠倒了。</p><p>以下版本可用于面向对象语言:</p><p></p><pre class="kx_code"><code class="C">// Euclid's algorithm for greatest common divisor
int euclidAlgorithm (int A, int B){
 &nbsp; &nbsp; A=Math.abs(A);
 &nbsp; &nbsp; B=Math.abs(B);
 &nbsp; &nbsp; while (B!=0){
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (A&gt;B) A=A-B;
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else B=B-A;
 &nbsp; &nbsp; }
 &nbsp; &nbsp; return A;
}</code></pre><p></p><p></p><h3>7.3 <span>测试欧几里得算法</span></h3><p></p><p>一个算法做了作者希望它做的事情吗？一些测试用例通常会给核心功能带来一些信心。但是测试是不够的。对于测试用例，一个来源<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_54" class="kx_ref">[54]</a></sup> 使用3009和884。克努特建议40902，24140。另一个有趣的例子是两个互质数字14157和5950。</p><p>但是“例外情况”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_55" class="kx_ref">[55]</a></sup> 必须被识别和测试。当R &gt; S，S &gt; R，R = S时，“不优雅”会正常运行吗？“优雅”也是如此:B &gt; A，A &gt; B，A = B？(对所有人都是)。当一个数为零，两个数都为零时会发生什么？(“不雅”在所有情况下永远计算；当A = 0时，“优雅”将永远计算。)如果 <i>否定</i> 输入了数字？分数？如果输入数字，即由算法/程序计算的函数的域，只包括包括零的正整数，那么零的故障表明算法(以及实例化它的程序)是一个部分函数而不是一个总函数。一个值得注意的例外是阿丽亚娜5号飞行501火箭故障(1996年6月4日)。</p><p><i>用数学归纳法证明程序的正确性</i>:Knuth演示了数学归纳法在欧几里得算法“扩展”版本中的应用，并提出了“一种适用于证明任何算法有效性的通用方法”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_56" class="kx_ref">[56]</a></sup> 陶斯沃特提出，一个程序复杂性的度量标准是其正确性证明的长度。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_57" class="kx_ref">[57]</a></sup> </p><p></p><h3>7.4 <span>欧几里得算法的度量和改进</span></h3><p></p><p><i>优雅(紧凑)与善良(速度)</i>:只有六个核心指令，“优雅”是明显的赢家，相比之下，“不雅”是十三个指令。然而，“不雅”是 <i>更快的</i> (它以更少的步骤到达HALT)。算法分析<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_58" class="kx_ref">[58]</a></sup> 指出为什么会是这种情况:“优雅”确实如此 <i>二</i> 每个减法循环中的条件测试，而“不合格”只做一个。由于算法(通常)需要多次循环， <i>平均</i> 做“B = 0”会浪费很多时间仅在计算完余数后才需要的测试。</p><p><i>算法可以改进吗？</i>:一旦程序员判断一个程序“合适”和“有效”——也就是说，它计算出作者想要的函数——那么问题就变成了，它能被改进吗？</p><p>“不雅”的紧凑性可以通过消除五个步骤来提高。但是柴丁证明了压缩算法不能由广义算法自动完成；<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_59" class="kx_ref">[59]</a></sup> 相反，它只能启发式地完成；即通过详尽的搜索(例如在《忙碌的海狸》中找到的例子)、反复试验、聪明、洞察力、归纳推理的应用等。观察步骤4、5和6在步骤11、12和13中重复。与“优雅”的比较暗示了这些步骤以及步骤2和3可以被取消。这将核心指令的数量从十三个减少到八个，这使得它在九个步骤中比“优雅”更“优雅”。</p><p>移动“B=0”可以提高“优雅”的速度在两个减法循环之外进行测试。这种变化需要增加三条指令(B = 0？，A = 0？，GOTO)。现在“优雅”计算示例数的速度更快；对于任何给定的A、B和R、S是否总是这种情况，需要详细的分析。</p></div></div><div id="par_14995099549171979"><h2 class="title">8 算法分析<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>知道给定算法理论上需要多少特定资源(例如时间或存储)通常很重要。已经开发了用于分析算法以获得这种定量答案(估计)的方法；例如，上面的排序算法有一个时间要求为 O(n)，使用大 O符号，n作为列表的长度。在任何时候，算法只需要记住两个值:迄今为止找到的最大数字，以及它在输入列表中的当前位置。因此，如果不计算存储输入数字所需的空间，则称其空间要求为 O(1)，如果计算了，则称其为O (n)。</p><p>与其他算法相比，不同的算法可以用不同的指令集在更少或更多的时间、空间或“努力程度 ”内完成相同的任务。例如，当用于排序列表或数组上的表查找时，二进制搜索算法( 时间复杂度为 O(log n))优于顺序搜索( 时间复杂度为O (n))。</p><p></p><h3>8.1 <span>形式化方法 与 经验方法</span></h3><p></p><p>算法的分析和研究是计算机科学的一门学科，通常在不使用特定编程语言或实现的情况下进行抽象实践。在这个意义上，算法分析类似于其他数学学科，因为它关注算法的基本属性，而不是任何特定实现的细节。伪代码通常用于分析，因为它是最简单和最通用的表示。然而，最终，大多数算法通常在特定的硬件/软件平台上实现，并且它们的算法效率最终使用真实代码进行测试。对于“一次性”问题的解决，特定算法的效率可能不会产生重大影响(除非n非常大)，但对于为快速交互、商业或长寿命科学应用而设计的算法来说，这可能是至关重要的。从小n到大n的缩放经常暴露出 效率低下的算法，而这些算法在其他方面是优良的。</p><p>经验测试很有用，因为它可能会发现影响性能的意外交互。基准可以用来比较程序优化后算法的潜在改进前后效率提高 。然而，经验测试不能取代形式分析，以 直接的方式进行也不是小事。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_60" class="kx_ref">[60]</a></sup> </p><p></p><h3>8.2 <span>执行效率</span></h3><p></p><p>为了说明即使在成熟的算法中也可能有潜在的改进，与快速傅立叶变换算法(在图像处理领域中大量使用)相关的最近一项重大创新可以将医学成像等应用的处理时间减少 高达1000倍。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_61" class="kx_ref">[61]</a></sup> 一般来说，速度的提高取决于问题的特殊性质，这在实际应用中非常常见。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_62" class="kx_ref">[62]</a></sup> 如此大规模的加速使得 大量使用图像处理的计算设备(如数码相机和医疗设备)消耗更少的能量。</p></div></div><div id="par_14995099549171980"><h2 class="title">9 分类<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>有多种方法对算法进行分类，每种方法都有自己的优点。</p><p></p><h3>9.1 <span>通过实现方法</span></h3><p></p><p>算法分类的一种方法是通过实现方式。</p><p>
 </p><table>
  <tbody>
   <tr>
    <td><pre class="kx_code"><code class="C">int gcd(int A, int B) {
 &nbsp; &nbsp;if (B == 0)
 &nbsp; &nbsp; &nbsp; &nbsp;return A;
 &nbsp; &nbsp;else if (A &gt; B)
 &nbsp; &nbsp; &nbsp; &nbsp;return gcd(A-B,B);
 &nbsp; &nbsp;else
 &nbsp; &nbsp; &nbsp; &nbsp;return gcd(A,B-A);
}</code></pre></td>
   </tr>
   <tr>
    <td>Recursive C implementation of Euclid's algorithm from the above flowchart</td>
   </tr>
  </tbody>
 </table><p></p><p>
 </p><dl>
  <dt>
   递归
  </dt>
  <dd>
   递归算法是一种反复调用(引用)自身，直到某个条件(也称为终止条件)匹配的算法，这是函数编程的常用方法。迭代算法使用循环这样的重复结构，有时使用堆栈这样的附加数据结构来解决给定的问题。有些问题自然适用于这种或那种实现。例如，河内的塔使用递归实现是很好理解的。每个递归版本都有一个等价的(但可能或多或少复杂)迭代版本，反之亦然。
  </dd>
  <dt>
   逻辑学的
  </dt>
  <dd>
   算法可以被视为受控逻辑演绎。这个概念可以表达为:算法=逻辑+控制。 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_63" class="kx_ref">[63]</a></sup> 逻辑组件表示可以在计算中使用的公理，而控制组件决定演绎应用于公理的方式。这是逻辑编程范例的基础。在纯逻辑编程语言中，控制组件是固定的，算法是通过只提供逻辑组件来指定的。这种方法的吸引力在于优雅的语义:公理的改变会导致算法中定义明确的改变。
  </dd>
  <dt>
   串行、并行或分布式
  </dt>
  <dd>
   算法的讨论通常假设计算机一次执行一条算法指令。那些计算机有时被称为串行计算机。为这种环境设计的算法称为串行算法，而不是并行算法或分布式算法。并行算法利用计算机体系结构，其中 多个处理器可以同时处理一个问题，而分布式算法利用与计算机网络相连的多台机器。并行或分布式算法将问题分成更对称或不对称的子问题，并将结果收集在一起。这种算法中的资源消耗不仅是每个处理器上的处理器周期，而且是处理器之间的通信开销。一些排序算法可以有效地并行化，但是它们的通信开销很 大。迭代算法通常是可并行化的。有些问题没有并行算法，被称为固有串行问题。
  </dd>
  <dt>
   确定性或非确定性
  </dt>
  <dd>
   确定性算法在算法的每一步都通过精确的决策来解决问题，而非确定性算法通过猜测来解决问题，尽管通过使用试探法可以使典型的猜测更加准确。
  </dd>
  <dt>
   精确或近似
  </dt>
  <dd>
   虽然许多算法都 能得到精确的解，但近似算法寻求更接近真实解的 近似解。 近似解可以通过使用确定性策略 或随机策略来达到。这种算法对许多难题都有实用价值。近似算法的一个例子是背包问题，其中有一组给定的项目。它的目标是打包背包以获得最大的总价值。每件物品都有一定的重量和价值。可以携带的总重量不超过某个固定的数字X 。因此，解决方案必须考虑物品的重量及其价值。 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_64" class="kx_ref">[64]</a></sup> 
  </dd>
  <dt>
   量子算法
  </dt>
  <dd>
   他们在量子计算的现实模型上运行。该术语通常用于那些看起来本质上是量子的算法，或者使用量子计算的一些基本特征，如量子叠加或量子纠缠。
  </dd>
 </dl><p></p><p></p><h3>9.2 <span>通过设计 范例</span></h3><p></p><p>算法分类的另一种方法是通过它们的设计方法或范例。有一定数量的范例，每一个都不同。此外，这些类别中的每一个都包括许多不同类型的算法。一些常见的范例是:</p><p>
 </p><dl>
  <dt>
   暴力或彻底搜索
  </dt>
  <dd>
   暴力搜索或穷举搜索这是一种 比较初级的方法，尝试每一种可能的解决方案，看看哪个是最好的。 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_65" class="kx_ref">[65]</a></sup> 
  </dd>
  <dt>
   分而治之方法
  </dt>
  <dd>
   分治法分治算法反复地将一个问题的实例简化为同一问题的一个或多个较小的实例(通常递归地)，直到这些实例小到足以容易地解决。分治的一个例子是 归并排序。在将数据划分成段之后，可以对每段数据进行排序，并且可以在 攻克阶段通过合并段来获得整个数据的排序。分治法的一个更简单的变体叫做 递减和 攻克算法，它解决一个相同的子问题，并使用这个子问题的解来解决更大的问题。 分治法将问题分成多个子问题，因此 攻克阶段比递减和攻克 算法更复杂。 递减和攻克算法的一个例子是 二分查找算法。
  </dd>
  <dt>
   搜索和枚举
  </dt>
  <dd>
   许多问题(例如下棋)可以被建模为图形上的问题。图探索算法指定了在图中移动的规则，并对这类问题很有用。该类别还包括搜索算法、分支和绑定枚举以及回溯。
  </dd>
  <dt>
   随机算法
  </dt>
  <dd></dd>
  <dd>
   这种算法随机(或伪随机)做出一些选择。它们在寻找问题的近似解时非常有用，因为在这些问题中，寻找精确的解是不切实际的(见下面的启发式方法)。对于其中一些问题，众所周知，最快的近似必须包含一些随机性。[66]对于某些问题，多项式时间复杂度的随机算法是否是最快的算法， 是一个被称为P对NP问题的开放性问题。这种算法有两大类: 蒙特卡罗算法以高概率返回正确答案。例如， RP是在多项式时间内运行的子类。 拉斯维加斯算法 总是返回正确的答案，但是它们的运行时间只有概率界限，例如ZPP。
  </dd>
 </dl><p></p><p>
 </p><dl>
  <dt>
   降低复杂性
  </dt>
  <dd>
   这项技术涉及到通过将一个难题转化为一个更广为人知的问题来解决这个难题，对此我们有( 充满希望的)渐近最优算法 。目标是找到一种简化算法，其复杂性不受最终简化算法的支配。例如，一种用于寻找未排序列表中的中间值的选择算法包括首先对列表进行排序( 代价较高的部分)，然后拉出排序列表中的中间元素( 代价较低的部分)。这种技术也被称为转换和 攻克。
  </dd>
  <dt>
   回溯法
  </dt>
  <dd>
   在这种方法中， 多个解决方案是增量构建的，当确定它们不能生成有效的解决方案时，这些方案就会被放弃。
  </dd>
 </dl><p></p><p></p><h3>9.3 <span>优化问题</span></h3><p></p><p>对于优化问题，有更具体的算法分类；这种问题的算法可以属于上述一个或多个一般类别，也可以属于以下类别之一:</p><p>
 </p><dl>
  <dt>
   线性规划
  </dt>
  <dd>
   当搜索线性等式和不等式约束的线性函数的最优解时，问题的约束可以直接用于产生最优解。有些算法可以解决这类问题，例如流行的单纯形算法。 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_66" class="kx_ref">[66]</a></sup> 线性规划可以解决的问题包括有向图的最大流问题。如果一个问题还要求一个或多个未知数必须是整数，那么它就被归入整数规划。如果能够证明整数值的所有限制都是表面的，即无论如何解满足这些限制，线性规划算法可以解决这样的问题。在一般情况下，根据问题的难度，使用专门的算法或找到近似解的算法。
  </dd>
  <dt>
   动态规划
  </dt>
  <dd>
   当一个问题显示出最优子结构(意味着问题的最优解可以由子问题的最优解构造)和重叠的子问题(意味着相同的子问题用于解决许多不同的问题实例)时，称为动态规划的更快的方法避免了重新计算已经计算的解。例如，Floyd–Warshall算法 ， 通过使用从所有相邻顶点到目标的最短路径，可以找到加权图中顶点到目标的最短路径。动态编程和记忆 是相辅相成的。动态规划和分治法的主要区别在于子问题在分治法中或多或少是独立的，而子问题在动态规划中是重叠的。动态编程和直接递归的区别在于递归调用的缓存或记忆。当子问题是独立的并且没有重复时，记忆化没有帮助；因此，动态编程不是所有复杂问题的解决方案。通过使用记忆化或维护已经解决的子问题表，动态规划将许多问题的指数性质降低到多项式复杂性。
  </dd>
  <dt>
   贪婪方法
  </dt>
  <dd>
   贪心算法类似于动态规划算法，它通过检查子结构来工作，在这种情况下不是检查 问题而是检查 给定的解决方案。这种算法从一些解决方案开始，这些解决方案可能是以某种方式给出或构建的，并通过做一些小的修改来改进它。对于某些问题，他们可以找到最优解，而对于另一些问题，他们停留在局部最优，即算法不能改进了 但不是最优的解。 贪心算法最常用的用途是寻找最小生成树，在这种情况下，用这种方法可以找到最优解。 Huffman Tree, Kruskal, Prim, Sollin是 贪心算法，可以解决这个优化问题。
  </dd>
  <dt>
   启发式方法
  </dt>
  <dd>
   在优化问题中，在寻找最优解是 不现实的情况下，启发式算法可以用来寻找接近最优解的解。随着算法的 进行，它们越来越接近最优解。原则上，如果运行无限长的时间，他们会找到最佳的解决方案。他们的优点是可以在相对较短的时间内找到一个非常接近最优的解决方案。这些算法包括局部搜索、禁忌搜索、模拟退火和遗传算法。其中一些，像模拟退火，是非确定性算法，而其他的，像禁忌搜索，是确定性的。当已知非最优解的误差界限时，该算法被进一步归类为近似算法。
  </dd>
 </dl><p></p><p></p><h3>9.4 <span>按研究领域</span></h3><p></p><p>每个科学领域都有自己的问题，需要高效的算法。一个领域的相关问题经常一起研究。一些示例类是搜索算法、排序算法、 归并算法、数值算法、图形算法、字符串算法、计算几何算法、组合算法、医学算法、机器学习、密码学、数据压缩算法和解析技术。</p><p>领域往往相互重叠，一个 领域的算法进步可能会改善其他 领域的算法进步，有时这些 领域完全不相关。例如，动态规划是为了优化工业中的资源消耗而发明的，但现在被用于解决许多领域的 一大系列问题。</p><p></p><h3>9.5 <span>按复杂性</span></h3><p></p><p>算法可以根据完成所需的时间和输入大小进行分类:</p><p>
 </p><ul>
  <li>恒定时间:如果算法所需的时间相同，不管输入大小如何。例如对数组元素的访问。</li>
  <li>线性时间:如果时间与输入大小成比例。例如遍历列表。</li>
  <li>对数时间:如果时间是输入大小的对数函数。例如二进制搜索算法。</li>
  <li>多项式时间:如果时间是输入大小的幂。例如， 冒泡排序法具有二次时间复杂度。</li>
  <li>指数时间:如果时间是输入大小的指数函数。例如暴力搜索。</li>
 </ul><p></p><p>一些问题可能有不同复杂性的多种算法，而其他问题可能没有算法或没有已知的有效算法。也有从一些问题到其他问题的映射。因此， 结果表明，基于最优算法的复杂度，将问题本身分类，而不是将算法划分为等价类更合适。</p></div></div><div id="par_14995099549171981"><h2 class="title">10 连续算法<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>形容词“连续”在应用于“算法”一词时可以表示:</p><p>
 </p><ul>
  <li>对表示连续量的数据进行运算的算法，即使这些数据是用离散近似表示的——这种算法是在数值分析中研究的；</li>
  <li>微分方程形式的一种算法，在模拟计算机上对数据连续运行。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_67" class="kx_ref">[67]</a></sup></li>
 </ul><p></p></div></div><div id="par_14995099549171982"><h2 class="title">11 法律问题<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>算法本身通常不具备专利性。在美国，仅由抽象概念、数字或信号的简单操作组成的权利要求不构成“过程”(USPTO 2006)，因此算法不可申请专利(如 Gottschalk v. Benson案)。然而算法的实际应用有时是可以申请专利的。例如，在&nbsp; Diamond v. Diehr案中，应用简单的反馈算法来帮助合成橡胶固化被认为是可申请 专利的。软件专利极具争议性，而且有很多备受批评的专利涉及算法，尤其是数据压缩算法，如 Unisys的LZW专利。</p><p>此外，一些加密算法有导出限制(请参见加密导出)。</p></div></div><div id="par_14995099549171983"><h2 class="title">12 历史:“算法”概念的发展<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p></p><h3>12.1 <span>古代近东</span></h3><p></p><p>算法在古希腊被使用。两个例子是 Eratosthenes的筛子，在[ Nicomachus的《算术导论》中有所描述，<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_68" class="kx_ref">[68]</a></sup><sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_69" class="kx_ref">[69]</a></sup> 第9.2章，欧几里德算法，在欧几里德的《元素》(公元前300年)中首次有所描述。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_69" class="kx_ref">[69]</a></sup> 巴比伦 泥板文书描述并使用算法程序来计算重大天文事件的时间和地点。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_69" class="kx_ref">[69]</a></sup> </p><p></p><h3>12.2 <span>离散和可区分的符号</span></h3><p></p><p>计数标记:为了记录他们的羊群，他们的粮食袋和他们的钱，古人使用计数法:积累石头或在棍子上划的标记，或者用粘土制作离散的符号。通过巴比伦人和埃及人 对标记和符号的使用，最终罗马数字和算盘得到了发展( Dilson，第16-41页)。计数标记在图灵机和后图灵机计算中使用的一元数字系统算法中表现突出。</p><p></p><h3>12.3 <span>作为数字“占位符”的符号操作:代数</span></h3><p></p><p>古希腊几何学家(欧几里得算法)、印度数学家 Brahmagupta和波斯数学家 Al-Khwarizmi (术语“ 十进位计算法”和“算法”是从他 的名字中派生出来的)以及西欧数学家的工作使在莱布尼茨的微积分推理器概念(约1680年)中达到了顶峰&nbsp;:</p><p>早于他所处时代整整一个半世纪 ，莱布尼茨提出了一 种逻辑代数，这 种代数将像普通代数规定操纵数字的规则一样规定操纵逻辑概念的规则.<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_70" class="kx_ref">[70]</a></sup></p><p></p><h3>12.4 <span>具有离散状态的机械装置</span></h3><p></p><p>时钟: Bolter将重量驱动时钟的发明&nbsp; 誉为“中世纪欧洲的关键发明”，特别是边缘擒纵机构<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_71" class="kx_ref">[71]</a></sup> 它为我们提供了机械钟的滴答声。“精确的自动机器”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_72" class="kx_ref">[72]</a></sup> 从13世纪开始，立即 催生了“机械自动机”，最终 催生了“计算机器”——19世纪中期 Charles Babbage和 Ada Lovelace伯爵夫人的差分机和分析机 。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_73" class="kx_ref">[73]</a></sup> Lovelace被认为是第一个设计用于计算机处理的算法的人—— Babbage的分析机 ， 被认为是第一个真正的图灵完整的计算机而不仅仅是计算器——因此Lovelace 有时被称为“历史上的第一个程序员”，尽管 Babbage的第二个设备的完整实现要等到她死后几十年才能实现。</p><p>逻辑机器1870年—— Stanley Jevons的“逻辑算盘”和“逻辑机器”:技术问题是当布尔方程以类似于现在被称为卡诺图的形式出现时，要简化布尔方程。 Jevons (1880)首先描述了一个简单的“算盘”，由“木条”组成，木条上有 指针，指针被 设计成可以机械地挑选出逻辑组合的任何部分或类别...然而，最近，我把系统简化为一种完全机械的形式，并因此把整个间接推理过程具体化为所谓的逻辑机器。他的机器配备了“某些可移动的木棒”和“脚下有21个键，像钢琴等的键一样……”。有了这台机器，他可以分析“三段论或任何其他简单的逻辑论证”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_74" class="kx_ref">[74]</a></sup> </p><p>1870年，他在皇家学会的研究员面前展示了这台机器。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_75" class="kx_ref">[75]</a></sup> 然而，另一位逻辑学家 John Venn在他1881年的《符号逻辑》中对这一努力持偏见:“我对有时被称为逻辑机器的兴趣或重要性没有很高的 评价...在我看来，目前已知或可能被发现的任何发明都不值得被称为逻辑机器”； 到算法特性中查看更多。但他也不甘示弱，提出了“一个有点类似于 Jevon教授算盘的计划... 又一次，对应于 Jevons教授的逻辑机器，以下发明可以描述。我更喜欢称它为逻辑图机器...但我认为它可以完全做到任何逻辑机器合理预期的一切”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_76" class="kx_ref">[76]</a></sup> </p><p>提花织机、 Hollerith穿孔卡、电报和电话——机电继电器: Bell和 Newell (1971年)指出，提花织机(1801年)、 Hollerith卡的前身 (穿孔卡，1887年)和“电话交换技术”是导致第一批计算机发展的根源。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_77" class="kx_ref">[77]</a></sup> 到19世纪中叶，电话的前身电报已经在全世界使用，它对字母的离散和可区分的编码是“点和破折号”，这是一种常见的声音。到了19世纪末，&nbsp; 自动收报机纸条(约19世纪70年代)开始使用，就像1890年美国人口普查中Hollerith 卡的使用一样。然后是电传打字机( 大约在1910年)，在 打孔纸上使用 Baudot码。</p><p>机电继电器的电话交换网络(发明于1835年)是以数字加法设备的发明者&nbsp; George Stibitz (1937年) 的工作为基础的。当他在贝尔实验室工作时，他观察到机械计算器和齿轮的“累赘”使用。“1937年的一个晚上，他回到家，打算验证他的想法...修补工作结束后， Stibitz建造了一个二进制加法装置”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_78" class="kx_ref">[78]</a></sup> </p><p>Davis (2000)观察到机电继电器的特殊重要性(其两个“二进制状态”打开和关闭):</p><p>
 </p><dl>
  <dd>
   直到从20世纪30年代开始，使用继电器的机电计算器得到发展，机器才被制造出 Babbage所设想的范围。“ &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_79" class="kx_ref">[79]</a></sup> 
  </dd>
 </dl><p></p><p></p><h3>12.5 <span>从19世纪到20世纪中期的数学</span></h3><p></p><p>符号和规则:接连不断地， &nbsp; George Boole (1847，1854)、 Gottlob Frege (1879)和 Giuseppe Peano (1888-1889)的数学运算 将算术简化为由规则操纵的符号序列。 Peano的《算术原理》，由一种新方法(1888年)提出，是“用符号语言对数学进行公理化的第一次尝试”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_80" class="kx_ref">[80]</a></sup> </p><p>但是 Heijenoort给了Frege&nbsp; (1879)这样的 赞誉: Frege&nbsp; 的作品“也许是逻辑史上最重要的一部作品。...其中我们看到了一种“公式语言”，这是一种语言特征，一种用特殊符号写成的语言，“用于纯粹的思考”，也就是说，没有修辞修饰...由根据明确规则操纵的特定符号构成”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_81" class="kx_ref">[81]</a></sup>Frege 的工作被 Alfred North Whitehead和 Bertrand Russell在其《数学原理》(1910-1913)中进一步简化和 扩充。</p><p>悖论:与此同时，一些令人不安的悖论出现在 著作中，特别是 Burali-Forti悖论(1897)、 Russell悖论(1902-03)和 Richard悖论。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_82" class="kx_ref">[82]</a></sup> 由此产生的考虑导致 Kurt Gödel的论文(1931年)——他特别引用了说谎者的悖论——将递归规则完全简化为数字。</p><p>有效计算能力:为了解决 Hilbert在1928年精确定义的判定问题 ，数学家们首先开始定义“有效方法”或“有效计算”或“有效计算能力”的含义(即，一个会成功的计算)。接下来，Alonzo Church、Stephen Kleene和J.B. Rosser 的λ演算<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_83" class="kx_ref">[83]</a></sup> 根据 Gödel的工作，按照 Jacques Herbrand的建议(参见 Gödel1934年的普林斯顿讲座)和 Kleene后来的简化，对“一般递归”进行了精细的定义。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_84" class="kx_ref">[84]</a></sup> Church的证明是<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_85" class="kx_ref">[85]</a></sup> 判定问题 是不可解决的， Emil Post对有效计算能力的定义是，一个工人盲目地遵循一系列指令，在一系列房间里向左或向右移动，在那里或者标记或擦除一张纸，或者观察这张纸，然后对下一条指令做出是或否的决定。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_86" class="kx_ref">[86]</a></sup> Alan Turing用他的“a-[自动-]机器<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_87" class="kx_ref">[87]</a></sup>证明判定 问题是无法解决的——实际上几乎与 Post的“公式”相同，J. Barkley Rosser用“机器”来定义“有效方法”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_88" class="kx_ref">[88]</a></sup> S.C. Kleene提出的“ Church论文”的前身，他称之为“论文一”，<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_89" class="kx_ref">[89]</a></sup> 几年后 Kleene重命名他的论文为“Church 的论文”<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_90" class="kx_ref">[90]</a></sup> 和提出“ Turing的论文”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_91" class="kx_ref">[91]</a></sup> </p><p></p><h3>12.6 <span>Emil Post (1936)和 Alan Turing (1936-37，1939)</span></h3><p></p><p>Emil Post (1936)对“计算机”(人类)的行为描述如下:</p><p>
 </p><dl>
  <dd>
   "...其中涉及两个概念:一个是符号空间，在这个空间中，从问题到答案的工作将被执行；另一个是一组固定的不可改变的方向。 他的符号空间是 “双向无限序列的空间或盒子...问题解决者或工作人员要在这个符号空间中移动和工作，能够在一个盒子里工作，一次只能在一个盒子里工作....一个盒子只允许两种可能的情况，即空的或未标记的，并且其中有一个标记，比如一个垂直的笔画。 “有一个盒子被挑选出来，叫做起点。...一个 特定的问题是用符号形式在被画上记号的有限数量的盒子[即输入]给出的 。同样，答案[(即输出)将以符号形式由这种被标记的盒子配置给出...
  </dd>
 </dl><p></p><p>
 </p><dl>
  <dd>
   “适用于一般问题的一组 指示在适用于每个特定问题时建立了确定性过程。这一过程只有在达到[类型(C)的方向时才终止，[即停止]”。 &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_92" class="kx_ref">[92]</a></sup> 
  </dd>
 </dl><p></p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img02.sogoucdn.com/app/a/200698/sogou_science_132" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">Alan Turing's statue at Bletchley Park</div>   
        </div> <p></p><p>Alan Turing的作品<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_93" class="kx_ref">[93]</a></sup> 早于 Stibitz的作品(1937)；还不知道 Stibitz是否知道 Turing的工作。 Turing的传记作者认为图灵 Turing使用打字机一样的模型源于 小时候的兴趣:“艾伦小时候就梦想发明打字机；图灵夫人有一台打字机，他 可能是从问自己把打字机叫做‘机械’是什么意思开始的。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_94" class="kx_ref">[94]</a></sup> 鉴于莫尔斯电码和电报、自动收报机和电传打字机的普及，我们[是谁？]可能猜想所有这些都是影响。</p><p>Turing——他的计算模型现在被称为图灵机——和 Post一样，开始于对人类计算机的分析，他把分析简化为一组简单的基本运动和“ 思维状态”。但是他更进一步，创造了一台机器作为计算数字的模型。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_95" class="kx_ref">[95]</a></sup> </p><p>
 </p><dl>
  <dd>
   “计算通常是通过在纸上写下某些符号来完成的。我们可以假设这张纸像一本儿童算术书一样被分成正方形...我假设计算是在一维纸上进行的，也就是说，在分成正方形的磁带上。我还假设可以打印的符号数量是有限的... 计算机在任何时候的行为都是由他观察到的符号和他当时的“思维 状态”决定的。我们可以假设计算机在某一时刻可以观察到的符号或正方形的数量有一个界限。如果他想观察更多，他必须使用连续的观察。我们还将假设需要考虑的 思维状态的数量是有限的... “让我们想象一下，由计算机执行的操作被分解成“简单的操作”，这些操作非常简单，很难想象它们会被进一步分解。” &nbsp;<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_96" class="kx_ref">[96]</a></sup> 
  </dd>
 </dl><p></p><p>Turing的归约产生了以下结果:</p><p>“因此，简单的操作必须包括:</p><p>"(a)观察到的一个方块上的符号发生变化</p><p>"(b)观察到的一个正方形向先前观察到的一个正方形的L个正方形内的另一个正方形的变化。</p><p>“可能其中一些变化必然会引起 思维状态的变化。因此，最一般的单一操作必须被视为以下操作之一:</p><p>"(A) 符号的可能变化以及 思维状态的可能变化。</p><p>(B) 观察到的正方形的可能变化，以及思维状态 的可能变化</p><p>"我们现在可以建造一台机器来完成这台计算机的工作."<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_96" class="kx_ref">[96]</a></sup> </p><p>几年后，图灵用这种有力的表达扩展了他的分析(论文，定义):</p><p>如果一个函数的值可以通过一些纯粹的机械过程找到，那么这个函数就被称为是“可有效计算的”。尽管很容易直观地理解这一概念，但还是希望有一些更明确的、数学上可表达的定义...[:他讨论了定义的历史，就像上面提到的 Gödel, Herbrand, Kleene, Church, Turing, and Post一样]...我们可以从字面上理解这句话，理解为一个可以被机器执行纯粹的机械过程 。有可能以某种形式给出这些机器结构的数学描述。这些思想的发展 引出了作者对可计算函数的定义，以及对可有效计算的可计算性 的识别...。</p><p>“我们将使用表达式“可计算函数”来表示可由机器计算的函数，并且我们让“可有效计算的”指的是直观的概念，而不与这些定义中的任何一个进行特殊的标识”。<sup><a href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/d10392.htm#quote_97" class="kx_ref">[97]</a></sup> </p><p></p><h3>12.7 <span>J.B. Rosser (1939)和S.C. Kleene&nbsp; (1943)</span></h3><p></p><p>J. Barkley Rosser以下列方式定义了“有效的[数学]方法”(增加了斜体):</p><p>“‘有效方法’在这里是以一种意义相当特殊的方法 来使用的，该方法的每一个步骤都被精确地确定，并且肯定会在有限的步骤中产生答案。有了这种特殊的含义，迄今为止已经给出了三种不同的精确定义。[，他的脚注5；请参见下面的讨论]。其中最简单的陈述( 归功于Post和Turing)说，如果一个人能造出一台机器来解决这组问题，除了插入问题和(稍后)阅读答案之外，不需要任何人的干预，就能解决这组问题，那么这就是解决某些问题的有效方法。这三个定义都是等价的，所以使用哪一个并不重要。此外，这三者都是等价的这一事实是任何一种方法 正确性的有力论据。”( Rosser 1939:225–226)</p><p>Rosser的脚注5提到了(1)Church和Kleene 的工作以及他们对λ可定义性的定义，特别是 Church在他的《初等数论的一个无法解决的问题》(1936)中对λ可定义性的使用；(2) Herbrand和 Gödel及其递归的使用，特别是 Gödel在他的著名论文《数学原理及相关系统的形式不可判定命题一》(1931)中的使用；和(3)Post(1936)和Turing (1936-37)在他们的计算机制模型中。</p><p>Stephen C. Kleene把他现在著名的“论文一”定义为 Church—— Turing论文。但他是在以下背景下这样做的(原文为黑体):</p><p>“12。算法理论...在建立一个完整的算法理论的过程中，我们所做的是描述一个过程，这个过程对于独立变量的每一组值都是可执行的，这个过程必须终止，并且以这样的方式，从结果中我们可以读到一个明确的答案，“是”或“否”，对于这个问题，“这个断言的值 是真的吗？" "( Kleene1943:273)</p><p>
 </p><dl>
  <dd></dd>
 </dl><p></p><p></p><h3>12.8 <span>1950年后的历史</span></h3><p></p><p>为了进一步完善“算法”的定义 ，人们付出了大量的努力。由于围绕数学基础(尤其是Church -Turing 论文)和 精神哲学(尤其是关于人工智能的争论)的问题，活动仍在继续。有关更多信息，请参见算法特性。</p></div></div><div id="par_14995099565949198"><h2 class="title">13 笔记<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>
 </p><ol>
  <li id="cite-ref-2">"Any classical mathematical algorithm, for example, can be described in a finite number of English words" (Rogers 1987:2).</li>
  <li id="cite-ref-4">Well defined with respect to the agent that executes the algorithm: "There is a computing agent, usually human, which can react to the instructions and carry out the computations" (Rogers 1987:2).</li>
  <li id="cite-ref-6">"an algorithm is a procedure for computing a <i>function</i> (with respect to some chosen notation for integers) ... this limitation (to numerical functions) results in no loss of generality", (Rogers 1987:1).</li>
  <li id="cite-ref-8">"An algorithm has zero or more inputs, i.e., quantities which are given to it initially before the algorithm begins" (Knuth 1973:5).</li>
  <li id="cite-ref-10">"A procedure which has all the characteristics of an algorithm except that it possibly lacks finiteness may be called a 'computational method'" (Knuth 1973:5).</li>
  <li id="cite-ref-12">"An algorithm has one or more outputs, i.e. quantities which have a specified relation to the inputs" (Knuth 1973:5).</li>
  <li id="cite-ref-14">Whether or not a process with random interior processes (not including the input) is an algorithm is debatable. Rogers opines that: "a computation is carried out in a discrete stepwise fashion, without the use of continuous methods or analogue devices ... carried forward deterministically, without resort to random methods or devices, e.g., dice" (Rogers 1987:2).</li>
  <li id="cite-ref-16">Cooke, Roger L. (2005). <i>The History of Mathematics: A Brief Course</i>. John Wiley &amp; Sons. ISBN&nbsp;978-1-118-46029-0.</li>
  <li id="cite-ref-18">Kleene 1943 in Davis 1965:274</li>
  <li id="cite-ref-20">Rosser 1939 in Davis 1965:225</li>
  <li id="cite-ref-22">"Al-Khwarizmi biography". <i>www-history.mcs.st-andrews.ac.uk</i>.</li>
  <li id="cite-ref-24">"Etymology of algorithm". <i>Chambers Dictionary</i>. Retrieved December 13, 2016.</li>
  <li id="cite-ref-26">Hogendijk, Jan P. (1998). "al-Khwarzimi". <i>Pythagoras</i>. <b>38</b> (2): 4–5. Archived from the original on April 12, 2009.</li>
  <li id="cite-ref-28">Oaks, Jeffrey A. "Was al-Khwarizmi an applied algebraist?". University of Indianapolis. Archived from the original on November 15, 2010. Retrieved May 30, 2008.</li>
  <li id="cite-ref-30">Brezina, Corona (2006). <i>Al-Khwarizmi: The Inventor Of Algebra</i>. The Rosen Publishing Group. ISBN&nbsp;978-1-4042-0513-0.</li>
  <li id="cite-ref-32">Foremost mathematical texts in history, according to Carl B. Boyer.</li>
  <li id="cite-ref-34"><i>Oxford English Dictionary</i>, Third Edition, 2012 <i>s.v.</i> </li>
  <li id="cite-ref-36">Stone 1973:4</li>
  <li id="cite-ref-38">Simanowski, Roberto (2018). <i>The Death Algorithm and Other Digital Dilemmas</i>. Untimely Meditations. <b>14</b>. Translated by Chase, Jefferson. Cambridge, Massachusetts: MIT Press. p.&nbsp;147. ISBN&nbsp;9780262536370. Retrieved 27 May 2019. [...] the next level of abstraction of central bureaucracy: globally operating algorithms.</li>
  <li id="cite-ref-40">Stone simply requires that "it must terminate in a finite number of steps" (Stone 1973:7–8).</li>
  <li id="cite-ref-42">Boolos and Jeffrey 1974,1999:19</li>
  <li id="cite-ref-44">cf Stone 1972:5</li>
  <li id="cite-ref-46">Knuth 1973:7 states: "In practice we not only want algorithms, we want <i>good</i> algorithms ... one criterion of goodness is the length of time taken to perform the algorithm ... other criteria are the adaptability of the algorithm to computers, its simplicity, and elegance, etc."</li>
  <li id="cite-ref-48">cf Stone 1973:6</li>
  <li id="cite-ref-50">Stone 1973:7–8 states that there must be, "...a procedure that a robot [i.e., computer] can follow in order to determine precisely how to obey the instruction". Stone adds finiteness of the process, and definiteness (having no ambiguity in the instructions) to this definition.</li>
  <li id="cite-ref-52">Knuth, loc. cit</li>
  <li id="cite-ref-54"></li>
  <li id="cite-ref-56">Gurevich 2000:1, 3</li>
  <li id="cite-ref-58">Sipser 2006:157</li>
  <li id="cite-ref-60">Goodrich, Michael T.; Tamassia, Roberto (2002), <i>Algorithm Design: Foundations, Analysis, and Internet Examples</i>, John Wiley &amp; Sons, Inc., ISBN&nbsp;978-0-471-38365-9</li>
  <li id="cite-ref-62">Knuth 1973:7</li>
  <li id="cite-ref-64">Chaitin 2005:32</li>
  <li id="cite-ref-66">Rogers 1987:1–2</li>
  <li id="cite-ref-68">In his essay "Calculations by Man and Machine: Conceptual Analysis" Seig 2002:390 credits this distinction to Robin Gandy, cf Wilfred Seig, et al., 2002 <i>Reflections on the foundations of mathematics: Essays in honor of Solomon Feferman</i>, Association for Symbolic Logic, A.K. Peters Ltd, Natick, MA.</li>
  <li id="cite-ref-70">cf Gandy 1980:126, Robin Gandy <i>Church's Thesis and Principles for Mechanisms</i> appearing on pp. 123–148 in J. Barwise et al. 1980 <i>The Kleene Symposium</i>, North-Holland Publishing Company.</li>
  <li id="cite-ref-72">A "robot": "A computer is a robot that performs any task that can be described as a sequence of instructions." cf Stone 1972:3</li>
  <li id="cite-ref-74">Lambek's "abacus" is a "countably infinite number of locations (holes, wires etc.) together with an unlimited supply of counters (pebbles, beads, etc). The locations are distinguishable, the counters are not". The holes have unlimited capacity, and standing by is an agent who understands and is able to carry out the list of instructions" (Lambek 1961:295). Lambek references Melzak who defines his Q-machine as "an indefinitely large number of locations ... an indefinitely large supply of counters distributed among these locations, a program, and an operator whose sole purpose is to carry out the program" (Melzak 1961:283). B-B-J (loc. cit.) add the stipulation that the holes are "capable of holding any number of stones" (p. 46). Both Melzak and Lambek appear in <i>The Canadian Mathematical Bulletin</i>, vol. 4, no. 3, September 1961.</li>
  <li id="cite-ref-76">If no confusion results, the word "counters" can be dropped, and a location can be said to contain a single "number".</li>
  <li id="cite-ref-78">"We say that an instruction is <i>effective</i> if there is a procedure that the robot can follow in order to determine precisely how to obey the instruction." (Stone 1972:6)</li>
  <li id="cite-ref-80">cf Minsky 1967: Chapter 11 "Computer models" and Chapter 14 "Very Simple Bases for Computability" pp. 255–281 in particular</li>
  <li id="cite-ref-82">cf Knuth 1973:3.</li>
  <li id="cite-ref-84">But always preceded by IF–THEN to avoid improper subtraction.</li>
  <li id="cite-ref-86">Knuth 1973:4</li>
  <li id="cite-ref-88">Stone 1972:5. Methods for extracting roots are not trivial: see Methods of computing square roots.</li>
  <li id="cite-ref-90">Leeuwen, Jan (1990). <i>Handbook of Theoretical Computer Science: Algorithms and complexity. Volume A</i>. Elsevier. p.&nbsp;85. ISBN&nbsp;978-0-444-88071-0.</li>
  <li id="cite-ref-92">John G. Kemeny and Thomas E. Kurtz 1985 <i>Back to Basic: The History, Corruption, and Future of the Language</i>, Addison-Wesley Publishing Company, Inc. Reading, MA, ISBN 0-201-13433-0.</li>
  <li id="cite-ref-94">Tausworthe 1977:101</li>
  <li id="cite-ref-96">Tausworthe 1977:142</li>
  <li id="cite-ref-98">Knuth 1973 section 1.2.1, expanded by Tausworthe 1977 at pages 100ff and Chapter 9.1</li>
  <li id="cite-ref-100">cf Tausworthe 1977</li>
  <li id="cite-ref-102">Heath 1908:300; Hawking's Dover 2005 edition derives from Heath.</li>
  <li id="cite-ref-104">" 'Let CD, measuring BF, leave FA less than itself.' This is a neat abbreviation for saying, measure along BA successive lengths equal to CD until a point F is reached such that the length FA remaining is less than CD; in other words, let BF be the largest exact multiple of CD contained in BA" (Heath 1908:297)</li>
  <li id="cite-ref-106">For modern treatments using division in the algorithm, see Hardy and Wright 1979:180, Knuth 1973:2 (Volume 1), plus more discussion of Euclid's algorithm in Knuth 1969:293–297 (Volume 2).</li>
  <li id="cite-ref-108">Euclid covers this question in his Proposition 1.</li>
  <li id="cite-ref-110">"Euclid's Elements, Book VII, Proposition 2". Aleph0.clarku.edu. Retrieved May 20, 2012.</li>
  <li id="cite-ref-112">While this notion is in widespread use, it cannot be defined precisely.</li>
  <li id="cite-ref-114">Knuth 1973:13–18. He credits "the formulation of algorithm-proving in terms of assertions and induction" to R W. Floyd, Peter Naur, C.A.R. Hoare, H.H. Goldstine and J. von Neumann. Tausworth 1977 borrows Knuth's Euclid example and extends Knuth's method in section 9.1 <i>Formal Proofs</i> (pp. 288–298).</li>
  <li id="cite-ref-116">Tausworthe 1997:294</li>
  <li id="cite-ref-118">cf Knuth 1973:7 (Vol. I), and his more-detailed analyses on pp. 1969:294–313 (Vol II).</li>
  <li id="cite-ref-120">Breakdown occurs when an algorithm tries to compact itself. Success would solve the Halting problem.</li>
  <li id="cite-ref-122">Kriegel, Hans-Peter; Schubert, Erich; Zimek, Arthur (2016). "The (black) art of run-time evaluation: Are we comparing algorithms or implementations?". <i>Knowledge and Information Systems</i>. <b>52</b> (2): 341–378. doi:10.1007/s10115-016-1004-2. ISSN&nbsp;0219-1377.</li>
  <li id="cite-ref-124">Gillian Conahan (January 2013). "Better Math Makes Faster Data Networks". discovermagazine.com.</li>
  <li id="cite-ref-126">Haitham Hassanieh, Piotr Indyk, Dina Katabi, and Eric Price, "ACM-SIAM Symposium On Discrete Algorithms (SODA) Archived 7月 4, 2013 at the Wayback Machine, Kyoto, January 2012. See also the sFFT Web Page.</li>
  <li id="cite-ref-128">Kowalski 1979</li>
  <li id="cite-ref-130"><i>Knapsack Problems | Hans Kellerer | Springer</i> (in 英语). Springer. 2004. ISBN&nbsp;978-3-540-40286-2.</li>
  <li id="cite-ref-132">Carroll, Sue; Daughtrey, Taz (July 4, 2007). <i>Fundamental Concepts for the Software Quality Engineer</i>. American Society for Quality. pp.&nbsp;282 et seq. ISBN&nbsp;978-0-87389-720-4.</li>
  <li id="cite-ref-134">George B. Dantzig and Mukund N. Thapa. 2003. <i>Linear Programming 2: Theory and Extensions</i>. Springer-Verlag.</li>
  <li id="cite-ref-136">Tsypkin (1971). <i>Adaptation and learning in automatic systems</i>. Academic Press. p.&nbsp;54. ISBN&nbsp;978-0-08-095582-7.</li>
  <li id="cite-ref-138">Ast, Courtney. "Eratosthenes". Wichita State University: Department of Mathematics and Statistics.</li>
  <li id="cite-ref-140">Aaboe, Asger (2001), <i>Episodes from the Early History of Astronomy</i>, New York: Springer, pp.&nbsp;40–62, ISBN&nbsp;978-0-387-95136-2</li>
  <li id="cite-ref-142">Davis 2000:18</li>
  <li id="cite-ref-144">Bolter 1984:24</li>
  <li id="cite-ref-146">Bolter 1984:26</li>
  <li id="cite-ref-148">Bolter 1984:33–34, 204–206.</li>
  <li id="cite-ref-150">All quotes from W. Stanley Jevons 1880 <i>Elementary Lessons in Logic: Deductive and Inductive</i>, Macmillan and Co., London and New York. Republished as a googlebook; cf Jevons 1880:199–201. Louis Couturat 1914 <i>the Algebra of Logic</i>, The Open Court Publishing Company, Chicago and London. Republished as a googlebook; cf Couturat 1914:75–76 gives a few more details; he compares this to a typewriter as well as a piano. Jevons states that the account is to be found at January 20, 1870 <i>The Proceedings of the Royal Society</i>.</li>
  <li id="cite-ref-152">Jevons 1880:199–200</li>
  <li id="cite-ref-154">All quotes from John Venn 1881 <i>Symbolic Logic</i>, Macmillan and Co., London. Republished as a googlebook. cf Venn 1881:120–125. The interested reader can find a deeper explanation in those pages.</li>
  <li id="cite-ref-156">Bell and Newell diagram 1971:39, cf. Davis 2000</li>
  <li id="cite-ref-158">* Melina Hill, Valley News Correspondent, <i>A Tinkerer Gets a Place in History</i>, Valley News West Lebanon NH, Thursday, March 31, 1983, p. 13.</li>
  <li id="cite-ref-160">Davis 2000:14</li>
  <li id="cite-ref-162">van Heijenoort 1967:81ff</li>
  <li id="cite-ref-164">van Heijenoort's commentary on Frege's <i>Begriffsschrift, a formula language, modeled upon that of arithmetic, for pure thought</i> in van Heijenoort 1967:1</li>
  <li id="cite-ref-166">Dixon 1906, cf. Kleene 1952:36–40</li>
  <li id="cite-ref-168">cf. footnote in Alonzo Church 1936a in Davis 1965:90 and 1936b in Davis 1965:110</li>
  <li id="cite-ref-170">Kleene 1935–6 in Davis 1965:237ff, Kleene 1943 in Davis 1965:255ff</li>
  <li id="cite-ref-172">Church 1936 in Davis 1965:88ff</li>
  <li id="cite-ref-174">cf. "Finite Combinatory Processes – formulation 1", Post 1936 in Davis 1965:289–290</li>
  <li id="cite-ref-176">Turing 1936–37 in Davis 1965:116ff</li>
  <li id="cite-ref-178">Rosser 1939 in Davis 1965:226</li>
  <li id="cite-ref-180">Kleene 1943 in Davis 1965:273–274</li>
  <li id="cite-ref-182">Kleene 1952:300, 317</li>
  <li id="cite-ref-184">Kleene 1952:376</li>
  <li id="cite-ref-186">Turing 1936–37 in Davis 1965:289–290</li>
  <li id="cite-ref-188">Turing 1936 in Davis 1965, Turing 1939 in Davis 1965:160</li>
  <li id="cite-ref-190">Hodges, p.&nbsp;96</li>
  <li id="cite-ref-192">Turing 1936–37:116</li>
  <li id="cite-ref-194">Turing 1936–37 in Davis 1965:136</li>
  <li id="cite-ref-196">Turing 1939 in Davis 1965:160</li>
 </ol><p></p></div></div><div id="par_14995099565949199"><h2 class="title">14 文献学<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>
 </p><ul>
  <li>Axt, P (1959). "On a Subrecursive Hierarchy and Primitive Recursive Degrees". <i>Transactions of the American Mathematical Society</i>. <b>92</b> (1): 85–105. doi:10.2307/1993169. JSTOR&nbsp;1993169.</li>
  <li>艾伦·戈登·贝尔和纽维尔(1971年)， <i>计算机结构:阅读和例子</i>纽约麦格劳希尔图书公司。 ISBN 0-07-004357-4。</li>
  <li>Blass, Andreas; Gurevich, Yuri (2003). "Algorithms: A Quest for Absolute Definitions" (PDF). <i>Bulletin of European Association for Theoretical Computer Science</i>. <b>81</b>. 包括56篇参考文献的优秀书目。</li>
  <li>Bolter, David J. (1984). <i>Turing's Man: Western Culture in the Computer Age</i> (1984 ed.). Chapel Hill, NC: The University of North Carolina Press. ISBN&nbsp;978-0-8078-1564-9., ISBN 0-8078-4108-0</li>
  <li>Boolos, George; Jeffrey, Richard (1999) [1974]. <i>Computability and Logic</i> (4th ed.). Cambridge University Press, London. ISBN&nbsp;978-0-521-20402-6.:参见第3章 <i>图灵机</i> 其中他们讨论“某些不有效(机械地)可枚举的可枚举集合”。</li>
  <li>Burgin, Mark (2004). <i>Super-Recursive Algorithms</i>. Springer. ISBN&nbsp;978-0-387-95569-8.</li>
  <li>孔帕尼奥洛，M.L .，Moore，c .，Costa，J.F. (2000)一个子正则函数的模拟特征化。在 <i>继续。第四届实数和计算机会议</i>奥登塞大学，页&nbsp;91–109</li>
  <li>Church, Alonzo (1936a). "An Unsolvable Problem of Elementary Number Theory". <i>The American Journal of Mathematics</i>. <b>58</b> (2): 345–363. doi:10.2307/2371045. JSTOR&nbsp;2371045. 重印于 <i>不可判定的</i>，p。&nbsp;89ff。“Church's论文”的第一个表述。具体参见第100页(<i>不可判定的</i>)其中他用“算法”定义了“有效可计算性”的概念，并使用了“终止”等词。</li>
  <li>Church, Alonzo (1936b). "A Note on the Entscheidungsproblem". <i>The Journal of Symbolic Logic</i>. <b>1</b> (1): 40–41. doi:10.2307/2269326. JSTOR&nbsp;2269326. Church, Alonzo (1936). "Correction to a Note on the Entscheidungsproblem". <i>The Journal of Symbolic Logic</i>. <b>1</b> (3): 101–102. doi:10.2307/2269030. JSTOR&nbsp;2269030. 重印于 <i>不可判定的</i>，p。&nbsp;110ff。丘奇用大约3页的文字和3页的脚注表明可判定性是不可解决的。</li>
  <li>Daffa', Ali Abdullah al- (1977). <i>The Muslim contribution to mathematics</i>. London: Croom Helm. ISBN&nbsp;978-0-85664-464-1.</li>
  <li>Davis, Martin (1965). <i>The Undecidable: Basic Papers On Undecidable Propositions, Unsolvable Problems and Computable Functions</i>. New York: Raven Press. ISBN&nbsp;978-0-486-43228-1. 戴维斯在每篇文章之前给出评论。包括哥德尔、阿隆佐·邱奇、图灵、罗塞尔、克莱尼和埃米尔邮报的论文；文章中引用的那些是按作者的名字列出的。</li>
  <li>Davis, Martin (2000). <i>Engines of Logic: Mathematicians and the Origin of the Computer</i>. New York: W.W. Nortion. ISBN&nbsp;978-0-393-32229-3. 戴维斯提供了莱布尼茨、布尔、弗雷格、康托尔、希尔伯特、哥德尔和图灵的简明传记，冯·诺伊曼是盗窃表演的恶棍。约瑟夫·玛丽·雅卡尔、巴贝奇、阿达·洛芙莱斯、克劳德·香农、霍华德·艾肯等的简介。</li>
  <li>&nbsp;本条目引用的公有领域材料。材料来自NIST的文档：Black, Paul E. "algorithm". <i>演算法与资料结构辞典（英语：Dictionary of Algorithms and Data Structures）</i>.</li>
  <li>Dean, Tim (2012). "Evolution and moral diversity". <i>Baltic International Yearbook of Cognition, Logic and Communication</i>. <b>7</b>.</li>
  <li>Dennett, Daniel (1995). <i>Darwin's Dangerous Idea</i>. <i>Complexity</i>. <b>2</b>. New York: Touchstone/Simon &amp; Schuster. p.&nbsp;32. Bibcode:1996Cmplx...2a..32M. doi:10.1002/(SICI)1099-0526(199609/10)2:1&lt;32::AID-CPLX8&gt;3.0.CO;2-H. ISBN&nbsp;978-0-684-80290-9.</li>
  <li>Dilson, Jesse (2007). <i>The Abacus</i> ((1968, 1994) ed.). St. Martin's Press, NY. ISBN&nbsp;978-0-312-10409-2., ISBN 0-312-10409-X</li>
  <li>尤里·古列维奇， <i>Sequential Abstract State Machines Capture Sequential Algorithms</i>《计算逻辑交易》，第1卷，第1期(2000年7月)，页&nbsp;77–111。包括33个来源的参考书目。</li>
  <li>van Heijenoort, Jean (2001). <i>From Frege to Gödel, A Source Book in Mathematical Logic, 1879–1931</i> ((1967) ed.). Harvard University Press, Cambridge. ISBN&nbsp;978-0-674-32449-7.，1976年第三版，[？]， ISBN 0-674-32449-8 (pbk。)</li>
  <li>Hodges, Andrew (1983). <i>Alan Turing: The Enigma</i>. <i>Physics Today</i>. <b>37</b>. New York: Simon and Schuster. p.&nbsp;107. Bibcode:1984PhT....37k.107H. doi:10.1063/1.2915935. ISBN&nbsp;978-0-671-49207-6., ISBN 0-671-49207-1。参见“真理的精神”一章，这是一部导致和讨论他的证明的历史。</li>
  <li>Kleene, Stephen C. (1936). "General Recursive Functions of Natural Numbers". <i>Mathematische Annalen</i>. <b>112</b> (5): 727–742. doi:10.1007/BF01565439. 1935年9月提交给美国数学学会。重印于 <i>不可判定的</i>，p。&nbsp;237ff。克莱尼对“一般递归”(现在称为mu递归)的定义被丘奇在他1935年的论文中使用 <i>初等数论中一个不可解决的问题</i> 这证明了“决策问题”是“不可判定的”(即否定的结果)。</li>
  <li>Kleene, Stephen C. (1943). "Recursive Predicates and Quantifiers". <i>American Mathematical Society Transactions</i>. <b>54</b> (1): 41–73. doi:10.2307/1990131. JSTOR&nbsp;1990131. 重印于 <i>不可判定的</i>，p。&nbsp;255ff。克莱尼完善了他对“一般递归”的定义，并在他的第12章继续进行。“算法理论”假设“论文一”(p&nbsp;274)；他后来会重复这篇论文(在克莱尼1952:300)并命名为“Church's论文”(克莱尼1952:317)(即教会论文)。</li>
  <li>Kleene, Stephen C. (1991) [1952]. <i>Introduction to Metamathematics</i> (Tenth ed.). North-Holland Publishing Company. ISBN&nbsp;978-0-7204-2103-3.</li>
  <li>Knuth, Donald (1997). <i>Fundamental Algorithms, Third Edition</i>. Reading, Massachusetts: Addison–Wesley. ISBN&nbsp;978-0-201-89683-1.</li>
  <li>Knuth, Donald (1969). <i>Volume 2/Seminumerical Algorithms, The Art of Computer Programming First Edition</i>. Reading, Massachusetts: Addison–Wesley.</li>
  <li>科索沃 <i>数理逻辑元素及其在子算法理论中的应用</i>，LSU Publ。列宁格勒，1981年</li>
  <li>Kowalski, Robert (1979). "Algorithm=Logic+Control". <i>Communications of the ACM</i>. <b>22</b> (7): 424–436. doi:10.1145/359131.359136.</li>
  <li>马可夫(1954) <i>算法理论</i>。[译自雅克·舒尔-孔和科普特工作人员]印刻莫斯科，苏联科学院，1954年[，即耶路撒冷，以色列科学翻译方案，1961年；可从华盛顿美国商务部技术服务办公室获得]描述444页&nbsp;28&nbsp;cm。苏联科学院数学研究所作品俄文翻译，第五版&nbsp;42.原标题:Teoriya algerifmov。[QA248。达特茅斯学院图书馆。美国商务部技术服务办公室，电话:OTS 60-51085。]</li>
  <li>Minsky, Marvin (1967). <i>Computation: Finite and Infinite Machines</i> (First ed.). Prentice-Hall, Englewood Cliffs, NJ. ISBN&nbsp;978-0-13-165449-5. 明斯基扩展了他的”...算法的想法——一个有效的程序……”在第5.1章中 <i>可计算性、有效程序和算法。无限的机器。</i></li>
  <li>Post, Emil (1936). "Finite Combinatory Processes, Formulation I". <i>The Journal of Symbolic Logic</i>. <b>1</b> (3): 103–105. doi:10.2307/2269031. JSTOR&nbsp;2269031. 重印于 <i>不可判定的</i>，第页。&nbsp;289ff。Post定义了一个简单的类似算法的过程，一个人写标记或擦除标记，然后从一个盒子到另一个盒子，最后停下来，按照简单的指令列表。这被克莱尼引用为他的“论文一”的一个来源，即所谓的邱奇－图灵论题。</li>
  <li>Rogers, Jr, Hartley (1987). <i>Theory of Recursive Functions and Effective Computability</i>. The MIT Press. ISBN&nbsp;978-0-262-68052-3.</li>
  <li>Rosser, J.B. (1939). "An Informal Exposition of Proofs of Godel's Theorem and Church's Theorem". <i>Journal of Symbolic Logic</i>. <b>4</b> (2): 53–60. doi:10.2307/2269059. JSTOR&nbsp;2269059. 重印于 <i>不可判定的</i>，p。&nbsp;223ff。这是罗斯尔对“有效方法”的著名定义...一种方法，其每一步都是精确预先确定的，并且一定会在有限的步骤中产生答案...一种机器，除了插入问题和(稍后)阅读答案之外，无需人工干预就能解决集合中的任何问题。&nbsp;225–226， <i>不可判定的</i>)</li>
  <li>Santos-Lang, Christopher (2014). "Moral Ecology Approaches to Machine Ethics" (PDF). In van Rysewyk, Simon; Pontier, Matthijs. <i>Machine Medical Ethics</i>. Intelligent Systems, Control and Automation: Science and Engineering. <b>74</b>. Switzerland: Springer. pp.&nbsp;111–127. doi:10.1007/978-3-319-08108-3_8. ISBN&nbsp;978-3-319-08107-6.</li>
  <li>Scott, Michael L. (2009). <i>Programming Language Pragmatics</i> (3rd ed.). Morgan Kaufmann Publishers/Elsevier. ISBN&nbsp;978-0-12-374514-9.</li>
  <li>Sipser, Michael (2006). <i>Introduction to the Theory of Computation</i>. PWS Publishing Company. ISBN&nbsp;978-0-534-94728-6.</li>
  <li>Sober, Elliott; Wilson, David Sloan (1998). <i>Unto Others: The Evolution and Psychology of Unselfish Behavior</i>. Cambridge: Harvard University Press.</li>
  <li>Stone, Harold S. (1972). <i>Introduction to Computer Organization and Data Structures</i> (1972 ed.). McGraw-Hill, New York. ISBN&nbsp;978-0-07-061726-1. 特别参见第一章，标题为: <i>算法、图灵机和程序</i>。”他简洁的非正式定义...机器人可以遵循的任何指令序列称为 <i>算法</i>"(p .&nbsp;4)。</li>
  <li>Tausworthe, Robert C (1977). <i>Standardized Development of Computer Software Part 1 Methods</i>. Englewood Cliffs NJ: Prentice–Hall, Inc. ISBN&nbsp;978-0-13-842195-3.</li>
  <li>Turing, Alan M. (1936–37). "On Computable Numbers, With An Application to the Entscheidungsproblem". <i>Proceedings of the London Mathematical Society</i>. Series 2. <b>42</b>: 230–265. doi:10.1112/plms/s2-42.1.230.。更正，同上，第43卷(1937)页&nbsp;544–546。重印于 <i>不可判定的</i>，p。&nbsp;116ff。图灵的著名论文是在英国美国国王学院剑桥大学完成的硕士论文。</li>
  <li>Turing, Alan M. (1939). "Systems of Logic Based on Ordinals". <i>Proceedings of the London Mathematical Society</i>. <b>45</b>: 161–228. doi:10.1112/plms/s2-45.1.161. hdl:21.11116/0000-0001-91CE-3. 重印于 <i>不可判定的</i>，第页。&nbsp;155ff。图灵定义“神谕”的论文是他在普林斯顿时的博士论文。</li>
  <li>美国专利及商标局(2006)， <i>2106.02 **&gt;Mathematical Algorithms: 2100 Patentability</i>《专利审查程序手册》(MPEP)。最新修订于2006年8月</li>
 </ul><p></p></div></div></div></div><div id="references"><h2 class="title" id="par_references">参考文献</h2><ul class="references"><li id="quote_1"><span class="references-num">[1]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Any classical mathematical algorithm, for example, can be described in a finite number of English words" (Rogers 1987:2)..</span></p></li><li id="quote_2"><span class="references-num">[2]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Well defined with respect to the agent that executes the algorithm: "There is a computing agent, usually human, which can react to the instructions and carry out the computations" (Rogers 1987:2)..</span></p></li><li id="quote_3"><span class="references-num">[3]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"an algorithm is a procedure for computing a function (with respect to some chosen notation for integers) ... this limitation (to numerical functions) results in no loss of generality", (Rogers 1987:1)..</span></p></li><li id="quote_4"><span class="references-num">[4]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"An algorithm has zero or more inputs, i.e., quantities which are given to it initially before the algorithm begins" (Knuth 1973:5)..</span></p></li><li id="quote_5"><span class="references-num">[5]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"A procedure which has all the characteristics of an algorithm except that it possibly lacks finiteness may be called a 'computational method'" (Knuth 1973:5)..</span></p></li><li id="quote_6"><span class="references-num">[6]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"An algorithm has one or more outputs, i.e. quantities which have a specified relation to the inputs" (Knuth 1973:5)..</span></p></li><li id="quote_7"><span class="references-num">[7]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Whether or not a process with random interior processes (not including the input) is an algorithm is debatable. Rogers opines that: "a computation is carried out in a discrete stepwise fashion, without the use of continuous methods or analogue devices ... carried forward deterministically, without resort to random methods or devices, e.g., dice" (Rogers 1987:2)..</span></p></li><li id="quote_8"><span class="references-num">[8]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1943 in Davis 1965:274.</span></p></li><li id="quote_9"><span class="references-num">[9]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Rosser 1939 in Davis 1965:225.</span></p></li><li id="quote_10"><span class="references-num">[10]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Al-Khwarizmi biography". www-history.mcs.st-andrews.ac.uk..</span></p></li><li id="quote_11"><span class="references-num">[11]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Etymology of algorithm". Chambers Dictionary. Retrieved December 13, 2016..</span></p></li><li id="quote_12"><span class="references-num">[12]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Hogendijk, Jan P. (1998). "al-Khwarzimi". Pythagoras. 38 (2): 4–5. Archived from the original on April 12, 2009..</span></p></li><li id="quote_13"><span class="references-num">[13]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Oaks, Jeffrey A. "Was al-Khwarizmi an applied algebraist?". University of Indianapolis. Archived from the original on November 15, 2010. Retrieved May 30, 2008..</span></p></li><li id="quote_14"><span class="references-num">[14]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Brezina, Corona (2006). Al-Khwarizmi: The Inventor Of Algebra. The Rosen Publishing Group. ISBN 978-1-4042-0513-0..</span></p></li><li id="quote_15"><span class="references-num">[15]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Foremost mathematical texts in history, according to Carl B. Boyer..</span></p></li><li id="quote_16"><span class="references-num">[16]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Oxford English Dictionary, Third Edition, 2012 s.v..</span></p></li><li id="quote_17"><span class="references-num">[17]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Stone 1973:4.</span></p></li><li id="quote_18"><span class="references-num">[18]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Simanowski, Roberto (2018). The Death Algorithm and Other Digital Dilemmas. Untimely Meditations. 14. Translated by Chase, Jefferson. Cambridge, Massachusetts: MIT Press. p. 147. ISBN 9780262536370. Retrieved 27 May 2019. [...] the next level of abstraction of central bureaucracy: globally operating algorithms..</span></p></li><li id="quote_19"><span class="references-num">[19]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Stone simply requires that "it must terminate in a finite number of steps" (Stone 1973:7–8)..</span></p></li><li id="quote_20"><span class="references-num">[20]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Boolos and Jeffrey 1974,1999:19.</span></p></li><li id="quote_21"><span class="references-num">[21]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Stone 1972:5.</span></p></li><li id="quote_22"><span class="references-num">[22]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth 1973:7 states: "In practice we not only want algorithms, we want good algorithms ... one criterion of goodness is the length of time taken to perform the algorithm ... other criteria are the adaptability of the algorithm to computers, its simplicity, and elegance, etc.".</span></p></li><li id="quote_23"><span class="references-num">[23]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Stone 1973:6.</span></p></li><li id="quote_24"><span class="references-num">[24]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Stone 1973:7–8 states that there must be, "...a procedure that a robot [i.e., computer] can follow in order to determine precisely how to obey the instruction". Stone adds finiteness of the process, and definiteness (having no ambiguity in the instructions) to this definition..</span></p></li><li id="quote_25"><span class="references-num">[25]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth, loc. cit.</span></p></li><li id="quote_26"><span class="references-num">[26]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Minsky 1967.</span></p></li><li id="quote_27"><span class="references-num">[27]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Gurevich 2000:1, 3.</span></p></li><li id="quote_28"><span class="references-num">[28]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Sipser 2006:157.</span></p></li><li id="quote_29"><span class="references-num">[29]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Goodrich, Michael T.; Tamassia, Roberto (2002), Algorithm Design: Foundations, Analysis, and Internet Examples, John Wiley &amp; Sons, Inc., ISBN 978-0-471-38365-9.</span></p></li><li id="quote_30"><span class="references-num">[30]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth 1973:7.</span></p></li><li id="quote_31"><span class="references-num">[31]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Chaitin 2005:32.</span></p></li><li id="quote_32"><span class="references-num">[32]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Rogers 1987:1–2.</span></p></li><li id="quote_33"><span class="references-num">[33]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">In his essay "Calculations by Man and Machine: Conceptual Analysis" Seig 2002:390 credits this distinction to Robin Gandy, cf Wilfred Seig, et al., 2002 Reflections on the foundations of mathematics: Essays in honor of Solomon Feferman, Association for Symbolic Logic, A.K. Peters Ltd, Natick, MA..</span></p></li><li id="quote_34"><span class="references-num">[34]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Gandy 1980:126, Robin Gandy Church's Thesis and Principles for Mechanisms appearing on pp. 123–148 in J. Barwise et al. 1980 The Kleene Symposium, North-Holland Publishing Company..</span></p></li><li id="quote_35"><span class="references-num">[35]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">A "robot": "A computer is a robot that performs any task that can be described as a sequence of instructions." cf Stone 1972:3.</span></p></li><li id="quote_36"><span class="references-num">[36]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Lambek's "abacus" is a "countably infinite number of locations (holes, wires etc.) together with an unlimited supply of counters (pebbles, beads, etc). The locations are distinguishable, the counters are not". The holes have unlimited capacity, and standing by is an agent who understands and is able to carry out the list of instructions" (Lambek 1961:295). Lambek references Melzak who defines his Q-machine as "an indefinitely large number of locations ... an indefinitely large supply of counters distributed among these locations, a program, and an operator whose sole purpose is to carry out the program" (Melzak 1961:283). B-B-J (loc. cit.) add the stipulation that the holes are "capable of holding any number of stones" (p. 46). Both Melzak and Lambek appear in The Canadian Mathematical Bulletin, vol. 4, no. 3, September 1961..</span></p></li><li id="quote_37"><span class="references-num">[37]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">If no confusion results, the word "counters" can be dropped, and a location can be said to contain a single "number"..</span></p></li><li id="quote_38"><span class="references-num">[38]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"We say that an instruction is effective if there is a procedure that the robot can follow in order to determine precisely how to obey the instruction." (Stone 1972:6).</span></p></li><li id="quote_39"><span class="references-num">[39]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Minsky 1967: Chapter 11 "Computer models" and Chapter 14 "Very Simple Bases for Computability" pp. 255–281 in particular.</span></p></li><li id="quote_40"><span class="references-num">[40]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Knuth 1973:3..</span></p></li><li id="quote_41"><span class="references-num">[41]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">But always preceded by IF–THEN to avoid improper subtraction..</span></p></li><li id="quote_42"><span class="references-num">[42]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth 1973:4.</span></p></li><li id="quote_43"><span class="references-num">[43]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Stone 1972:5. Methods for extracting roots are not trivial: see Methods of computing square roots..</span></p></li><li id="quote_44"><span class="references-num">[44]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Leeuwen, Jan (1990). Handbook of Theoretical Computer Science: Algorithms and complexity. Volume A. Elsevier. p. 85. ISBN 978-0-444-88071-0..</span></p></li><li id="quote_45"><span class="references-num">[45]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">John G. Kemeny and Thomas E. Kurtz 1985 Back to Basic: The History, Corruption, and Future of the Language, Addison-Wesley Publishing Company, Inc. Reading, MA, ISBN 0-201-13433-0..</span></p></li><li id="quote_46"><span class="references-num">[46]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Tausworthe 1977:101.</span></p></li><li id="quote_47"><span class="references-num">[47]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Tausworthe 1977:142.</span></p></li><li id="quote_48"><span class="references-num">[48]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth 1973 section 1.2.1, expanded by Tausworthe 1977 at pages 100ff and Chapter 9.1.</span></p></li><li id="quote_49"><span class="references-num">[49]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Tausworthe 1977.</span></p></li><li id="quote_50"><span class="references-num">[50]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Heath 1908:300; Hawking's Dover 2005 edition derives from Heath..</span></p></li><li id="quote_51"><span class="references-num">[51]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">" 'Let CD, measuring BF, leave FA less than itself.' This is a neat abbreviation for saying, measure along BA successive lengths equal to CD until a point F is reached such that the length FA remaining is less than CD; in other words, let BF be the largest exact multiple of CD contained in BA" (Heath 1908:297).</span></p></li><li id="quote_52"><span class="references-num">[52]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">For modern treatments using division in the algorithm, see Hardy and Wright 1979:180, Knuth 1973:2 (Volume 1), plus more discussion of Euclid's algorithm in Knuth 1969:293–297 (Volume 2)..</span></p></li><li id="quote_53"><span class="references-num">[53]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Euclid covers this question in his Proposition 1..</span></p></li><li id="quote_54"><span class="references-num">[54]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Euclid's Elements, Book VII, Proposition 2". Aleph0.clarku.edu. Retrieved May 20, 2012..</span></p></li><li id="quote_55"><span class="references-num">[55]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">While this notion is in widespread use, it cannot be defined precisely..</span></p></li><li id="quote_56"><span class="references-num">[56]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knuth 1973:13–18. He credits "the formulation of algorithm-proving in terms of assertions and induction" to R W. Floyd, Peter Naur, C.A.R. Hoare, H.H. Goldstine and J. von Neumann. Tausworth 1977 borrows Knuth's Euclid example and extends Knuth's method in section 9.1 Formal Proofs (pp. 288–298)..</span></p></li><li id="quote_57"><span class="references-num">[57]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Tausworthe 1997:294.</span></p></li><li id="quote_58"><span class="references-num">[58]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf Knuth 1973:7 (Vol. I), and his more-detailed analyses on pp. 1969:294–313 (Vol II)..</span></p></li><li id="quote_59"><span class="references-num">[59]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Breakdown occurs when an algorithm tries to compact itself. Success would solve the Halting problem..</span></p></li><li id="quote_60"><span class="references-num">[60]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kriegel, Hans-Peter; Schubert, Erich; Zimek, Arthur (2016). "The (black) art of run-time evaluation: Are we comparing algorithms or implementations?". Knowledge and Information Systems. 52 (2): 341–378. doi:10.1007/s10115-016-1004-2. ISSN 0219-1377..</span></p></li><li id="quote_61"><span class="references-num">[61]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Gillian Conahan (January 2013). "Better Math Makes Faster Data Networks". discovermagazine.com..</span></p></li><li id="quote_62"><span class="references-num">[62]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Haitham Hassanieh, Piotr Indyk, Dina Katabi, and Eric Price, "ACM-SIAM Symposium On Discrete Algorithms (SODA) Archived 7月 4, 2013 at the Wayback Machine, Kyoto, January 2012. See also the sFFT Web Page..</span></p></li><li id="quote_63"><span class="references-num">[63]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kowalski 1979.</span></p></li><li id="quote_64"><span class="references-num">[64]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Knapsack Problems | Hans Kellerer | Springer (in 英语). Springer. 2004. ISBN 978-3-540-40286-2..</span></p></li><li id="quote_65"><span class="references-num">[65]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Carroll, Sue; Daughtrey, Taz (July 4, 2007). Fundamental Concepts for the Software Quality Engineer. American Society for Quality. pp. 282 et seq. ISBN 978-0-87389-720-4..</span></p></li><li id="quote_66"><span class="references-num">[66]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">George B. Dantzig and Mukund N. Thapa. 2003. Linear Programming 2: Theory and Extensions. Springer-Verlag..</span></p></li><li id="quote_67"><span class="references-num">[67]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Tsypkin (1971). Adaptation and learning in automatic systems. Academic Press. p. 54. ISBN 978-0-08-095582-7..</span></p></li><li id="quote_68"><span class="references-num">[68]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Ast, Courtney. "Eratosthenes". Wichita State University: Department of Mathematics and Statistics..</span></p></li><li id="quote_69"><span class="references-num">[69]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Cooke, Roger L. (2005). The History of Mathematics: A Brief Course. John Wiley &amp; Sons. ISBN 978-1-118-46029-0..</span></p></li><li id="quote_70"><span class="references-num">[70]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Davis 2000:18.</span></p></li><li id="quote_71"><span class="references-num">[71]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Bolter 1984:24.</span></p></li><li id="quote_72"><span class="references-num">[72]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Bolter 1984:26.</span></p></li><li id="quote_73"><span class="references-num">[73]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Bolter 1984:33–34, 204–206..</span></p></li><li id="quote_74"><span class="references-num">[74]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">All quotes from W. Stanley Jevons 1880 Elementary Lessons in Logic: Deductive and Inductive, Macmillan and Co., London and New York. Republished as a googlebook; cf Jevons 1880:199–201. Louis Couturat 1914 the Algebra of Logic, The Open Court Publishing Company, Chicago and London. Republished as a googlebook; cf Couturat 1914:75–76 gives a few more details; he compares this to a typewriter as well as a piano. Jevons states that the account is to be found at January 20, 1870 The Proceedings of the Royal Society..</span></p></li><li id="quote_75"><span class="references-num">[75]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Jevons 1880:199–200.</span></p></li><li id="quote_76"><span class="references-num">[76]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">All quotes from John Venn 1881 Symbolic Logic, Macmillan and Co., London. Republished as a googlebook. cf Venn 1881:120–125. The interested reader can find a deeper explanation in those pages..</span></p></li><li id="quote_77"><span class="references-num">[77]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Bell and Newell diagram 1971:39, cf. Davis 2000.</span></p></li><li id="quote_78"><span class="references-num">[78]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">* Melina Hill, Valley News Correspondent, A Tinkerer Gets a Place in History, Valley News West Lebanon NH, Thursday, March 31, 1983, p. 13..</span></p></li><li id="quote_79"><span class="references-num">[79]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Davis 2000:14.</span></p></li><li id="quote_80"><span class="references-num">[80]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">van Heijenoort 1967:81ff.</span></p></li><li id="quote_81"><span class="references-num">[81]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">van Heijenoort's commentary on Frege's Begriffsschrift, a formula language, modeled upon that of arithmetic, for pure thought in van Heijenoort 1967:1.</span></p></li><li id="quote_82"><span class="references-num">[82]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Dixon 1906, cf. Kleene 1952:36–40.</span></p></li><li id="quote_83"><span class="references-num">[83]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf. footnote in Alonzo Church 1936a in Davis 1965:90 and 1936b in Davis 1965:110.</span></p></li><li id="quote_84"><span class="references-num">[84]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1935–6 in Davis 1965:237ff, Kleene 1943 in Davis 1965:255ff.</span></p></li><li id="quote_85"><span class="references-num">[85]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Church 1936 in Davis 1965:88ff.</span></p></li><li id="quote_86"><span class="references-num">[86]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">cf. "Finite Combinatory Processes – formulation 1", Post 1936 in Davis 1965:289–290.</span></p></li><li id="quote_87"><span class="references-num">[87]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1936–37 in Davis 1965:116ff.</span></p></li><li id="quote_88"><span class="references-num">[88]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Rosser 1939 in Davis 1965:226.</span></p></li><li id="quote_89"><span class="references-num">[89]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1943 in Davis 1965:273–274.</span></p></li><li id="quote_90"><span class="references-num">[90]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1952:300, 317.</span></p></li><li id="quote_91"><span class="references-num">[91]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1952:376.</span></p></li><li id="quote_92"><span class="references-num">[92]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1936–37 in Davis 1965:289–290.</span></p></li><li id="quote_93"><span class="references-num">[93]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1936 in Davis 1965, Turing 1939 in Davis 1965:160.</span></p></li><li id="quote_94"><span class="references-num">[94]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Hodges, p. 96.</span></p></li><li id="quote_95"><span class="references-num">[95]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1936–37:116.</span></p></li><li id="quote_96"><span class="references-num">[96]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1936–37 in Davis 1965:136.</span></p></li><li id="quote_97"><span class="references-num">[97]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Turing 1939 in Davis 1965:160.</span></p></li></ul></div><div class="read-num">阅读 <!-- -->3.0<!-- -->w</div></div><div class="right-side" id="rightSide"><div class="side" id="lemma-side"><div class="side-title">版本记录</div><ul class="side-lst"><li><p class="side-lst-txt">暂无</p></li></ul><div class="user-card userCard"></div></div><div class="side"><div class="side-event"></div></div></div></div><div class="footer-box"><div id="footer"><div class="footer-logo-wrap"><div class="footer-logo"></div><div class="footer-logo-text">知识·传播·科普</div></div><div class="footer-info">本网站内容采用<a target="_blank" href="https://web.archive.org/web/20221025113656/https://creativecommons.org/licenses/by-sa/3.0/deed.zh?tdsourcetag=s_pctim_aiomsg">CC-BY-SA 3.0</a>授权</div><div class="footer-btn-wrap"><a target="_blank" href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/help/#user_protocol">用户协议</a><a target="_blank" href="https://web.archive.org/web/20221025113656/http://www.sogou.com/docs/terms.htm?v=1">免责声明</a><a target="_blank" href="https://web.archive.org/web/20221025113656/http://corp.sogou.com/private.html">隐私政策</a><a target="_blank" href="https://web.archive.org/web/20221025113656/https://baike.sogou.com/kexue/intro.htm">关于我们</a></div></div></div><script>window.lemmaInfo ={"lemmaId":"10392","versionId":"53964833581752068","title":"算法","subtitle":"","abstracts":{"paragraphId":"53964833581752086","title":"摘要","versionId":"53964833581752069","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":2,"content":"<p>在数学和计算机科学中，算法是如何解决一类问题的明确规范。算法可以执行计算、数据处理、自动推理和其他任务。</p>\n<p>作为一种有效的方法，算法可以在有限的空间和时间内用定义明确的形式语言<sup><a href=\"#quote_1\" class=\"kx_ref\">[1]</a></sup> 来表示，以计算函数<sup><a href=\"#quote_2\" class=\"kx_ref\">[2]</a></sup> <sup><a href=\"#quote_3\" class=\"kx_ref\">[3]</a></sup> 。从初始状态和初始输入(可能为空)开始，<sup><a href=\"#quote_4\" class=\"kx_ref\">[4]</a></sup> 指令描述了一种计算，当执行该计算时，该计算通过有限的<sup><a href=\"#quote_5\" class=\"kx_ref\">[5]</a></sup> 数量的明确定义的连续状态，最终产生的“输出”<sup><a href=\"#quote_6\" class=\"kx_ref\">[6]</a></sup> 并终止于最终结束状态。从一种状态到下一种状态的转变不一定是 明确的；一些被称为随机算法的算法包含随机输入。<sup><a href=\"#quote_7\" class=\"kx_ref\">[7]</a></sup> </p>\n<p>算法的概念已经存在了几个世纪。希腊数学家使用 Eratosthenes筛子中的算法寻找素数，欧几里德算法寻找两个数的最大公约数。 </p>\n<p>“算法”一词本身源自9世纪数学家muḥammad· ibn Mūsā al-Khwārizmī的拉丁化算法。后来成为现代算法概念的部分 规范化始于1928年 David Hilbert提出的解决判定问题 (决策问题)的尝试。后来的 规范化被 看作试图定义“有效可计算性”<sup><a href=\"#quote_8\" class=\"kx_ref\">[8]</a></sup> 或“有效方法”。<sup><a href=\"#quote_9\" class=\"kx_ref\">[9]</a></sup> 这些 规范化包括1930年、1934年和1935年的 Gödel–Herbrand–Kleene递归函数，1936年的 Alonzo Church的λ微积分，1936年的 Emil Post公式1，以及1936-37年和1939年 Alan Turing的图灵机。</p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_4716?width=231&height=174&titlename=Flowchart%20of%20an%20algorithm%20(Euclid's%20algorithm)%20for%20calculating%20the%20greatest%20common%20divisor%20(g.c.d.)%20of%20two%20numbers%20a%20and%20b%20in%20locations%20named%20A%20and%20B.%20The%20algorithm%20proceeds%20by%20successive%20subtractions%20in%20two%20loops:%20IF%20the%20test%20B%20%E2%89%A5%20A%20yields%20%22yes%22%20(or%20true)%20(more%20accurately%20the%20number%20b%20in%20location%20B%20is%20greater%20than%20or%20equal%20to%20the%20number%20a%20in%20location%20A)%20THEN,%20the%20algorithm%20specifies%20B%20%E2%86%90%20B%20%E2%88%92%20A%20(meaning%20the%20number%20b%20%E2%88%92%20a%20replaces%20the%20old%20b).%20Similarly,%20IF%20A%20%3E%20B,%20THEN%20A%20%E2%86%90%20A%20%E2%88%92%20B.%20The%20process%20terminates%20when%20(the%20contents%20of)%20B%20is%200,%20yielding%20the%20g.c.d.%20in%20A.%20(Algorithm%20derived%20from%20Scott%202009:13;%20symbols%20and%20drawing%20style%20from%20Tausworthe%201977).&w=300&h=675","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_4716","rw":300,"rh":675,"title":"Flowchart of an algorithm (Euclid's algorithm) for calculating the greatest common divisor (g.c.d.) of two numbers a and b in locations named A and B. The algorithm proceeds by successive subtractions in two loops: IF the test B ≥ A yields \"yes\" (or true) (more accurately the number b in location B is greater than or equal to the number a in location A) THEN, the algorithm specifies B ← B − A (meaning the number b − a replaces the old b). Similarly, IF A > B, THEN A ← A − B. The process terminates when (the contents of) B is 0, yielding the g.c.d. in A. (Algorithm derived from Scott 2009:13; symbols and drawing style from Tausworthe 1977).","alt":null,"width":231,"height":174}],"card":null,"references":[],"versionCount":0},"card":{"paragraphId":"53964833581752085","title":"基本信息","versionId":"53964833581752070","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":3,"content":"","pics":null,"card":{"cardItems":[{"key":"外文名","value":"Algorithm"},{"key":"特征","value":"有穷性，确切性，输入项，输出项，可行性"},{"key":"常用","value":"计算、数据处理和自动推理"}]},"references":[],"versionCount":0},"categories":[{"id":1,"name":"计算机","parents":[]}],"creator":{"uid":9348296,"name":"邹同学","pic":"https://web.archive.org/web/20221025113656/https://cache.soso.com/qlogo/g?b=oidb&k=3FK1wF1EtdEic0ickUq2L9sw&s=100&t=1556702969","introduction":null,"educations":[{"schoolName":"四川大学","major":"","degree":"硕士","universityId":90,"universityLogo":"https://web.archive.org/web/20221025113656/https://img01.sogoucdn.com/app/a/200943/41b2078c-6012-11e9-8112-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":null,"lab":null,"researchField":null}],"jobs":null,"works":null,"educationBrief":"四川大学","jobBrief":"","role":0,"roleName":null,"title":"四川大学 · 计算机科学与技术硕士","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":67,"partnerIdCreateTime":1594286507,"partnerIdPoped":false},"createTime":1571038051,"editor":{"uid":9348296,"name":"邹同学","pic":"https://web.archive.org/web/20221025113656/https://cache.soso.com/qlogo/g?b=oidb&k=3FK1wF1EtdEic0ickUq2L9sw&s=100&t=1556702969","introduction":null,"educations":[{"schoolName":"四川大学","major":"","degree":"硕士","universityId":90,"universityLogo":"https://web.archive.org/web/20221025113656/https://img01.sogoucdn.com/app/a/200943/41b2078c-6012-11e9-8112-fc4dd4f70029","majorLevel1":"理学","majorLevel2":"计算机科学与技术","majorLevel3":"计算机科学与技术","majorLevel1Id":1,"majorLevel2Id":316,"majorLevel3Id":319,"state":null,"lab":null,"researchField":null}],"jobs":null,"works":null,"educationBrief":"四川大学","jobBrief":"","role":0,"roleName":null,"title":"四川大学 · 计算机科学与技术硕士","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":67,"partnerIdCreateTime":1594286507,"partnerIdPoped":false},"editTime":1576233909,"state":1,"versionCount":2,"upNum":4,"downNum":0,"pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_4716?width=231&height=174&titlename=Flowchart%20of%20an%20algorithm%20(Euclid's%20algorithm)%20for%20calculating%20the%20greatest%20common%20divisor%20(g.c.d.)%20of%20two%20numbers%20a%20and%20b%20in%20locations%20named%20A%20and%20B.%20The%20algorithm%20proceeds%20by%20successive%20subtractions%20in%20two%20loops:%20IF%20the%20test%20B%20%E2%89%A5%20A%20yields%20%22yes%22%20(or%20true)%20(more%20accurately%20the%20number%20b%20in%20location%20B%20is%20greater%20than%20or%20equal%20to%20the%20number%20a%20in%20location%20A)%20THEN,%20the%20algorithm%20specifies%20B%20%E2%86%90%20B%20%E2%88%92%20A%20(meaning%20the%20number%20b%20%E2%88%92%20a%20replaces%20the%20old%20b).%20Similarly,%20IF%20A%20%3E%20B,%20THEN%20A%20%E2%86%90%20A%20%E2%88%92%20B.%20The%20process%20terminates%20when%20(the%20contents%20of)%20B%20is%200,%20yielding%20the%20g.c.d.%20in%20A.%20(Algorithm%20derived%20from%20Scott%202009:13;%20symbols%20and%20drawing%20style%20from%20Tausworthe%201977).&w=300&h=675","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_4716","rw":300,"rh":675,"title":"Flowchart of an algorithm (Euclid's algorithm) for calculating the greatest common divisor (g.c.d.) of two numbers a and b in locations named A and B. The algorithm proceeds by successive subtractions in two loops: IF the test B ≥ A yields \"yes\" (or true) (more accurately the number b in location B is greater than or equal to the number a in location A) THEN, the algorithm specifies B ← B − A (meaning the number b − a replaces the old b). Similarly, IF A > B, THEN A ← A − B. The process terminates when (the contents of) B is 0, yielding the g.c.d. in A. (Algorithm derived from Scott 2009:13; symbols and drawing style from Tausworthe 1977).","alt":null,"width":231,"height":174},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_4717?w=300&h=246&titlename=Logical%20NAND%20algorithm%20implemented%20electronically%20in%207400%20chip","url":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_4717","rw":300,"rh":246,"title":"Logical NAND algorithm implemented electronically in 7400 chip","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_136?w=176&h=319&titlename=Flowchart%20examples%20of%20the%20canonical%20B%C3%B6hm-Jacopini%20structures:%20the%20SEQUENCE%20(rectangles%20descending%20the%20page),%20the%20WHILE-DO%20and%20the%20IF-THEN-ELSE.%20The%20three%20structures%20are%20made%20of%20the%20primitive%20conditional%20GOTO%20(IF%20test%3Dtrue%20THEN%20GOTO%20step%20xxx)%20(a%20diamond),%20the%20unconditional%20GOTO%20(rectangle),%20various%20assignment%20operators%20(rectangle),%20and%20HALT%20(rectangle).%20Nesting%20of%20these%20structures%20inside%20assignment-blocks%20result%20in%20complex%20diagrams%20(cf%20Tausworthe%201977:100,%20114).","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_136","rw":176,"rh":319,"title":"Flowchart examples of the canonical Böhm-Jacopini structures: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (IF test=true THEN GOTO step xxx) (a diamond), the unconditional GOTO (rectangle), various assignment operators (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100, 114).","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_4718?w=280&h=214&titlename=An%20animation%20of%20the%20quicksort%20algorithm%20sorting%20an%20array%20of%20randomized%20values.%20The%20red%20bars%20mark%20the%20pivot%20element;%20at%20the%20start%20of%20the%20animation,%20the%20element%20farthest%20to%20the%20right-hand%20side%20is%20chosen%20as%20the%20pivot.","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_4718","rw":280,"rh":214,"title":"An animation of the quicksort algorithm sorting an array of randomized values. The red bars mark the pivot element; at the start of the animation, the element farthest to the right-hand side is chosen as the pivot.","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_134?w=250&h=263&titlename=The%20example-diagram%20of%20Euclid's%20algorithm%20from%20T.L.%20Heath%20(1908),%20with%20more%20detail%20added.%20Euclid%20does%20not%20go%20beyond%20a%20third%20measuring%20and%20gives%20no%20numerical%20examples.%20Nicomachus%20gives%20the%20example%20of%2049%20and%2021:%20%22I%20subtract%20the%20less%20from%20the%20greater;%2028%20is%20left;%20then%20again%20I%20subtract%20from%20this%20the%20same%2021%20(for%20this%20is%20possible);%207%20is%20left;%20I%20subtract%20this%20from%2021,%2014%20is%20left;%20from%20which%20I%20again%20subtract%207%20(for%20this%20is%20possible);%207%20is%20left,%20but%207%20cannot%20be%20subtracted%20from%207.%22%20Heath%20comments%20that%20%22The%20last%20phrase%20is%20curious,%20but%20the%20meaning%20of%20it%20is%20obvious%20enough,%20as%20also%20the%20meaning%20of%20the%20phrase%20about%20ending%20'at%20one%20and%20the%20same%20number'.%22(Heath%201908:300).","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_134","rw":250,"rh":263,"title":"The example-diagram of Euclid's algorithm from T.L. Heath (1908), with more detail added. Euclid does not go beyond a third measuring and gives no numerical examples. Nicomachus gives the example of 49 and 21: \"I subtract the less from the greater; 28 is left; then again I subtract from this the same 21 (for this is possible); 7 is left; I subtract this from 21, 14 is left; from which I again subtract 7 (for this is possible); 7 is left, but 7 cannot be subtracted from 7.\" Heath comments that \"The last phrase is curious, but the meaning of it is obvious enough, as also the meaning of the phrase about ending 'at one and the same number'.\"(Heath 1908:300).","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_138?w=350&h=210&titlename=A%20graphical%20expression%20of%20Euclid's%20algorithm%20to%20find%20the%20greatest%20common%20divisor%20for%201599%20and%20650.%20%201599%20%3D%20650%C3%972%20%2B%20299%0A%20650%20%3D%20299%C3%972%20%2B%2052%0A%20299%20%3D%2052%C3%975%20%2B%2039%0A%2052%20%3D%2039%C3%971%20%2B%2013%0A%2039%20%3D%2013%C3%973%20%2B%200","url":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_138","rw":350,"rh":210,"title":"A graphical expression of Euclid's algorithm to find the greatest common divisor for 1599 and 650.  1599 = 650×2 + 299\n 650 = 299×2 + 52\n 299 = 52×5 + 39\n 52 = 39×1 + 13\n 39 = 13×3 + 0","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_135?titlename=%22Inelegant%22%20is%20a%20translation%20of%20Knuth's%20version%20of%20the%20algorithm%20with%20a%20subtraction-based%20remainder-loop%20replacing%20his%20use%20of%20division%20(or%20a%20%22modulus%22%20instruction).%20Derived%20from%20Knuth%201973:2%E2%80%934.%20Depending%20on%20the%20two%20numbers%20%22Inelegant%22%20may%20compute%20the%20g.c.d.%20in%20fewer%20steps%20than%20%22Elegant%22.&w=163&h=349","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_135","rw":163,"rh":349,"title":"\"Inelegant\" is a translation of Knuth's version of the algorithm with a subtraction-based remainder-loop replacing his use of division (or a \"modulus\" instruction). Derived from Knuth 1973:2–4. Depending on the two numbers \"Inelegant\" may compute the g.c.d. in fewer steps than \"Elegant\".","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_132?w=200&h=150&titlename=Alan%20Turing's%20statue%20at%20Bletchley%20Park","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_132","rw":200,"rh":150,"title":"Alan Turing's statue at Bletchley Park","alt":null,"width":0,"height":0}],"catalogs":[{"level":1,"title":"词源","paragraphId":"14995099515617542","subCatalogs":null},{"level":1,"title":"非正式定义","paragraphId":"14995099515617543","subCatalogs":null},{"level":1,"title":"形式化","paragraphId":"14995099515617544","subCatalogs":[{"level":2,"title":"表达算法","paragraphId":"14995099515617544","subCatalogs":null}]},{"level":1,"title":"设计","paragraphId":"14995099532394758","subCatalogs":null},{"level":1,"title":"履行","paragraphId":"14995099532394759","subCatalogs":null},{"level":1,"title":"计算机算法","paragraphId":"14995099532394760","subCatalogs":null},{"level":1,"title":"例子","paragraphId":"14995099532394761","subCatalogs":[{"level":2,"title":"算法示例","paragraphId":"14995099532394761","subCatalogs":null},{"level":2,"title":"欧几里得算法","paragraphId":"14995099532394761","subCatalogs":null},{"level":2,"title":"测试欧几里得算法","paragraphId":"14995099532394761","subCatalogs":null},{"level":2,"title":"欧几里得算法的度量和改进","paragraphId":"14995099532394761","subCatalogs":null}]},{"level":1,"title":"算法分析","paragraphId":"14995099549171979","subCatalogs":[{"level":2,"title":"形式化方法 与 经验方法","paragraphId":"14995099549171979","subCatalogs":null},{"level":2,"title":"执行效率","paragraphId":"14995099549171979","subCatalogs":null}]},{"level":1,"title":"分类","paragraphId":"14995099549171980","subCatalogs":[{"level":2,"title":"通过实现方法","paragraphId":"14995099549171980","subCatalogs":null},{"level":2,"title":"通过设计 范例","paragraphId":"14995099549171980","subCatalogs":null},{"level":2,"title":"优化问题","paragraphId":"14995099549171980","subCatalogs":null},{"level":2,"title":"按研究领域","paragraphId":"14995099549171980","subCatalogs":null},{"level":2,"title":"按复杂性","paragraphId":"14995099549171980","subCatalogs":null}]},{"level":1,"title":"连续算法","paragraphId":"14995099549171981","subCatalogs":null},{"level":1,"title":"法律问题","paragraphId":"14995099549171982","subCatalogs":null},{"level":1,"title":"历史:“算法”概念的发展","paragraphId":"14995099549171983","subCatalogs":[{"level":2,"title":"古代近东","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"离散和可区分的符号","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"作为数字“占位符”的符号操作:代数","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"具有离散状态的机械装置","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"从19世纪到20世纪中期的数学","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"Emil Post (1936)和 Alan Turing (1936-37，1939)","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"J.B. Rosser (1939)和S.C. Kleene&nbsp; (1943)","paragraphId":"14995099549171983","subCatalogs":null},{"level":2,"title":"1950年后的历史","paragraphId":"14995099549171983","subCatalogs":null}]},{"level":1,"title":"笔记","paragraphId":"14995099565949198","subCatalogs":null},{"level":1,"title":"文献学","paragraphId":"14995099565949199","subCatalogs":null},{"level":1,"title":"参考文献","paragraphId":"-1","subCatalogs":null}],"paragraphs":[{"paragraphId":"14995099515617542","title":"词源","versionId":"53964833581752071","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>“算法”一词起源于将 Muhammad ibn Musa al-Khwarizmi的名字拉丁化，这是 算法书的第一步。<sup><a href=\"#quote_10\" class=\"kx_ref\">[10]</a></sup><sup><a href=\"#quote_11\" class=\"kx_ref\">[11]</a></sup>Al-Khwārizmī(阿拉伯语:الخوارزمي‎，波斯语:خوارزمی‎，约780-850年)是巴格达智慧宫的波斯数学家、天文学家、地理学家和学者，他的名字的意思是“Khwarazm的本地人”， Khwarazm是大伊朗的一部分，现在在乌兹别克斯坦。<sup><a href=\"#quote_12\" class=\"kx_ref\">[12]</a></sup><sup><a href=\"#quote_13\" class=\"kx_ref\">[13]</a></sup> </p><p>大约在825年， al-Khwarizmi写了一篇关于印度-阿拉伯数字系统的阿拉伯语论文，该论文在12世纪被翻译成拉丁文，题目是《 Algoritmi de numero Indorum》。这个标题的意思是“印第安人数字上的 Algoritmi”，其中“ Algoritmi”是译者对 Al-Khwarizmi名字的拉丁化。<sup><a href=\"#quote_14\" class=\"kx_ref\">[14]</a></sup>Al-Khwarizmi是中世纪晚期被 欧洲阅读最广泛的数学家，主要是通过他的另一本书《代数》。<sup><a href=\"#quote_15\" class=\"kx_ref\">[15]</a></sup> 在中世纪晚期的拉丁语中，algorismus，英语中的“algorism”，都是他的名字的 传讹，仅仅意味着“十进制数字系统”。在15世纪，在希腊单词ἀριθμός“number”(参见“算术”)的影响下，拉丁语单词被改为algorithmus，相应的英语术语“algorithm”在17世纪首次得到证实；现代意义是在19世纪引入的。<sup><a href=\"#quote_16\" class=\"kx_ref\">[16]</a></sup> </p><p>在英语中，它首先在1230年左右 被使用，然后在1391年被乔叟使用。英语采用了法语术语，但是直到19世纪末，“算法”才具有现代英语中的含义。</p><p>这个词的另一个早期用法是从1240年开始的，在 Alexandre de Villedieu撰写的一本名为《 Carmen de Algorismo》的手册中。它是这样开始的:</p><p><i>Haec algorismus ars praesens dicitur, in qua / Talibus Indorum fruimur bis quinque figuris.</i></p><p>其翻译为:</p><p>算法是一门通过现在我们使用印度数字的艺术， 数字是2乘以5。</p><p>这首诗有几百行长，总结了用印度骰子或印度数字的新风格计算的艺术。</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099515617543","title":"非正式定义","versionId":"53964833581752072","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>有关“算法”定义的各种观点的详细介绍，请参见算法特性。<sup><a href=\"#quote_17\" class=\"kx_ref\">[17]</a></sup> 非正式定义可以是“一组精确定义操作序列的规则”。<sup><a href=\"#quote_18\" class=\"kx_ref\">[18]</a></sup>这将包括所有计算机程序，包括不执行数值计算的程序。一般来说，程序只有在最终停止时才是算法。<sup><a href=\"#quote_19\" class=\"kx_ref\">[19]</a></sup> </p><p>算法的一个典型例子是欧几里德算法，用于确定两个整数的最大公约数；上面的流程图描述了一个示例(还有其他示例),并且在后面的部分中作为一个示例。</p><p>Boolos，Jeffrey &amp; 1974，1999在下面的引文中给出了这个词的非正式含义:</p><p>没有人能写得足够快、足够长或足够小...（小得没有限度， 你会试图写在分子、原子、电子上)，通过用某种符号一个接一个地写出它们的名字来列出一个可列举的无限集合的所有成员。但是人类可以做一些同样有用的事情，在某些可列举的无限集合的情况下:对于任意有限的n，他们可以给出明确的指令来确定集合的第n个成员。这样的指令可以非常明确地给出，其形式是计算机或者只能对符号进行非常基本的运算的人可以 做到的。<sup><a href=\"#quote_20\" class=\"kx_ref\">[20]</a></sup></p><p>“可枚举无限集合”是指其元素可以与整数一一对应的集合。因此， Boolos和 Jeffrey说，一个算法意味着一个过程的指令，该过程从任意的“输入”整数或者理论上可以任意大的整数“创建”输出整数 。因此，一个算法可以是一个代数方程，比如y = m+n——两个任意的“输入变量”m和n，它们产生一个输出y。但是，不同作者对这个概念的定义表明，这个词隐含的意义远远不止于此，大约是(对于加法例子):</p><p>\n <dl>\n  <dd>\n   精确的指令(以“计算机”理解的语言) &nbsp;<sup><a href=\"#quote_21\" class=\"kx_ref\">[21]</a></sup> 用于快速、高效的“良好” &nbsp;<sup><a href=\"#quote_22\" class=\"kx_ref\">[22]</a></sup> 过程，该过程指定“计算机”(机器或人类，配备有必要的内部包含的信息和能力)的“移动”， &nbsp;<sup><a href=\"#quote_23\" class=\"kx_ref\">[23]</a></sup> 来查找、解码，然后处理任意输入的整数/符号m和n，符号+和=...和“有效地” &nbsp;<sup><a href=\"#quote_24\" class=\"kx_ref\">[24]</a></sup> 在“合理”时间内，在指定地点以指定格式&nbsp; 生成 &nbsp;<sup><a href=\"#quote_25\" class=\"kx_ref\">[25]</a></sup> 输出整数y。\n  </dd>\n </dl></p><p>算法的概念也被用来定义可判定性的概念。这个概念对于解释 正式系统是如何从一小组公理和规则开始形成的至关重要。在逻辑上，一个算法完成所需的时间是无法测量的，因为它显然与我们习惯的物理维度无关。这种不确定性是正在进行的工作的特征，这种不确定性导致无法找到既适合具体(在某种意义上)又适合抽象术语使用的算法定义。</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099515617544","title":"形式化","versionId":"53964833581752073","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>算法对计算机处理数据的方式至关重要。许多计算机程序都包含算法，这些算法详细说明了计算机执行特定任务(以特定顺序)应该执行的特定指令，例如计算员工工资或打印学生成绩单。因此，算法可以被认为是图灵完备系统可以模拟的任何操作序列。主张这一论点的作者包括 Minsky (1967)、 Savage (1987)和 Gurevich (2000):</p><p>Minsky:“但我们也会坚持，图灵...任何可以“自然地”被称为有效的程序，实际上可以通过(简单的)机器来实现。尽管这看起来有些极端，但争论...对它有利是很难反驳的”。<sup><a href=\"#quote_26\" class=\"kx_ref\">[26]</a></sup></p><p>Gurevich:\"...图灵支持他论文的非正式论点证明了一个更强有力的论点:每种算法都可以由图灵机模拟...根据 Savage [1987)，算法是由图灵机定义的计算过程。<sup><a href=\"#quote_27\" class=\"kx_ref\">[27]</a></sup></p><p>通常，当算法与处理信息相关联时，数据可以从输入源读取，写入输出设备并存储以供进一步处理。存储的数据被视为执行算法的实体的内部状态的一部分。实际上，状态存储在一个或多个数据结构中。</p><p>对于一些这样的计算过程，算法必须被严格定义:在所有可能出现的情况下以其应用的方式指定。也就是说，任何有条件的步骤都必须系统地 逐一处理；每个案例的标准必须清晰(并且是可计算的)。</p><p>因为算法是精确步骤的精确列表，所以计算顺序对于算法的运行总是至关重要的。指令通常被认为是明确列出的，并且被描述为从“顶部”开始到“底部”，这种思想被更正式地描述为控制流。</p><p>到目前为止，关于算法形式化的讨论已经假定了命令式编程的前提。这是最常见的概念，它试图以离散的“机械”方式描述一项任务。这种形式化算法概念的独特之处在于赋值操作，它设置变量的值。它源于“记忆”作为便笺簿的直觉。下面有一个这样的例子。</p><p>关于算法构成的一些替代概念，请参见函数编程和逻辑编程。</p><p><h3>表达算法</h3></p><p>算法可以用多种符号表示，包括自然语言、伪代码、流程图、drakon图表、编程语言或控制表(由解释器处理)。算法的自然语言表达往往冗长而模糊，很少用于复杂或技术性的算法。伪代码、流程图、drakon图表和控制表是表达算法的结构化方式，避免了自然语言语句中常见的许多歧义。编程语言主要用于以计算机可以执行的形式表达算法，但通常被用作定义或记录算法的一种方式。</p><p>有很多种可能的表示，可以将一个给定的图灵机程序表示为一系列的机器表(见有限状态机、状态转换表和控制表)，流程图和drakon图(见状态图)，或者表示为一种称为“四元组”的基本机器代码或汇编代码(见图灵机)。</p><p>算法的表示可以分为图灵机描述的三个公认的层次:<sup><a href=\"#quote_28\" class=\"kx_ref\">[28]</a></sup> </p><p>\n <dl>\n  <dt>\n   1高级描述\n  </dt>\n  <dd>\n   \"...散文来描述算法，忽略实现细节。在这个级别上，我们不需要提及机器是如何管理其磁带或磁头的。”\n  </dd>\n  <dt>\n   2实施说明\n  </dt>\n  <dd>\n   \"...散文用来定义图灵机使用磁头的方式和在磁带上存储数据的方式。在这个层次上，我们不给出状态或转换函数的细节。”\n  </dd>\n  <dt>\n   3 形式化描述\n  </dt>\n  <dd>\n   最详细的“最低级别”给出了图灵机的“状态表”。 有关在所有三个级别中描述的简单算法“添加m+n”的示例，请参见算法#示例。\n  </dd>\n </dl></p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099532394758","title":"设计","versionId":"53964833581752074","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>算法设计是指解决问题和工程算法的方法或数学过程。算法设计是运筹学中许多求解理论的一部分，如动态规划和分治法。设计和实现算法设计的技术也被称为算法设计模式，<sup><a href=\"#quote_29\" class=\"kx_ref\">[29]</a></sup> 例如模板方法模式和装饰模式。</p><p>算法设计的一个最重要的方面是创建一个具有高效运行时间的算法，也称为“大 O”</p><p>算法开发的典型步骤:</p><p>1.问题定义</p><p>2.模型的开发</p><p>3.算法说明</p><p>4.设计算法</p><p>5.检查算法的正确性</p><p>6.算法分析</p><p>7.算法的实现</p><p>8.程序测试</p><p>9.文件准备</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099532394759","title":"履行","versionId":"53964833581752075","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"246\" img_width=\"300\" titlename=\"Logical NAND algorithm implemented electronically in 7400 chip\" data-src=\"https://img03.sogoucdn.com/app/a/200698/sogou_science_4717\"> </p><p>实现大多数算法都是以计算机程序的形式实现的。然而，算法也可以通过其他方式实现，例如在生物神经网络(例如，人类大脑实现算法或昆虫寻找食物)、电路或机械设备中。</p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_4717?w=300&h=246&titlename=Logical%20NAND%20algorithm%20implemented%20electronically%20in%207400%20chip","url":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_4717","rw":300,"rh":246,"title":"Logical NAND algorithm implemented electronically in 7400 chip","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099532394760","title":"计算机算法","versionId":"53964833581752076","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"319\" img_width=\"176\" titlename=\"Flowchart examples of the canonical Böhm-Jacopini structures: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (IF test=true THEN GOTO step xxx) (a diamond), the unconditional GOTO (rectangle), various assignment operators (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100, 114).\" data-src=\"https://img04.sogoucdn.com/app/a/200698/sogou_science_136\"> </p><p>在计算机系统中，算法基本上是软件开发人员用软件编写的逻辑实例， 使预定的“目标”计算机能够有效地从给定(可能为空)输入生成输出。一个最优算法，即使在旧硬件中运行，也会比在更高效的硬件中运行的非最优(时间复杂度更高)算法产生更快的结果；这就是为什么算法，像计算机硬件一样 ，被认为是技术的原因 。</p><p>“优雅”(紧凑)程序，“良好”(快速)程序:“简单和优雅”的概念非正式地产生 于 Knuth， 准确的产生于Chaitin:</p><p>Knuth:\"...我们想要一些定义松散的美学意义上的好算法。一个标准...执行算法所花费的时间长度....其他标准是算法对计算机的适应性、简单性和优雅性等”<sup><a href=\"#quote_30\" class=\"kx_ref\">[30]</a></sup> </p><p>\n </p><dl>\n  <dd>\n   Chaitin: \"...一个程序是“优雅的”，我的意思是它是产生输出的最小可能的程序&nbsp; 。” &nbsp;<sup><a href=\"#quote_31\" class=\"kx_ref\">[31]</a></sup> \n  </dd>\n </dl><p></p><p>Chaitin在他的定义前写道:“我会证明你不能证明一个程序是‘优雅的’”——这样的证明可以解决&nbsp; 停机问题(同上)。</p><p>算法与可由算法计算的函数:对于给定的函数，可能存在多种算法。这是真的，即使没有扩展程序员可用的指令集。 Rogers观察到“是的...区分算法概念(即过程)和可由算法计算的函数概念(即过程产生的映射)很重要。同一函数可能有几种不同的算法”。<sup><a href=\"#quote_32\" class=\"kx_ref\">[32]</a></sup> </p><p>不幸的是，在好(速度)和优雅(紧凑)之间可能会有一个折衷——一个优雅的程序可能比一个不那么优雅的程序需要更多的步骤来完成一个计算。下面是一个使用欧几里德算法的例子。</p><p>计算机 ，计算模型:计算机(或人类“计算机”<sup><a href=\"#quote_33\" class=\"kx_ref\">[33]</a></sup>)是一种受限制的机器，一种盲目遵循指令的“离散确定性机械装置”<sup><a href=\"#quote_34\" class=\"kx_ref\">[34]</a></sup> <sup><a href=\"#quote_35\" class=\"kx_ref\">[35]</a></sup> Melzak和 Lambek的原始模型<sup><a href=\"#quote_36\" class=\"kx_ref\">[36]</a></sup> 将这一概念简化为四个要素:(1)离散的、可区分的位置，(2)离散的、不可区分的计数器<sup><a href=\"#quote_37\" class=\"kx_ref\">[37]</a></sup> (3)代理，以及(4)相对于代理能力有效的指令列表。<sup><a href=\"#quote_38\" class=\"kx_ref\">[38]</a></sup> </p><p>Minsky在他的《可计算性的非常简单的基础》中描述了 Lambek的“算盘”模型的一个更相似的变体。<sup><a href=\"#quote_39\" class=\"kx_ref\">[39]</a></sup> Minsky的机器通过它的五条(或六条，取决于如何计数)指令按顺序运行，除非有条件的“ IF–THEN GOTO”或无条件的“ GOTO”改变了程序的顺序。除了 停止， Minsky的机器还包括三个赋值(替换， 置换)<sup><a href=\"#quote_40\" class=\"kx_ref\">[40]</a></sup> 操作:零(例如位置内容被0: L←0替换)、后继(例如 L← L+1)和递减(例如 L ← L − 1)。<sup><a href=\"#quote_41\" class=\"kx_ref\">[41]</a></sup> 程序员很少用如此有限的指令集编写“代码”。但是 Minsky (像 Melzak和Lambek一样)表明，他的机器是只包括 四种通用类型的指令的图灵机:条件GOTO、无条件GOTO、赋值/替换/替换和 停止。然而，为了 图灵机完整性，还需要一些不同的赋值指令(例如， Minsky机器的减量、增量和零/清除/空指令)；他们的具体规格多少取决于 设计者。无条件的GOTO是一种便利；它可以通过将专用位置初始化为零来构建，例如指令“Z←0”；此后，指令如果Z=0，那么转到xxx是无条件的。</p><p>算法模拟:计算机 语言:Knuth建议读者，“学习算法的最好方法是尝试一下 ……立即拿起笔和纸，举一个例子”。<sup><a href=\"#quote_42\" class=\"kx_ref\">[42]</a></sup> 但是真实事物的模拟或执行呢？程序员必须将算法翻译成模拟器/计算机 能够有效执行的语言。 Stone举了一个例子:当计算二次方程的根时，计算机必须知道如何求平方根。如果没有，那么算法要想有效，就必须提供一套提取平方根的规则。<sup><a href=\"#quote_43\" class=\"kx_ref\">[43]</a></sup> </p><p>这意味着程序员必须知道一种相对于目标计算代理(计算机 )有效的“语言”。</p><p>但是模拟应该使用什么模型呢？ Van Emde Boas观察到，“即使我们把复杂性理论建立在抽象而不是具体的机器上，模型选择的任意性仍然存在。正是在这一点上，模拟的概念出现了”。<sup><a href=\"#quote_44\" class=\"kx_ref\">[44]</a></sup> 当测量速度时，指令集很重要。例如，欧几里德算法中计算余数的子程序，如果程序员有一条“模数”指令可用，而不仅仅是减法(或者更糟的是，只有 Minsky的“减量”)，执行起来会快得多。</p><p>结构化编程，规范结构:根据 Church–Turing理论，任何算法都可以通过已知的图灵完全模型来计算，根据 Minsky的演示，图灵 完备只需要四种指令类型——条件GOTO，无条件GOTO，赋值， 停止。Kemeny和Kurtz观察到，虽然无条件GOTOs和有条件IF-THEN GOTOs的“无纪律”使用会导致“意大利面代码”，但程序员可以只使用这些指令编写结构化程序；另一方面，“用结构化语言编写结构不良的程序也是可能的，而且不会太难”。<sup><a href=\"#quote_45\" class=\"kx_ref\">[45]</a></sup> Tausworthe增加了三个Böhm-Jacopini规范 结构:<sup><a href=\"#quote_46\" class=\"kx_ref\">[46]</a></sup> 序列， IF-THEN-ELSE，和 WHILE-DO，还有两个: DO-WHILE和案例。<sup><a href=\"#quote_47\" class=\"kx_ref\">[47]</a></sup> 结构化程序的另一个好处是它有助于用数学归纳法证明正确性。<sup><a href=\"#quote_48\" class=\"kx_ref\">[48]</a></sup> </p><p><i>标准流程图符号<sup><a href=\"#quote_49\" class=\"kx_ref\">[49]</a></sup></i>:称为流程图的图形助手，提供了一种描述和记录算法(和一个计算机程序)的方法。就像 Minsky机器的程序流程一样，流程图总是从页面的顶部开始向下进行。它的主要符号只有四个:显示程序流的有向箭头、矩形(序列、 GOTO)、菱形( IF-THEN-ELSE)和点( OR-tie)。 Böhm–Jacopini规范结构是由这些原始形状组成的。子结构可以“嵌套”在矩形中，但前提是上部结构只有一个出口。图中显示了这些符号及其用于构建规范结构的用途。</p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_136?w=176&h=319&titlename=Flowchart%20examples%20of%20the%20canonical%20B%C3%B6hm-Jacopini%20structures:%20the%20SEQUENCE%20(rectangles%20descending%20the%20page),%20the%20WHILE-DO%20and%20the%20IF-THEN-ELSE.%20The%20three%20structures%20are%20made%20of%20the%20primitive%20conditional%20GOTO%20(IF%20test%3Dtrue%20THEN%20GOTO%20step%20xxx)%20(a%20diamond),%20the%20unconditional%20GOTO%20(rectangle),%20various%20assignment%20operators%20(rectangle),%20and%20HALT%20(rectangle).%20Nesting%20of%20these%20structures%20inside%20assignment-blocks%20result%20in%20complex%20diagrams%20(cf%20Tausworthe%201977:100,%20114).","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_136","rw":176,"rh":319,"title":"Flowchart examples of the canonical Böhm-Jacopini structures: the SEQUENCE (rectangles descending the page), the WHILE-DO and the IF-THEN-ELSE. The three structures are made of the primitive conditional GOTO (IF test=true THEN GOTO step xxx) (a diamond), the unconditional GOTO (rectangle), various assignment operators (rectangle), and HALT (rectangle). Nesting of these structures inside assignment-blocks result in complex diagrams (cf Tausworthe 1977:100, 114).","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099532394761","title":"例子","versionId":"53964833581752077","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p></p><h3>算法示例</h3><p></p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"214\" img_width=\"280\" titlename=\"An animation of the quicksort algorithm sorting an array of randomized values. The red bars mark the pivot element; at the start of the animation, the element farthest to the right-hand side is chosen as the pivot.\" data-src=\"https://img02.sogoucdn.com/app/a/200698/sogou_science_4718\"> </p><p>最简单的算法之一是在随机顺序的数字列表中找到最大的数字。找到解决方案需要查看列表中的每个数字。由此可以得出一个简单的算法，可以用英语散文的高级描述来表述:</p><p><i>高级描述:</i> </p><p>\n </p><ol>\n  <li>如果集合中没有数字，那么就没有最高的数字。</li>\n  <li>假设集合中的第一个数字是集合中最大的数字。</li>\n  <li>对于集合中的每个剩余数:如果该数大于当前最大数，则认为该数是集合中的最大数。</li>\n  <li>当集合中没有剩余要迭代的数时，将当前最大的数视为集合中最大的数。</li>\n </ol><p></p><p><i>(准)形式描述:</i> 以下是更正式的伪代码语句编码或洋泾浜编码:</p><p></p><pre class=\"kx_code\"><b>Algorithm</b> LargestNumber\n  输入:数字列表 <i>L²</i>。\n  输出:列表中最大的数字 <i>L²</i>。</pre><p></p><p></p><pre class=\"kx_code\">  如果 <i>l .尺寸</i> = 0返回null  <i>最大的</i> ⅲ <i>L²</i>[0]\n  对于每一个 <i>项目</i> 在 <i>L²</i>，做\n    如果 <i>项目</i> &gt; <i>最大的</i>那么      <i>最大的</i> ⅲ <i>项目</i>\n  返回 <i>最大的</i></pre><p></p><p>\n </p><ul>\n  <li>\"←\" denotes assignment. For instance, \"<i>largest</i> ← <i>item</i>\" means that the value of <i>largest</i> changes to the value of <i>item</i>.</li>\n  <li>\"<b>return</b>\" terminates the algorithm and outputs the following value.</li>\n </ul><p></p><p></p><h3>欧几里得算法</h3><p></p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"263\" img_width=\"250\" titlename=\"The example-diagram of Euclid's algorithm from T.L. Heath (1908), with more detail added. Euclid does not go beyond a third measuring and gives no numerical examples. Nicomachus gives the example of 49 and 21: &quot;I subtract the less from the greater; 28 is left; then again I subtract from this the same 21 (for this is possible); 7 is left; I subtract this from 21, 14 is left; from which I again subtract 7 (for this is possible); 7 is left, but 7 cannot be subtracted from 7.&quot; Heath comments that &quot;The last phrase is curious, but the meaning of it is obvious enough, as also the meaning of the phrase about ending 'at one and the same number'.&quot;(Heath 1908:300).\" data-src=\"https://img04.sogoucdn.com/app/a/200698/sogou_science_134\"> </p><p>欧几里得计算两个数的最大公约数算法在他的第七卷《初等数论》中作为命题二出现 <i>元素</i>。<sup><a href=\"#quote_50\" class=\"kx_ref\">[50]</a></sup> 欧几里得这样提出了这个问题:“给定两个互不质数，找到它们最大的公共测度”。他将“[数”定义为]由单位组成的群体:计数数，不包括零的正整数。“测量”是放置较短的测量长度 <i>s</i> 连续(<i>q</i> 时间)沿着更长的长度 <i>l</i> 直到剩余部分 <i>r</i> 小于较短的长度 <i>s</i>。<sup><a href=\"#quote_51\" class=\"kx_ref\">[51]</a></sup> 用现代话说，余数 <i>r</i> = <i>l</i> − <i>q</i>×<i>s</i>, <i>q</i> 是商，或余数 <i>r</i> 是“模数”，除法之后剩下的整数分数部分。<sup><a href=\"#quote_52\" class=\"kx_ref\">[52]</a></sup> </p><p>欧几里得方法要成功，起始长度必须满足两个要求:(1)长度不能为零，(2)减法必须“正确”；也就是说，一个测试必须保证两个数字中较小的那个被从较大的那个中减去(或者，两个可以相等，所以它们的相减得到零)。</p><p>欧几里得的原始证明增加了第三个要求:两个长度不能互相质数。欧几里得这样规定是为了构造一个归谬反证法证明，证明两个数的共同测度实际上是 <i>最好的</i>。<sup><a href=\"#quote_53\" class=\"kx_ref\">[53]</a></sup> 虽然尼科马库斯算法与欧几里得算法相同，但当这些数互为质数时，它们的公共测度会得到数“1”。所以，准确地说，下面是真正的尼科马库斯算法。</p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"210\" img_width=\"350\" titlename=\"A graphical expression of Euclid's algorithm to find the greatest common divisor for 1599 and 650.  1599 = 650×2 + 299\n 650 = 299×2 + 52\n 299 = 52×5 + 39\n 52 = 39×1 + 13\n 39 = 13×3 + 0\" data-src=\"https://img03.sogoucdn.com/app/a/200698/sogou_science_138\"> </p><p><strong>欧几里得算法的计算机语言</strong></p><p>只有几条指令 <i>类型</i> 需要执行欧几里得算法——一些逻辑测试(条件GOTO)、无条件GOTO、赋值(替换)和减法。</p><p>\n </p><ul>\n  <li>A <i>位置</i> 用大写字母表示，如S、A等。</li>\n  <li>位置中的变化量(数字)用小写字母书写，并且(通常)与位置名称相关联。例如，起始位置L可能包含数字 <i>l</i> = 3009。</li>\n </ul><p></p><p><strong>欧几里得算法的一个不雅程序</strong></p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"349\" img_width=\"163\" titlename=\"&quot;Inelegant&quot; is a translation of Knuth's version of the algorithm with a subtraction-based remainder-loop replacing his use of division (or a &quot;modulus&quot; instruction). Derived from Knuth 1973:2–4. Depending on the two numbers &quot;Inelegant&quot; may compute the g.c.d. in fewer steps than &quot;Elegant&quot;.\" data-src=\"https://img02.sogoucdn.com/app/a/200698/sogou_science_135\"> </p><p>下面的算法被构造成克努特的欧几里得和尼科马库斯的四步版本，但是它没有使用除法来寻找余数，而是使用较短长度的连续减法 <i>s</i> 从剩余长度 <i>r</i> 直到 <i>r</i> 小于 <i>s</i>。粗体显示的高级描述改编自克努特1973:2–4:</p><p>输入:</p><p></p><pre class=\"kx_code\">1 [分成两个位置，L和S把数字 <i>l</i> 和 <i>s</i> 代表两个长度]:\n  输入L，S\n2 [初始化R:剩下的长度 <i>r</i> 等于起始/初始/输入长度 <i>l</i>]:\n  R ← L</pre><p></p><p>E0:[确保 <i>r</i> ≥ <i>s</i>。]</p><p></p><pre class=\"kx_code\">3 [确保两个数字中较小的在S中，较大的在R中]:\n  如果R &gt; S，则\n    L的内容是更大的数字，所以略过交换-步骤4，5和6:\n    转到步骤6\n  其他\n    交换R和s的内容。\n4   L ← R(第一步是多余的，但对后面的讨论很有用)。\n5   R ← S\n6   S ← L</pre><p></p><p>E1:[找到余数]:直到剩余长度 <i>r</i> 在R小于较短的长度 <i>s</i> 在S中，重复减去测量数 <i>s</i> 剩余长度的S <i>r</i> 在r区</p><p></p><pre class=\"kx_code\">7 如果S &gt; R，则\n    完成测量\n    GOTO 10\n  其他\n    再次测量，\n8   R←R-S\n9   [余数循环]:\n    GOTO 7。</pre><p></p><p>E2:[余数为零吗？]:要么(I)最后一个度量是精确的，R中的余数为零，程序可以停止，要么(ii)算法必须继续:最后一个度量在R中留下的余数小于s中的度量数。</p><p></p><pre class=\"kx_code\">10 如果R = 0，则\n     这样做\n     转到步骤15\n   其他\n     继续到步骤11，</pre><p></p><p>E3:[互通 <i>s</i> 和 <i>r</i>]:欧几里得算法的难点。使用余数 <i>r</i> 来测量以前较小的数字 <i>s</i>；我只是一个临时位置。</p><p></p><pre class=\"kx_code\">11  L ← R\n12  R ← S\n13  S ← L\n14  [重复测量过程]:\n    GOTO 7</pre><p></p><p>输出:</p><p></p><pre class=\"kx_code\">15 [完成。s包含最大公约数]:\n   打印</pre><p></p><p>完成:</p><p></p><pre class=\"kx_code\">16 停止，结束，停止。</pre><p></p><p><strong>欧几里得算法的优美程序</strong></p><p>The following version of Euclid's algorithm requires only six core instructions to do what thirteen are required to do by \"Inelegant\"; worse, \"Inelegant\" requires more <i>types</i> of instructions.<sup class=\"noprint Inline-Template\">[需要解释]</sup> “优雅”的流程图可以在本文的顶部找到。在(非结构化)基础语言中，步骤被编号，指令 <code class=\"mw-highlight\" dir=\"ltr\"><span>LET</span> <span>[]</span> <span>=</span> <span>[]</span></code> 是用←符号表示的赋值指令。</p><p></p><pre class=\"kx_code\"><code class=\"C\"> &nbsp;5 REM Euclid's algorithm for greatest common divisor\n &nbsp;6 PRINT \"Type two integers greater than 0\"\n &nbsp;10 INPUT A,B\n &nbsp;20 IF B=0 THEN GOTO 80\n &nbsp;30 IF A &gt; B THEN GOTO 60\n &nbsp;40 LET B=B-A\n &nbsp;50 GOTO 20\n &nbsp;60 LET A=A-B\n &nbsp;70 GOTO 20\n &nbsp;80 PRINT A\n &nbsp;90 END</code></pre><p></p><p><i>“优雅”是如何运作的</i>:代替外部的“欧几里得环”，“优雅”在两个“共环”之间来回移动，A &gt; B环计算A←A-B，B ≤ A环计算B←B-A。 <i>s</i> (新的测量长度)和减数可以成为新的 <i>r</i> (要测量的长度)；换句话说，减法的“意义”颠倒了。</p><p>以下版本可用于面向对象语言:</p><p></p><pre class=\"kx_code\"><code class=\"C\">// Euclid's algorithm for greatest common divisor\nint euclidAlgorithm (int A, int B){\n &nbsp; &nbsp; A=Math.abs(A);\n &nbsp; &nbsp; B=Math.abs(B);\n &nbsp; &nbsp; while (B!=0){\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (A&gt;B) A=A-B;\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else B=B-A;\n &nbsp; &nbsp; }\n &nbsp; &nbsp; return A;\n}</code></pre><p></p><p></p><h3>测试欧几里得算法</h3><p></p><p>一个算法做了作者希望它做的事情吗？一些测试用例通常会给核心功能带来一些信心。但是测试是不够的。对于测试用例，一个来源<sup><a href=\"#quote_54\" class=\"kx_ref\">[54]</a></sup> 使用3009和884。克努特建议40902，24140。另一个有趣的例子是两个互质数字14157和5950。</p><p>但是“例外情况”<sup><a href=\"#quote_55\" class=\"kx_ref\">[55]</a></sup> 必须被识别和测试。当R &gt; S，S &gt; R，R = S时，“不优雅”会正常运行吗？“优雅”也是如此:B &gt; A，A &gt; B，A = B？(对所有人都是)。当一个数为零，两个数都为零时会发生什么？(“不雅”在所有情况下永远计算；当A = 0时，“优雅”将永远计算。)如果 <i>否定</i> 输入了数字？分数？如果输入数字，即由算法/程序计算的函数的域，只包括包括零的正整数，那么零的故障表明算法(以及实例化它的程序)是一个部分函数而不是一个总函数。一个值得注意的例外是阿丽亚娜5号飞行501火箭故障(1996年6月4日)。</p><p><i>用数学归纳法证明程序的正确性</i>:Knuth演示了数学归纳法在欧几里得算法“扩展”版本中的应用，并提出了“一种适用于证明任何算法有效性的通用方法”。<sup><a href=\"#quote_56\" class=\"kx_ref\">[56]</a></sup> 陶斯沃特提出，一个程序复杂性的度量标准是其正确性证明的长度。<sup><a href=\"#quote_57\" class=\"kx_ref\">[57]</a></sup> </p><p></p><h3>欧几里得算法的度量和改进</h3><p></p><p><i>优雅(紧凑)与善良(速度)</i>:只有六个核心指令，“优雅”是明显的赢家，相比之下，“不雅”是十三个指令。然而，“不雅”是 <i>更快的</i> (它以更少的步骤到达HALT)。算法分析<sup><a href=\"#quote_58\" class=\"kx_ref\">[58]</a></sup> 指出为什么会是这种情况:“优雅”确实如此 <i>二</i> 每个减法循环中的条件测试，而“不合格”只做一个。由于算法(通常)需要多次循环， <i>平均</i> 做“B = 0”会浪费很多时间仅在计算完余数后才需要的测试。</p><p><i>算法可以改进吗？</i>:一旦程序员判断一个程序“合适”和“有效”——也就是说，它计算出作者想要的函数——那么问题就变成了，它能被改进吗？</p><p>“不雅”的紧凑性可以通过消除五个步骤来提高。但是柴丁证明了压缩算法不能由广义算法自动完成；<sup><a href=\"#quote_59\" class=\"kx_ref\">[59]</a></sup> 相反，它只能启发式地完成；即通过详尽的搜索(例如在《忙碌的海狸》中找到的例子)、反复试验、聪明、洞察力、归纳推理的应用等。观察步骤4、5和6在步骤11、12和13中重复。与“优雅”的比较暗示了这些步骤以及步骤2和3可以被取消。这将核心指令的数量从十三个减少到八个，这使得它在九个步骤中比“优雅”更“优雅”。</p><p>移动“B=0”可以提高“优雅”的速度在两个减法循环之外进行测试。这种变化需要增加三条指令(B = 0？，A = 0？，GOTO)。现在“优雅”计算示例数的速度更快；对于任何给定的A、B和R、S是否总是这种情况，需要详细的分析。</p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_4718?w=280&h=214&titlename=An%20animation%20of%20the%20quicksort%20algorithm%20sorting%20an%20array%20of%20randomized%20values.%20The%20red%20bars%20mark%20the%20pivot%20element;%20at%20the%20start%20of%20the%20animation,%20the%20element%20farthest%20to%20the%20right-hand%20side%20is%20chosen%20as%20the%20pivot.","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_4718","rw":280,"rh":214,"title":"An animation of the quicksort algorithm sorting an array of randomized values. The red bars mark the pivot element; at the start of the animation, the element farthest to the right-hand side is chosen as the pivot.","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_134?w=250&h=263&titlename=The%20example-diagram%20of%20Euclid's%20algorithm%20from%20T.L.%20Heath%20(1908),%20with%20more%20detail%20added.%20Euclid%20does%20not%20go%20beyond%20a%20third%20measuring%20and%20gives%20no%20numerical%20examples.%20Nicomachus%20gives%20the%20example%20of%2049%20and%2021:%20%22I%20subtract%20the%20less%20from%20the%20greater;%2028%20is%20left;%20then%20again%20I%20subtract%20from%20this%20the%20same%2021%20(for%20this%20is%20possible);%207%20is%20left;%20I%20subtract%20this%20from%2021,%2014%20is%20left;%20from%20which%20I%20again%20subtract%207%20(for%20this%20is%20possible);%207%20is%20left,%20but%207%20cannot%20be%20subtracted%20from%207.%22%20Heath%20comments%20that%20%22The%20last%20phrase%20is%20curious,%20but%20the%20meaning%20of%20it%20is%20obvious%20enough,%20as%20also%20the%20meaning%20of%20the%20phrase%20about%20ending%20'at%20one%20and%20the%20same%20number'.%22(Heath%201908:300).","url":"https://web.archive.org/web/20221025113656/https://img04.sogoucdn.com/app/a/200698/sogou_science_134","rw":250,"rh":263,"title":"The example-diagram of Euclid's algorithm from T.L. Heath (1908), with more detail added. Euclid does not go beyond a third measuring and gives no numerical examples. Nicomachus gives the example of 49 and 21: \"I subtract the less from the greater; 28 is left; then again I subtract from this the same 21 (for this is possible); 7 is left; I subtract this from 21, 14 is left; from which I again subtract 7 (for this is possible); 7 is left, but 7 cannot be subtracted from 7.\" Heath comments that \"The last phrase is curious, but the meaning of it is obvious enough, as also the meaning of the phrase about ending 'at one and the same number'.\"(Heath 1908:300).","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_138?w=350&h=210&titlename=A%20graphical%20expression%20of%20Euclid's%20algorithm%20to%20find%20the%20greatest%20common%20divisor%20for%201599%20and%20650.%20%201599%20%3D%20650%C3%972%20%2B%20299%0A%20650%20%3D%20299%C3%972%20%2B%2052%0A%20299%20%3D%2052%C3%975%20%2B%2039%0A%2052%20%3D%2039%C3%971%20%2B%2013%0A%2039%20%3D%2013%C3%973%20%2B%200","url":"https://web.archive.org/web/20221025113656/https://img03.sogoucdn.com/app/a/200698/sogou_science_138","rw":350,"rh":210,"title":"A graphical expression of Euclid's algorithm to find the greatest common divisor for 1599 and 650.  1599 = 650×2 + 299\n 650 = 299×2 + 52\n 299 = 52×5 + 39\n 52 = 39×1 + 13\n 39 = 13×3 + 0","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_135?titlename=%22Inelegant%22%20is%20a%20translation%20of%20Knuth's%20version%20of%20the%20algorithm%20with%20a%20subtraction-based%20remainder-loop%20replacing%20his%20use%20of%20division%20(or%20a%20%22modulus%22%20instruction).%20Derived%20from%20Knuth%201973:2%E2%80%934.%20Depending%20on%20the%20two%20numbers%20%22Inelegant%22%20may%20compute%20the%20g.c.d.%20in%20fewer%20steps%20than%20%22Elegant%22.&w=163&h=349","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_135","rw":163,"rh":349,"title":"\"Inelegant\" is a translation of Knuth's version of the algorithm with a subtraction-based remainder-loop replacing his use of division (or a \"modulus\" instruction). Derived from Knuth 1973:2–4. Depending on the two numbers \"Inelegant\" may compute the g.c.d. in fewer steps than \"Elegant\".","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099549171979","title":"算法分析","versionId":"53964833581752078","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>知道给定算法理论上需要多少特定资源(例如时间或存储)通常很重要。已经开发了用于分析算法以获得这种定量答案(估计)的方法；例如，上面的排序算法有一个时间要求为 O(n)，使用大 O符号，n作为列表的长度。在任何时候，算法只需要记住两个值:迄今为止找到的最大数字，以及它在输入列表中的当前位置。因此，如果不计算存储输入数字所需的空间，则称其空间要求为 O(1)，如果计算了，则称其为O (n)。</p><p>与其他算法相比，不同的算法可以用不同的指令集在更少或更多的时间、空间或“努力程度 ”内完成相同的任务。例如，当用于排序列表或数组上的表查找时，二进制搜索算法( 时间复杂度为 O(log n))优于顺序搜索( 时间复杂度为O (n))。</p><p><h3>形式化方法 与 经验方法</h3></p><p>算法的分析和研究是计算机科学的一门学科，通常在不使用特定编程语言或实现的情况下进行抽象实践。在这个意义上，算法分析类似于其他数学学科，因为它关注算法的基本属性，而不是任何特定实现的细节。伪代码通常用于分析，因为它是最简单和最通用的表示。然而，最终，大多数算法通常在特定的硬件/软件平台上实现，并且它们的算法效率最终使用真实代码进行测试。对于“一次性”问题的解决，特定算法的效率可能不会产生重大影响(除非n非常大)，但对于为快速交互、商业或长寿命科学应用而设计的算法来说，这可能是至关重要的。从小n到大n的缩放经常暴露出 效率低下的算法，而这些算法在其他方面是优良的。</p><p>经验测试很有用，因为它可能会发现影响性能的意外交互。基准可以用来比较程序优化后算法的潜在改进前后效率提高 。然而，经验测试不能取代形式分析，以 直接的方式进行也不是小事。<sup><a href=\"#quote_60\" class=\"kx_ref\">[60]</a></sup> </p><p><h3>执行效率</h3></p><p>为了说明即使在成熟的算法中也可能有潜在的改进，与快速傅立叶变换算法(在图像处理领域中大量使用)相关的最近一项重大创新可以将医学成像等应用的处理时间减少 高达1000倍。<sup><a href=\"#quote_61\" class=\"kx_ref\">[61]</a></sup> 一般来说，速度的提高取决于问题的特殊性质，这在实际应用中非常常见。<sup><a href=\"#quote_62\" class=\"kx_ref\">[62]</a></sup> 如此大规模的加速使得 大量使用图像处理的计算设备(如数码相机和医疗设备)消耗更少的能量。</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099549171980","title":"分类","versionId":"53964833581752079","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>有多种方法对算法进行分类，每种方法都有自己的优点。</p><p><h3>通过实现方法</h3></p><p>算法分类的一种方法是通过实现方式。</p><p>\n <table>\n  <tbody>\n   <tr>\n    <td><pre class=\"kx_code\"><code class=\"C\">int gcd(int A, int B) {\n &nbsp; &nbsp;if (B == 0)\n &nbsp; &nbsp; &nbsp; &nbsp;return A;\n &nbsp; &nbsp;else if (A &gt; B)\n &nbsp; &nbsp; &nbsp; &nbsp;return gcd(A-B,B);\n &nbsp; &nbsp;else\n &nbsp; &nbsp; &nbsp; &nbsp;return gcd(A,B-A);\n}</code></pre></td>\n   </tr>\n   <tr>\n    <td>Recursive C implementation of Euclid's algorithm from the above flowchart</td>\n   </tr>\n  </tbody>\n </table></p><p>\n <dl>\n  <dt>\n   递归\n  </dt>\n  <dd>\n   递归算法是一种反复调用(引用)自身，直到某个条件(也称为终止条件)匹配的算法，这是函数编程的常用方法。迭代算法使用循环这样的重复结构，有时使用堆栈这样的附加数据结构来解决给定的问题。有些问题自然适用于这种或那种实现。例如，河内的塔使用递归实现是很好理解的。每个递归版本都有一个等价的(但可能或多或少复杂)迭代版本，反之亦然。\n  </dd>\n  <dt>\n   逻辑学的\n  </dt>\n  <dd>\n   算法可以被视为受控逻辑演绎。这个概念可以表达为:算法=逻辑+控制。 &nbsp;<sup><a href=\"#quote_63\" class=\"kx_ref\">[63]</a></sup> 逻辑组件表示可以在计算中使用的公理，而控制组件决定演绎应用于公理的方式。这是逻辑编程范例的基础。在纯逻辑编程语言中，控制组件是固定的，算法是通过只提供逻辑组件来指定的。这种方法的吸引力在于优雅的语义:公理的改变会导致算法中定义明确的改变。\n  </dd>\n  <dt>\n   串行、并行或分布式\n  </dt>\n  <dd>\n   算法的讨论通常假设计算机一次执行一条算法指令。那些计算机有时被称为串行计算机。为这种环境设计的算法称为串行算法，而不是并行算法或分布式算法。并行算法利用计算机体系结构，其中 多个处理器可以同时处理一个问题，而分布式算法利用与计算机网络相连的多台机器。并行或分布式算法将问题分成更对称或不对称的子问题，并将结果收集在一起。这种算法中的资源消耗不仅是每个处理器上的处理器周期，而且是处理器之间的通信开销。一些排序算法可以有效地并行化，但是它们的通信开销很 大。迭代算法通常是可并行化的。有些问题没有并行算法，被称为固有串行问题。\n  </dd>\n  <dt>\n   确定性或非确定性\n  </dt>\n  <dd>\n   确定性算法在算法的每一步都通过精确的决策来解决问题，而非确定性算法通过猜测来解决问题，尽管通过使用试探法可以使典型的猜测更加准确。\n  </dd>\n  <dt>\n   精确或近似\n  </dt>\n  <dd>\n   虽然许多算法都 能得到精确的解，但近似算法寻求更接近真实解的 近似解。 近似解可以通过使用确定性策略 或随机策略来达到。这种算法对许多难题都有实用价值。近似算法的一个例子是背包问题，其中有一组给定的项目。它的目标是打包背包以获得最大的总价值。每件物品都有一定的重量和价值。可以携带的总重量不超过某个固定的数字X 。因此，解决方案必须考虑物品的重量及其价值。 &nbsp;<sup><a href=\"#quote_64\" class=\"kx_ref\">[64]</a></sup> \n  </dd>\n  <dt>\n   量子算法\n  </dt>\n  <dd>\n   他们在量子计算的现实模型上运行。该术语通常用于那些看起来本质上是量子的算法，或者使用量子计算的一些基本特征，如量子叠加或量子纠缠。\n  </dd>\n </dl></p><p><h3>通过设计 范例</h3></p><p>算法分类的另一种方法是通过它们的设计方法或范例。有一定数量的范例，每一个都不同。此外，这些类别中的每一个都包括许多不同类型的算法。一些常见的范例是:</p><p>\n <dl>\n  <dt>\n   暴力或彻底搜索\n  </dt>\n  <dd>\n   暴力搜索或穷举搜索这是一种 比较初级的方法，尝试每一种可能的解决方案，看看哪个是最好的。 &nbsp;<sup><a href=\"#quote_65\" class=\"kx_ref\">[65]</a></sup> \n  </dd>\n  <dt>\n   分而治之方法\n  </dt>\n  <dd>\n   分治法分治算法反复地将一个问题的实例简化为同一问题的一个或多个较小的实例(通常递归地)，直到这些实例小到足以容易地解决。分治的一个例子是 归并排序。在将数据划分成段之后，可以对每段数据进行排序，并且可以在 攻克阶段通过合并段来获得整个数据的排序。分治法的一个更简单的变体叫做 递减和 攻克算法，它解决一个相同的子问题，并使用这个子问题的解来解决更大的问题。 分治法将问题分成多个子问题，因此 攻克阶段比递减和攻克 算法更复杂。 递减和攻克算法的一个例子是 二分查找算法。\n  </dd>\n  <dt>\n   搜索和枚举\n  </dt>\n  <dd>\n   许多问题(例如下棋)可以被建模为图形上的问题。图探索算法指定了在图中移动的规则，并对这类问题很有用。该类别还包括搜索算法、分支和绑定枚举以及回溯。\n  </dd>\n  <dt>\n   随机算法\n  </dt>\n  <dd></dd>\n  <dd>\n   这种算法随机(或伪随机)做出一些选择。它们在寻找问题的近似解时非常有用，因为在这些问题中，寻找精确的解是不切实际的(见下面的启发式方法)。对于其中一些问题，众所周知，最快的近似必须包含一些随机性。[66]对于某些问题，多项式时间复杂度的随机算法是否是最快的算法， 是一个被称为P对NP问题的开放性问题。这种算法有两大类: 蒙特卡罗算法以高概率返回正确答案。例如， RP是在多项式时间内运行的子类。 拉斯维加斯算法 总是返回正确的答案，但是它们的运行时间只有概率界限，例如ZPP。\n  </dd>\n </dl></p><p>\n <dl>\n  <dt>\n   降低复杂性\n  </dt>\n  <dd>\n   这项技术涉及到通过将一个难题转化为一个更广为人知的问题来解决这个难题，对此我们有( 充满希望的)渐近最优算法 。目标是找到一种简化算法，其复杂性不受最终简化算法的支配。例如，一种用于寻找未排序列表中的中间值的选择算法包括首先对列表进行排序( 代价较高的部分)，然后拉出排序列表中的中间元素( 代价较低的部分)。这种技术也被称为转换和 攻克。\n  </dd>\n  <dt>\n   回溯法\n  </dt>\n  <dd>\n   在这种方法中， 多个解决方案是增量构建的，当确定它们不能生成有效的解决方案时，这些方案就会被放弃。\n  </dd>\n </dl></p><p><h3>优化问题</h3></p><p>对于优化问题，有更具体的算法分类；这种问题的算法可以属于上述一个或多个一般类别，也可以属于以下类别之一:</p><p>\n <dl>\n  <dt>\n   线性规划\n  </dt>\n  <dd>\n   当搜索线性等式和不等式约束的线性函数的最优解时，问题的约束可以直接用于产生最优解。有些算法可以解决这类问题，例如流行的单纯形算法。 &nbsp;<sup><a href=\"#quote_66\" class=\"kx_ref\">[66]</a></sup> 线性规划可以解决的问题包括有向图的最大流问题。如果一个问题还要求一个或多个未知数必须是整数，那么它就被归入整数规划。如果能够证明整数值的所有限制都是表面的，即无论如何解满足这些限制，线性规划算法可以解决这样的问题。在一般情况下，根据问题的难度，使用专门的算法或找到近似解的算法。\n  </dd>\n  <dt>\n   动态规划\n  </dt>\n  <dd>\n   当一个问题显示出最优子结构(意味着问题的最优解可以由子问题的最优解构造)和重叠的子问题(意味着相同的子问题用于解决许多不同的问题实例)时，称为动态规划的更快的方法避免了重新计算已经计算的解。例如，Floyd–Warshall算法 ， 通过使用从所有相邻顶点到目标的最短路径，可以找到加权图中顶点到目标的最短路径。动态编程和记忆 是相辅相成的。动态规划和分治法的主要区别在于子问题在分治法中或多或少是独立的，而子问题在动态规划中是重叠的。动态编程和直接递归的区别在于递归调用的缓存或记忆。当子问题是独立的并且没有重复时，记忆化没有帮助；因此，动态编程不是所有复杂问题的解决方案。通过使用记忆化或维护已经解决的子问题表，动态规划将许多问题的指数性质降低到多项式复杂性。\n  </dd>\n  <dt>\n   贪婪方法\n  </dt>\n  <dd>\n   贪心算法类似于动态规划算法，它通过检查子结构来工作，在这种情况下不是检查 问题而是检查 给定的解决方案。这种算法从一些解决方案开始，这些解决方案可能是以某种方式给出或构建的，并通过做一些小的修改来改进它。对于某些问题，他们可以找到最优解，而对于另一些问题，他们停留在局部最优，即算法不能改进了 但不是最优的解。 贪心算法最常用的用途是寻找最小生成树，在这种情况下，用这种方法可以找到最优解。 Huffman Tree, Kruskal, Prim, Sollin是 贪心算法，可以解决这个优化问题。\n  </dd>\n  <dt>\n   启发式方法\n  </dt>\n  <dd>\n   在优化问题中，在寻找最优解是 不现实的情况下，启发式算法可以用来寻找接近最优解的解。随着算法的 进行，它们越来越接近最优解。原则上，如果运行无限长的时间，他们会找到最佳的解决方案。他们的优点是可以在相对较短的时间内找到一个非常接近最优的解决方案。这些算法包括局部搜索、禁忌搜索、模拟退火和遗传算法。其中一些，像模拟退火，是非确定性算法，而其他的，像禁忌搜索，是确定性的。当已知非最优解的误差界限时，该算法被进一步归类为近似算法。\n  </dd>\n </dl></p><p><h3>按研究领域</h3></p><p>每个科学领域都有自己的问题，需要高效的算法。一个领域的相关问题经常一起研究。一些示例类是搜索算法、排序算法、 归并算法、数值算法、图形算法、字符串算法、计算几何算法、组合算法、医学算法、机器学习、密码学、数据压缩算法和解析技术。</p><p>领域往往相互重叠，一个 领域的算法进步可能会改善其他 领域的算法进步，有时这些 领域完全不相关。例如，动态规划是为了优化工业中的资源消耗而发明的，但现在被用于解决许多领域的 一大系列问题。</p><p><h3>按复杂性</h3></p><p>算法可以根据完成所需的时间和输入大小进行分类:</p><p>\n <ul>\n  <li>恒定时间:如果算法所需的时间相同，不管输入大小如何。例如对数组元素的访问。</li>\n  <li>线性时间:如果时间与输入大小成比例。例如遍历列表。</li>\n  <li>对数时间:如果时间是输入大小的对数函数。例如二进制搜索算法。</li>\n  <li>多项式时间:如果时间是输入大小的幂。例如， 冒泡排序法具有二次时间复杂度。</li>\n  <li>指数时间:如果时间是输入大小的指数函数。例如暴力搜索。</li>\n </ul></p><p>一些问题可能有不同复杂性的多种算法，而其他问题可能没有算法或没有已知的有效算法。也有从一些问题到其他问题的映射。因此， 结果表明，基于最优算法的复杂度，将问题本身分类，而不是将算法划分为等价类更合适。</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099549171981","title":"连续算法","versionId":"53964833581752080","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>形容词“连续”在应用于“算法”一词时可以表示:</p><p>\n <ul>\n  <li>对表示连续量的数据进行运算的算法，即使这些数据是用离散近似表示的——这种算法是在数值分析中研究的；</li>\n  <li>微分方程形式的一种算法，在模拟计算机上对数据连续运行。<sup><a href=\"#quote_67\" class=\"kx_ref\">[67]</a></sup></li>\n </ul></p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099549171982","title":"法律问题","versionId":"53964833581752081","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>算法本身通常不具备专利性。在美国，仅由抽象概念、数字或信号的简单操作组成的权利要求不构成“过程”(USPTO 2006)，因此算法不可申请专利(如 Gottschalk v. Benson案)。然而算法的实际应用有时是可以申请专利的。例如，在&nbsp; Diamond v. Diehr案中，应用简单的反馈算法来帮助合成橡胶固化被认为是可申请 专利的。软件专利极具争议性，而且有很多备受批评的专利涉及算法，尤其是数据压缩算法，如 Unisys的LZW专利。</p><p>此外，一些加密算法有导出限制(请参见加密导出)。</p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099549171983","title":"历史:“算法”概念的发展","versionId":"53964833581752082","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p></p><h3>古代近东</h3><p></p><p>算法在古希腊被使用。两个例子是 Eratosthenes的筛子，在[ Nicomachus的《算术导论》中有所描述，<sup><a href=\"#quote_68\" class=\"kx_ref\">[68]</a></sup><sup><a href=\"#quote_69\" class=\"kx_ref\">[69]</a></sup> 第9.2章，欧几里德算法，在欧几里德的《元素》(公元前300年)中首次有所描述。<sup><a href=\"#quote_69\" class=\"kx_ref\">[69]</a></sup> 巴比伦 泥板文书描述并使用算法程序来计算重大天文事件的时间和地点。<sup><a href=\"#quote_69\" class=\"kx_ref\">[69]</a></sup> </p><p></p><h3>离散和可区分的符号</h3><p></p><p>计数标记:为了记录他们的羊群，他们的粮食袋和他们的钱，古人使用计数法:积累石头或在棍子上划的标记，或者用粘土制作离散的符号。通过巴比伦人和埃及人 对标记和符号的使用，最终罗马数字和算盘得到了发展( Dilson，第16-41页)。计数标记在图灵机和后图灵机计算中使用的一元数字系统算法中表现突出。</p><p></p><h3>作为数字“占位符”的符号操作:代数</h3><p></p><p>古希腊几何学家(欧几里得算法)、印度数学家 Brahmagupta和波斯数学家 Al-Khwarizmi (术语“ 十进位计算法”和“算法”是从他 的名字中派生出来的)以及西欧数学家的工作使在莱布尼茨的微积分推理器概念(约1680年)中达到了顶峰&nbsp;:</p><p>早于他所处时代整整一个半世纪 ，莱布尼茨提出了一 种逻辑代数，这 种代数将像普通代数规定操纵数字的规则一样规定操纵逻辑概念的规则.<sup><a href=\"#quote_70\" class=\"kx_ref\">[70]</a></sup></p><p></p><h3>具有离散状态的机械装置</h3><p></p><p>时钟: Bolter将重量驱动时钟的发明&nbsp; 誉为“中世纪欧洲的关键发明”，特别是边缘擒纵机构<sup><a href=\"#quote_71\" class=\"kx_ref\">[71]</a></sup> 它为我们提供了机械钟的滴答声。“精确的自动机器”<sup><a href=\"#quote_72\" class=\"kx_ref\">[72]</a></sup> 从13世纪开始，立即 催生了“机械自动机”，最终 催生了“计算机器”——19世纪中期 Charles Babbage和 Ada Lovelace伯爵夫人的差分机和分析机 。<sup><a href=\"#quote_73\" class=\"kx_ref\">[73]</a></sup> Lovelace被认为是第一个设计用于计算机处理的算法的人—— Babbage的分析机 ， 被认为是第一个真正的图灵完整的计算机而不仅仅是计算器——因此Lovelace 有时被称为“历史上的第一个程序员”，尽管 Babbage的第二个设备的完整实现要等到她死后几十年才能实现。</p><p>逻辑机器1870年—— Stanley Jevons的“逻辑算盘”和“逻辑机器”:技术问题是当布尔方程以类似于现在被称为卡诺图的形式出现时，要简化布尔方程。 Jevons (1880)首先描述了一个简单的“算盘”，由“木条”组成，木条上有 指针，指针被 设计成可以机械地挑选出逻辑组合的任何部分或类别...然而，最近，我把系统简化为一种完全机械的形式，并因此把整个间接推理过程具体化为所谓的逻辑机器。他的机器配备了“某些可移动的木棒”和“脚下有21个键，像钢琴等的键一样……”。有了这台机器，他可以分析“三段论或任何其他简单的逻辑论证”。<sup><a href=\"#quote_74\" class=\"kx_ref\">[74]</a></sup> </p><p>1870年，他在皇家学会的研究员面前展示了这台机器。<sup><a href=\"#quote_75\" class=\"kx_ref\">[75]</a></sup> 然而，另一位逻辑学家 John Venn在他1881年的《符号逻辑》中对这一努力持偏见:“我对有时被称为逻辑机器的兴趣或重要性没有很高的 评价...在我看来，目前已知或可能被发现的任何发明都不值得被称为逻辑机器”； 到算法特性中查看更多。但他也不甘示弱，提出了“一个有点类似于 Jevon教授算盘的计划... 又一次，对应于 Jevons教授的逻辑机器，以下发明可以描述。我更喜欢称它为逻辑图机器...但我认为它可以完全做到任何逻辑机器合理预期的一切”。<sup><a href=\"#quote_76\" class=\"kx_ref\">[76]</a></sup> </p><p>提花织机、 Hollerith穿孔卡、电报和电话——机电继电器: Bell和 Newell (1971年)指出，提花织机(1801年)、 Hollerith卡的前身 (穿孔卡，1887年)和“电话交换技术”是导致第一批计算机发展的根源。<sup><a href=\"#quote_77\" class=\"kx_ref\">[77]</a></sup> 到19世纪中叶，电话的前身电报已经在全世界使用，它对字母的离散和可区分的编码是“点和破折号”，这是一种常见的声音。到了19世纪末，&nbsp; 自动收报机纸条(约19世纪70年代)开始使用，就像1890年美国人口普查中Hollerith 卡的使用一样。然后是电传打字机( 大约在1910年)，在 打孔纸上使用 Baudot码。</p><p>机电继电器的电话交换网络(发明于1835年)是以数字加法设备的发明者&nbsp; George Stibitz (1937年) 的工作为基础的。当他在贝尔实验室工作时，他观察到机械计算器和齿轮的“累赘”使用。“1937年的一个晚上，他回到家，打算验证他的想法...修补工作结束后， Stibitz建造了一个二进制加法装置”。<sup><a href=\"#quote_78\" class=\"kx_ref\">[78]</a></sup> </p><p>Davis (2000)观察到机电继电器的特殊重要性(其两个“二进制状态”打开和关闭):</p><p>\n </p><dl>\n  <dd>\n   直到从20世纪30年代开始，使用继电器的机电计算器得到发展，机器才被制造出 Babbage所设想的范围。“ &nbsp;<sup><a href=\"#quote_79\" class=\"kx_ref\">[79]</a></sup> \n  </dd>\n </dl><p></p><p></p><h3>从19世纪到20世纪中期的数学</h3><p></p><p>符号和规则:接连不断地， &nbsp; George Boole (1847，1854)、 Gottlob Frege (1879)和 Giuseppe Peano (1888-1889)的数学运算 将算术简化为由规则操纵的符号序列。 Peano的《算术原理》，由一种新方法(1888年)提出，是“用符号语言对数学进行公理化的第一次尝试”。<sup><a href=\"#quote_80\" class=\"kx_ref\">[80]</a></sup> </p><p>但是 Heijenoort给了Frege&nbsp; (1879)这样的 赞誉: Frege&nbsp; 的作品“也许是逻辑史上最重要的一部作品。...其中我们看到了一种“公式语言”，这是一种语言特征，一种用特殊符号写成的语言，“用于纯粹的思考”，也就是说，没有修辞修饰...由根据明确规则操纵的特定符号构成”。<sup><a href=\"#quote_81\" class=\"kx_ref\">[81]</a></sup>Frege 的工作被 Alfred North Whitehead和 Bertrand Russell在其《数学原理》(1910-1913)中进一步简化和 扩充。</p><p>悖论:与此同时，一些令人不安的悖论出现在 著作中，特别是 Burali-Forti悖论(1897)、 Russell悖论(1902-03)和 Richard悖论。<sup><a href=\"#quote_82\" class=\"kx_ref\">[82]</a></sup> 由此产生的考虑导致 Kurt Gödel的论文(1931年)——他特别引用了说谎者的悖论——将递归规则完全简化为数字。</p><p>有效计算能力:为了解决 Hilbert在1928年精确定义的判定问题 ，数学家们首先开始定义“有效方法”或“有效计算”或“有效计算能力”的含义(即，一个会成功的计算)。接下来，Alonzo Church、Stephen Kleene和J.B. Rosser 的λ演算<sup><a href=\"#quote_83\" class=\"kx_ref\">[83]</a></sup> 根据 Gödel的工作，按照 Jacques Herbrand的建议(参见 Gödel1934年的普林斯顿讲座)和 Kleene后来的简化，对“一般递归”进行了精细的定义。<sup><a href=\"#quote_84\" class=\"kx_ref\">[84]</a></sup> Church的证明是<sup><a href=\"#quote_85\" class=\"kx_ref\">[85]</a></sup> 判定问题 是不可解决的， Emil Post对有效计算能力的定义是，一个工人盲目地遵循一系列指令，在一系列房间里向左或向右移动，在那里或者标记或擦除一张纸，或者观察这张纸，然后对下一条指令做出是或否的决定。<sup><a href=\"#quote_86\" class=\"kx_ref\">[86]</a></sup> Alan Turing用他的“a-[自动-]机器<sup><a href=\"#quote_87\" class=\"kx_ref\">[87]</a></sup>证明判定 问题是无法解决的——实际上几乎与 Post的“公式”相同，J. Barkley Rosser用“机器”来定义“有效方法”。<sup><a href=\"#quote_88\" class=\"kx_ref\">[88]</a></sup> S.C. Kleene提出的“ Church论文”的前身，他称之为“论文一”，<sup><a href=\"#quote_89\" class=\"kx_ref\">[89]</a></sup> 几年后 Kleene重命名他的论文为“Church 的论文”<sup><a href=\"#quote_90\" class=\"kx_ref\">[90]</a></sup> 和提出“ Turing的论文”。<sup><a href=\"#quote_91\" class=\"kx_ref\">[91]</a></sup> </p><p></p><h3>Emil Post (1936)和 Alan Turing (1936-37，1939)</h3><p></p><p>Emil Post (1936)对“计算机”(人类)的行为描述如下:</p><p>\n </p><dl>\n  <dd>\n   \"...其中涉及两个概念:一个是符号空间，在这个空间中，从问题到答案的工作将被执行；另一个是一组固定的不可改变的方向。 他的符号空间是 “双向无限序列的空间或盒子...问题解决者或工作人员要在这个符号空间中移动和工作，能够在一个盒子里工作，一次只能在一个盒子里工作....一个盒子只允许两种可能的情况，即空的或未标记的，并且其中有一个标记，比如一个垂直的笔画。 “有一个盒子被挑选出来，叫做起点。...一个 特定的问题是用符号形式在被画上记号的有限数量的盒子[即输入]给出的 。同样，答案[(即输出)将以符号形式由这种被标记的盒子配置给出...\n  </dd>\n </dl><p></p><p>\n </p><dl>\n  <dd>\n   “适用于一般问题的一组 指示在适用于每个特定问题时建立了确定性过程。这一过程只有在达到[类型(C)的方向时才终止，[即停止]”。 &nbsp;<sup><a href=\"#quote_92\" class=\"kx_ref\">[92]</a></sup> \n  </dd>\n </dl><p></p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"150\" img_width=\"200\" titlename=\"Alan Turing's statue at Bletchley Park\" data-src=\"https://img02.sogoucdn.com/app/a/200698/sogou_science_132\"> </p><p>Alan Turing的作品<sup><a href=\"#quote_93\" class=\"kx_ref\">[93]</a></sup> 早于 Stibitz的作品(1937)；还不知道 Stibitz是否知道 Turing的工作。 Turing的传记作者认为图灵 Turing使用打字机一样的模型源于 小时候的兴趣:“艾伦小时候就梦想发明打字机；图灵夫人有一台打字机，他 可能是从问自己把打字机叫做‘机械’是什么意思开始的。<sup><a href=\"#quote_94\" class=\"kx_ref\">[94]</a></sup> 鉴于莫尔斯电码和电报、自动收报机和电传打字机的普及，我们[是谁？]可能猜想所有这些都是影响。</p><p>Turing——他的计算模型现在被称为图灵机——和 Post一样，开始于对人类计算机的分析，他把分析简化为一组简单的基本运动和“ 思维状态”。但是他更进一步，创造了一台机器作为计算数字的模型。<sup><a href=\"#quote_95\" class=\"kx_ref\">[95]</a></sup> </p><p>\n </p><dl>\n  <dd>\n   “计算通常是通过在纸上写下某些符号来完成的。我们可以假设这张纸像一本儿童算术书一样被分成正方形...我假设计算是在一维纸上进行的，也就是说，在分成正方形的磁带上。我还假设可以打印的符号数量是有限的... 计算机在任何时候的行为都是由他观察到的符号和他当时的“思维 状态”决定的。我们可以假设计算机在某一时刻可以观察到的符号或正方形的数量有一个界限。如果他想观察更多，他必须使用连续的观察。我们还将假设需要考虑的 思维状态的数量是有限的... “让我们想象一下，由计算机执行的操作被分解成“简单的操作”，这些操作非常简单，很难想象它们会被进一步分解。” &nbsp;<sup><a href=\"#quote_96\" class=\"kx_ref\">[96]</a></sup> \n  </dd>\n </dl><p></p><p>Turing的归约产生了以下结果:</p><p>“因此，简单的操作必须包括:</p><p>\"(a)观察到的一个方块上的符号发生变化</p><p>\"(b)观察到的一个正方形向先前观察到的一个正方形的L个正方形内的另一个正方形的变化。</p><p>“可能其中一些变化必然会引起 思维状态的变化。因此，最一般的单一操作必须被视为以下操作之一:</p><p>\"(A) 符号的可能变化以及 思维状态的可能变化。</p><p>(B) 观察到的正方形的可能变化，以及思维状态 的可能变化</p><p>\"我们现在可以建造一台机器来完成这台计算机的工作.\"<sup><a href=\"#quote_96\" class=\"kx_ref\">[96]</a></sup> </p><p>几年后，图灵用这种有力的表达扩展了他的分析(论文，定义):</p><p>如果一个函数的值可以通过一些纯粹的机械过程找到，那么这个函数就被称为是“可有效计算的”。尽管很容易直观地理解这一概念，但还是希望有一些更明确的、数学上可表达的定义...[:他讨论了定义的历史，就像上面提到的 Gödel, Herbrand, Kleene, Church, Turing, and Post一样]...我们可以从字面上理解这句话，理解为一个可以被机器执行纯粹的机械过程 。有可能以某种形式给出这些机器结构的数学描述。这些思想的发展 引出了作者对可计算函数的定义，以及对可有效计算的可计算性 的识别...。</p><p>“我们将使用表达式“可计算函数”来表示可由机器计算的函数，并且我们让“可有效计算的”指的是直观的概念，而不与这些定义中的任何一个进行特殊的标识”。<sup><a href=\"#quote_97\" class=\"kx_ref\">[97]</a></sup> </p><p></p><h3>J.B. Rosser (1939)和S.C. Kleene&nbsp; (1943)</h3><p></p><p>J. Barkley Rosser以下列方式定义了“有效的[数学]方法”(增加了斜体):</p><p>“‘有效方法’在这里是以一种意义相当特殊的方法 来使用的，该方法的每一个步骤都被精确地确定，并且肯定会在有限的步骤中产生答案。有了这种特殊的含义，迄今为止已经给出了三种不同的精确定义。[，他的脚注5；请参见下面的讨论]。其中最简单的陈述( 归功于Post和Turing)说，如果一个人能造出一台机器来解决这组问题，除了插入问题和(稍后)阅读答案之外，不需要任何人的干预，就能解决这组问题，那么这就是解决某些问题的有效方法。这三个定义都是等价的，所以使用哪一个并不重要。此外，这三者都是等价的这一事实是任何一种方法 正确性的有力论据。”( Rosser 1939:225–226)</p><p>Rosser的脚注5提到了(1)Church和Kleene 的工作以及他们对λ可定义性的定义，特别是 Church在他的《初等数论的一个无法解决的问题》(1936)中对λ可定义性的使用；(2) Herbrand和 Gödel及其递归的使用，特别是 Gödel在他的著名论文《数学原理及相关系统的形式不可判定命题一》(1931)中的使用；和(3)Post(1936)和Turing (1936-37)在他们的计算机制模型中。</p><p>Stephen C. Kleene把他现在著名的“论文一”定义为 Church—— Turing论文。但他是在以下背景下这样做的(原文为黑体):</p><p>“12。算法理论...在建立一个完整的算法理论的过程中，我们所做的是描述一个过程，这个过程对于独立变量的每一组值都是可执行的，这个过程必须终止，并且以这样的方式，从结果中我们可以读到一个明确的答案，“是”或“否”，对于这个问题，“这个断言的值 是真的吗？\" \"( Kleene1943:273)</p><p>\n </p><dl>\n  <dd></dd>\n </dl><p></p><p></p><h3>1950年后的历史</h3><p></p><p>为了进一步完善“算法”的定义 ，人们付出了大量的努力。由于围绕数学基础(尤其是Church -Turing 论文)和 精神哲学(尤其是关于人工智能的争论)的问题，活动仍在继续。有关更多信息，请参见算法特性。</p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_132?w=200&h=150&titlename=Alan%20Turing's%20statue%20at%20Bletchley%20Park","url":"https://web.archive.org/web/20221025113656/https://img02.sogoucdn.com/app/a/200698/sogou_science_132","rw":200,"rh":150,"title":"Alan Turing's statue at Bletchley Park","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099565949198","title":"笔记","versionId":"53964833581752083","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>\n <ol>\n  <li id=\"cite-ref-2\">\"Any classical mathematical algorithm, for example, can be described in a finite number of English words\" (Rogers 1987:2).</li>\n  <li id=\"cite-ref-4\">Well defined with respect to the agent that executes the algorithm: \"There is a computing agent, usually human, which can react to the instructions and carry out the computations\" (Rogers 1987:2).</li>\n  <li id=\"cite-ref-6\">\"an algorithm is a procedure for computing a <i>function</i> (with respect to some chosen notation for integers) ... this limitation (to numerical functions) results in no loss of generality\", (Rogers 1987:1).</li>\n  <li id=\"cite-ref-8\">\"An algorithm has zero or more inputs, i.e., quantities which are given to it initially before the algorithm begins\" (Knuth 1973:5).</li>\n  <li id=\"cite-ref-10\">\"A procedure which has all the characteristics of an algorithm except that it possibly lacks finiteness may be called a 'computational method'\" (Knuth 1973:5).</li>\n  <li id=\"cite-ref-12\">\"An algorithm has one or more outputs, i.e. quantities which have a specified relation to the inputs\" (Knuth 1973:5).</li>\n  <li id=\"cite-ref-14\">Whether or not a process with random interior processes (not including the input) is an algorithm is debatable. Rogers opines that: \"a computation is carried out in a discrete stepwise fashion, without the use of continuous methods or analogue devices ... carried forward deterministically, without resort to random methods or devices, e.g., dice\" (Rogers 1987:2).</li>\n  <li id=\"cite-ref-16\">Cooke, Roger L. (2005). <i>The History of Mathematics: A Brief Course</i>. John Wiley &amp; Sons. ISBN&nbsp;978-1-118-46029-0.</li>\n  <li id=\"cite-ref-18\">Kleene 1943 in Davis 1965:274</li>\n  <li id=\"cite-ref-20\">Rosser 1939 in Davis 1965:225</li>\n  <li id=\"cite-ref-22\">\"Al-Khwarizmi biography\". <i>www-history.mcs.st-andrews.ac.uk</i>.</li>\n  <li id=\"cite-ref-24\">\"Etymology of algorithm\". <i>Chambers Dictionary</i>. Retrieved December 13, 2016.</li>\n  <li id=\"cite-ref-26\">Hogendijk, Jan P. (1998). \"al-Khwarzimi\". <i>Pythagoras</i>. <b>38</b> (2): 4–5. Archived from the original on April 12, 2009.</li>\n  <li id=\"cite-ref-28\">Oaks, Jeffrey A. \"Was al-Khwarizmi an applied algebraist?\". University of Indianapolis. Archived from the original on November 15, 2010. Retrieved May 30, 2008.</li>\n  <li id=\"cite-ref-30\">Brezina, Corona (2006). <i>Al-Khwarizmi: The Inventor Of Algebra</i>. The Rosen Publishing Group. ISBN&nbsp;978-1-4042-0513-0.</li>\n  <li id=\"cite-ref-32\">Foremost mathematical texts in history, according to Carl B. Boyer.</li>\n  <li id=\"cite-ref-34\"><i>Oxford English Dictionary</i>, Third Edition, 2012 <i>s.v.</i> </li>\n  <li id=\"cite-ref-36\">Stone 1973:4</li>\n  <li id=\"cite-ref-38\">Simanowski, Roberto (2018). <i>The Death Algorithm and Other Digital Dilemmas</i>. Untimely Meditations. <b>14</b>. Translated by Chase, Jefferson. Cambridge, Massachusetts: MIT Press. p.&nbsp;147. ISBN&nbsp;9780262536370. Retrieved 27 May 2019. [...] the next level of abstraction of central bureaucracy: globally operating algorithms.</li>\n  <li id=\"cite-ref-40\">Stone simply requires that \"it must terminate in a finite number of steps\" (Stone 1973:7–8).</li>\n  <li id=\"cite-ref-42\">Boolos and Jeffrey 1974,1999:19</li>\n  <li id=\"cite-ref-44\">cf Stone 1972:5</li>\n  <li id=\"cite-ref-46\">Knuth 1973:7 states: \"In practice we not only want algorithms, we want <i>good</i> algorithms ... one criterion of goodness is the length of time taken to perform the algorithm ... other criteria are the adaptability of the algorithm to computers, its simplicity, and elegance, etc.\"</li>\n  <li id=\"cite-ref-48\">cf Stone 1973:6</li>\n  <li id=\"cite-ref-50\">Stone 1973:7–8 states that there must be, \"...a procedure that a robot [i.e., computer] can follow in order to determine precisely how to obey the instruction\". Stone adds finiteness of the process, and definiteness (having no ambiguity in the instructions) to this definition.</li>\n  <li id=\"cite-ref-52\">Knuth, loc. cit</li>\n  <li id=\"cite-ref-54\"></li>\n  <li id=\"cite-ref-56\">Gurevich 2000:1, 3</li>\n  <li id=\"cite-ref-58\">Sipser 2006:157</li>\n  <li id=\"cite-ref-60\">Goodrich, Michael T.; Tamassia, Roberto (2002), <i>Algorithm Design: Foundations, Analysis, and Internet Examples</i>, John Wiley &amp; Sons, Inc., ISBN&nbsp;978-0-471-38365-9</li>\n  <li id=\"cite-ref-62\">Knuth 1973:7</li>\n  <li id=\"cite-ref-64\">Chaitin 2005:32</li>\n  <li id=\"cite-ref-66\">Rogers 1987:1–2</li>\n  <li id=\"cite-ref-68\">In his essay \"Calculations by Man and Machine: Conceptual Analysis\" Seig 2002:390 credits this distinction to Robin Gandy, cf Wilfred Seig, et al., 2002 <i>Reflections on the foundations of mathematics: Essays in honor of Solomon Feferman</i>, Association for Symbolic Logic, A.K. Peters Ltd, Natick, MA.</li>\n  <li id=\"cite-ref-70\">cf Gandy 1980:126, Robin Gandy <i>Church's Thesis and Principles for Mechanisms</i> appearing on pp. 123–148 in J. Barwise et al. 1980 <i>The Kleene Symposium</i>, North-Holland Publishing Company.</li>\n  <li id=\"cite-ref-72\">A \"robot\": \"A computer is a robot that performs any task that can be described as a sequence of instructions.\" cf Stone 1972:3</li>\n  <li id=\"cite-ref-74\">Lambek's \"abacus\" is a \"countably infinite number of locations (holes, wires etc.) together with an unlimited supply of counters (pebbles, beads, etc). The locations are distinguishable, the counters are not\". The holes have unlimited capacity, and standing by is an agent who understands and is able to carry out the list of instructions\" (Lambek 1961:295). Lambek references Melzak who defines his Q-machine as \"an indefinitely large number of locations ... an indefinitely large supply of counters distributed among these locations, a program, and an operator whose sole purpose is to carry out the program\" (Melzak 1961:283). B-B-J (loc. cit.) add the stipulation that the holes are \"capable of holding any number of stones\" (p. 46). Both Melzak and Lambek appear in <i>The Canadian Mathematical Bulletin</i>, vol. 4, no. 3, September 1961.</li>\n  <li id=\"cite-ref-76\">If no confusion results, the word \"counters\" can be dropped, and a location can be said to contain a single \"number\".</li>\n  <li id=\"cite-ref-78\">\"We say that an instruction is <i>effective</i> if there is a procedure that the robot can follow in order to determine precisely how to obey the instruction.\" (Stone 1972:6)</li>\n  <li id=\"cite-ref-80\">cf Minsky 1967: Chapter 11 \"Computer models\" and Chapter 14 \"Very Simple Bases for Computability\" pp. 255–281 in particular</li>\n  <li id=\"cite-ref-82\">cf Knuth 1973:3.</li>\n  <li id=\"cite-ref-84\">But always preceded by IF–THEN to avoid improper subtraction.</li>\n  <li id=\"cite-ref-86\">Knuth 1973:4</li>\n  <li id=\"cite-ref-88\">Stone 1972:5. Methods for extracting roots are not trivial: see Methods of computing square roots.</li>\n  <li id=\"cite-ref-90\">Leeuwen, Jan (1990). <i>Handbook of Theoretical Computer Science: Algorithms and complexity. Volume A</i>. Elsevier. p.&nbsp;85. ISBN&nbsp;978-0-444-88071-0.</li>\n  <li id=\"cite-ref-92\">John G. Kemeny and Thomas E. Kurtz 1985 <i>Back to Basic: The History, Corruption, and Future of the Language</i>, Addison-Wesley Publishing Company, Inc. Reading, MA, ISBN 0-201-13433-0.</li>\n  <li id=\"cite-ref-94\">Tausworthe 1977:101</li>\n  <li id=\"cite-ref-96\">Tausworthe 1977:142</li>\n  <li id=\"cite-ref-98\">Knuth 1973 section 1.2.1, expanded by Tausworthe 1977 at pages 100ff and Chapter 9.1</li>\n  <li id=\"cite-ref-100\">cf Tausworthe 1977</li>\n  <li id=\"cite-ref-102\">Heath 1908:300; Hawking's Dover 2005 edition derives from Heath.</li>\n  <li id=\"cite-ref-104\">\" 'Let CD, measuring BF, leave FA less than itself.' This is a neat abbreviation for saying, measure along BA successive lengths equal to CD until a point F is reached such that the length FA remaining is less than CD; in other words, let BF be the largest exact multiple of CD contained in BA\" (Heath 1908:297)</li>\n  <li id=\"cite-ref-106\">For modern treatments using division in the algorithm, see Hardy and Wright 1979:180, Knuth 1973:2 (Volume 1), plus more discussion of Euclid's algorithm in Knuth 1969:293–297 (Volume 2).</li>\n  <li id=\"cite-ref-108\">Euclid covers this question in his Proposition 1.</li>\n  <li id=\"cite-ref-110\">\"Euclid's Elements, Book VII, Proposition 2\". Aleph0.clarku.edu. Retrieved May 20, 2012.</li>\n  <li id=\"cite-ref-112\">While this notion is in widespread use, it cannot be defined precisely.</li>\n  <li id=\"cite-ref-114\">Knuth 1973:13–18. He credits \"the formulation of algorithm-proving in terms of assertions and induction\" to R W. Floyd, Peter Naur, C.A.R. Hoare, H.H. Goldstine and J. von Neumann. Tausworth 1977 borrows Knuth's Euclid example and extends Knuth's method in section 9.1 <i>Formal Proofs</i> (pp. 288–298).</li>\n  <li id=\"cite-ref-116\">Tausworthe 1997:294</li>\n  <li id=\"cite-ref-118\">cf Knuth 1973:7 (Vol. I), and his more-detailed analyses on pp. 1969:294–313 (Vol II).</li>\n  <li id=\"cite-ref-120\">Breakdown occurs when an algorithm tries to compact itself. Success would solve the Halting problem.</li>\n  <li id=\"cite-ref-122\">Kriegel, Hans-Peter; Schubert, Erich; Zimek, Arthur (2016). \"The (black) art of run-time evaluation: Are we comparing algorithms or implementations?\". <i>Knowledge and Information Systems</i>. <b>52</b> (2): 341–378. doi:10.1007/s10115-016-1004-2. ISSN&nbsp;0219-1377.</li>\n  <li id=\"cite-ref-124\">Gillian Conahan (January 2013). \"Better Math Makes Faster Data Networks\". discovermagazine.com.</li>\n  <li id=\"cite-ref-126\">Haitham Hassanieh, Piotr Indyk, Dina Katabi, and Eric Price, \"ACM-SIAM Symposium On Discrete Algorithms (SODA) Archived 7月 4, 2013 at the Wayback Machine, Kyoto, January 2012. See also the sFFT Web Page.</li>\n  <li id=\"cite-ref-128\">Kowalski 1979</li>\n  <li id=\"cite-ref-130\"><i>Knapsack Problems | Hans Kellerer | Springer</i> (in 英语). Springer. 2004. ISBN&nbsp;978-3-540-40286-2.</li>\n  <li id=\"cite-ref-132\">Carroll, Sue; Daughtrey, Taz (July 4, 2007). <i>Fundamental Concepts for the Software Quality Engineer</i>. American Society for Quality. pp.&nbsp;282 et seq. ISBN&nbsp;978-0-87389-720-4.</li>\n  <li id=\"cite-ref-134\">George B. Dantzig and Mukund N. Thapa. 2003. <i>Linear Programming 2: Theory and Extensions</i>. Springer-Verlag.</li>\n  <li id=\"cite-ref-136\">Tsypkin (1971). <i>Adaptation and learning in automatic systems</i>. Academic Press. p.&nbsp;54. ISBN&nbsp;978-0-08-095582-7.</li>\n  <li id=\"cite-ref-138\">Ast, Courtney. \"Eratosthenes\". Wichita State University: Department of Mathematics and Statistics.</li>\n  <li id=\"cite-ref-140\">Aaboe, Asger (2001), <i>Episodes from the Early History of Astronomy</i>, New York: Springer, pp.&nbsp;40–62, ISBN&nbsp;978-0-387-95136-2</li>\n  <li id=\"cite-ref-142\">Davis 2000:18</li>\n  <li id=\"cite-ref-144\">Bolter 1984:24</li>\n  <li id=\"cite-ref-146\">Bolter 1984:26</li>\n  <li id=\"cite-ref-148\">Bolter 1984:33–34, 204–206.</li>\n  <li id=\"cite-ref-150\">All quotes from W. Stanley Jevons 1880 <i>Elementary Lessons in Logic: Deductive and Inductive</i>, Macmillan and Co., London and New York. Republished as a googlebook; cf Jevons 1880:199–201. Louis Couturat 1914 <i>the Algebra of Logic</i>, The Open Court Publishing Company, Chicago and London. Republished as a googlebook; cf Couturat 1914:75–76 gives a few more details; he compares this to a typewriter as well as a piano. Jevons states that the account is to be found at January 20, 1870 <i>The Proceedings of the Royal Society</i>.</li>\n  <li id=\"cite-ref-152\">Jevons 1880:199–200</li>\n  <li id=\"cite-ref-154\">All quotes from John Venn 1881 <i>Symbolic Logic</i>, Macmillan and Co., London. Republished as a googlebook. cf Venn 1881:120–125. The interested reader can find a deeper explanation in those pages.</li>\n  <li id=\"cite-ref-156\">Bell and Newell diagram 1971:39, cf. Davis 2000</li>\n  <li id=\"cite-ref-158\">* Melina Hill, Valley News Correspondent, <i>A Tinkerer Gets a Place in History</i>, Valley News West Lebanon NH, Thursday, March 31, 1983, p. 13.</li>\n  <li id=\"cite-ref-160\">Davis 2000:14</li>\n  <li id=\"cite-ref-162\">van Heijenoort 1967:81ff</li>\n  <li id=\"cite-ref-164\">van Heijenoort's commentary on Frege's <i>Begriffsschrift, a formula language, modeled upon that of arithmetic, for pure thought</i> in van Heijenoort 1967:1</li>\n  <li id=\"cite-ref-166\">Dixon 1906, cf. Kleene 1952:36–40</li>\n  <li id=\"cite-ref-168\">cf. footnote in Alonzo Church 1936a in Davis 1965:90 and 1936b in Davis 1965:110</li>\n  <li id=\"cite-ref-170\">Kleene 1935–6 in Davis 1965:237ff, Kleene 1943 in Davis 1965:255ff</li>\n  <li id=\"cite-ref-172\">Church 1936 in Davis 1965:88ff</li>\n  <li id=\"cite-ref-174\">cf. \"Finite Combinatory Processes – formulation 1\", Post 1936 in Davis 1965:289–290</li>\n  <li id=\"cite-ref-176\">Turing 1936–37 in Davis 1965:116ff</li>\n  <li id=\"cite-ref-178\">Rosser 1939 in Davis 1965:226</li>\n  <li id=\"cite-ref-180\">Kleene 1943 in Davis 1965:273–274</li>\n  <li id=\"cite-ref-182\">Kleene 1952:300, 317</li>\n  <li id=\"cite-ref-184\">Kleene 1952:376</li>\n  <li id=\"cite-ref-186\">Turing 1936–37 in Davis 1965:289–290</li>\n  <li id=\"cite-ref-188\">Turing 1936 in Davis 1965, Turing 1939 in Davis 1965:160</li>\n  <li id=\"cite-ref-190\">Hodges, p.&nbsp;96</li>\n  <li id=\"cite-ref-192\">Turing 1936–37:116</li>\n  <li id=\"cite-ref-194\">Turing 1936–37 in Davis 1965:136</li>\n  <li id=\"cite-ref-196\">Turing 1939 in Davis 1965:160</li>\n </ol></p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14995099565949199","title":"文献学","versionId":"53964833581752084","lemmaId":10392,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":82812762,"name":"雷克斯班纳","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1599461547,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>\n <ul>\n  <li>Axt, P (1959). \"On a Subrecursive Hierarchy and Primitive Recursive Degrees\". <i>Transactions of the American Mathematical Society</i>. <b>92</b> (1): 85–105. doi:10.2307/1993169. JSTOR&nbsp;1993169.</li>\n  <li>艾伦·戈登·贝尔和纽维尔(1971年)， <i>计算机结构:阅读和例子</i>纽约麦格劳希尔图书公司。 ISBN 0-07-004357-4。</li>\n  <li>Blass, Andreas; Gurevich, Yuri (2003). \"Algorithms: A Quest for Absolute Definitions\" (PDF). <i>Bulletin of European Association for Theoretical Computer Science</i>. <b>81</b>. 包括56篇参考文献的优秀书目。</li>\n  <li>Bolter, David J. (1984). <i>Turing's Man: Western Culture in the Computer Age</i> (1984 ed.). Chapel Hill, NC: The University of North Carolina Press. ISBN&nbsp;978-0-8078-1564-9., ISBN 0-8078-4108-0</li>\n  <li>Boolos, George; Jeffrey, Richard (1999) [1974]. <i>Computability and Logic</i> (4th ed.). Cambridge University Press, London. ISBN&nbsp;978-0-521-20402-6.:参见第3章 <i>图灵机</i> 其中他们讨论“某些不有效(机械地)可枚举的可枚举集合”。</li>\n  <li>Burgin, Mark (2004). <i>Super-Recursive Algorithms</i>. Springer. ISBN&nbsp;978-0-387-95569-8.</li>\n  <li>孔帕尼奥洛，M.L .，Moore，c .，Costa，J.F. (2000)一个子正则函数的模拟特征化。在 <i>继续。第四届实数和计算机会议</i>奥登塞大学，页&nbsp;91–109</li>\n  <li>Church, Alonzo (1936a). \"An Unsolvable Problem of Elementary Number Theory\". <i>The American Journal of Mathematics</i>. <b>58</b> (2): 345–363. doi:10.2307/2371045. JSTOR&nbsp;2371045. 重印于 <i>不可判定的</i>，p。&nbsp;89ff。“Church's论文”的第一个表述。具体参见第100页(<i>不可判定的</i>)其中他用“算法”定义了“有效可计算性”的概念，并使用了“终止”等词。</li>\n  <li>Church, Alonzo (1936b). \"A Note on the Entscheidungsproblem\". <i>The Journal of Symbolic Logic</i>. <b>1</b> (1): 40–41. doi:10.2307/2269326. JSTOR&nbsp;2269326. Church, Alonzo (1936). \"Correction to a Note on the Entscheidungsproblem\". <i>The Journal of Symbolic Logic</i>. <b>1</b> (3): 101–102. doi:10.2307/2269030. JSTOR&nbsp;2269030. 重印于 <i>不可判定的</i>，p。&nbsp;110ff。丘奇用大约3页的文字和3页的脚注表明可判定性是不可解决的。</li>\n  <li>Daffa', Ali Abdullah al- (1977). <i>The Muslim contribution to mathematics</i>. London: Croom Helm. ISBN&nbsp;978-0-85664-464-1.</li>\n  <li>Davis, Martin (1965). <i>The Undecidable: Basic Papers On Undecidable Propositions, Unsolvable Problems and Computable Functions</i>. New York: Raven Press. ISBN&nbsp;978-0-486-43228-1. 戴维斯在每篇文章之前给出评论。包括哥德尔、阿隆佐·邱奇、图灵、罗塞尔、克莱尼和埃米尔邮报的论文；文章中引用的那些是按作者的名字列出的。</li>\n  <li>Davis, Martin (2000). <i>Engines of Logic: Mathematicians and the Origin of the Computer</i>. New York: W.W. Nortion. ISBN&nbsp;978-0-393-32229-3. 戴维斯提供了莱布尼茨、布尔、弗雷格、康托尔、希尔伯特、哥德尔和图灵的简明传记，冯·诺伊曼是盗窃表演的恶棍。约瑟夫·玛丽·雅卡尔、巴贝奇、阿达·洛芙莱斯、克劳德·香农、霍华德·艾肯等的简介。</li>\n  <li>&nbsp;本条目引用的公有领域材料。材料来自NIST的文档：Black, Paul E. \"algorithm\". <i>演算法与资料结构辞典（英语：Dictionary of Algorithms and Data Structures）</i>.</li>\n  <li>Dean, Tim (2012). \"Evolution and moral diversity\". <i>Baltic International Yearbook of Cognition, Logic and Communication</i>. <b>7</b>.</li>\n  <li>Dennett, Daniel (1995). <i>Darwin's Dangerous Idea</i>. <i>Complexity</i>. <b>2</b>. New York: Touchstone/Simon &amp; Schuster. p.&nbsp;32. Bibcode:1996Cmplx...2a..32M. doi:10.1002/(SICI)1099-0526(199609/10)2:1&lt;32::AID-CPLX8&gt;3.0.CO;2-H. ISBN&nbsp;978-0-684-80290-9.</li>\n  <li>Dilson, Jesse (2007). <i>The Abacus</i> ((1968, 1994) ed.). St. Martin's Press, NY. ISBN&nbsp;978-0-312-10409-2., ISBN 0-312-10409-X</li>\n  <li>尤里·古列维奇， <i>Sequential Abstract State Machines Capture Sequential Algorithms</i>《计算逻辑交易》，第1卷，第1期(2000年7月)，页&nbsp;77–111。包括33个来源的参考书目。</li>\n  <li>van Heijenoort, Jean (2001). <i>From Frege to Gödel, A Source Book in Mathematical Logic, 1879–1931</i> ((1967) ed.). Harvard University Press, Cambridge. ISBN&nbsp;978-0-674-32449-7.，1976年第三版，[？]， ISBN 0-674-32449-8 (pbk。)</li>\n  <li>Hodges, Andrew (1983). <i>Alan Turing: The Enigma</i>. <i>Physics Today</i>. <b>37</b>. New York: Simon and Schuster. p.&nbsp;107. Bibcode:1984PhT....37k.107H. doi:10.1063/1.2915935. ISBN&nbsp;978-0-671-49207-6., ISBN 0-671-49207-1。参见“真理的精神”一章，这是一部导致和讨论他的证明的历史。</li>\n  <li>Kleene, Stephen C. (1936). \"General Recursive Functions of Natural Numbers\". <i>Mathematische Annalen</i>. <b>112</b> (5): 727–742. doi:10.1007/BF01565439. 1935年9月提交给美国数学学会。重印于 <i>不可判定的</i>，p。&nbsp;237ff。克莱尼对“一般递归”(现在称为mu递归)的定义被丘奇在他1935年的论文中使用 <i>初等数论中一个不可解决的问题</i> 这证明了“决策问题”是“不可判定的”(即否定的结果)。</li>\n  <li>Kleene, Stephen C. (1943). \"Recursive Predicates and Quantifiers\". <i>American Mathematical Society Transactions</i>. <b>54</b> (1): 41–73. doi:10.2307/1990131. JSTOR&nbsp;1990131. 重印于 <i>不可判定的</i>，p。&nbsp;255ff。克莱尼完善了他对“一般递归”的定义，并在他的第12章继续进行。“算法理论”假设“论文一”(p&nbsp;274)；他后来会重复这篇论文(在克莱尼1952:300)并命名为“Church's论文”(克莱尼1952:317)(即教会论文)。</li>\n  <li>Kleene, Stephen C. (1991) [1952]. <i>Introduction to Metamathematics</i> (Tenth ed.). North-Holland Publishing Company. ISBN&nbsp;978-0-7204-2103-3.</li>\n  <li>Knuth, Donald (1997). <i>Fundamental Algorithms, Third Edition</i>. Reading, Massachusetts: Addison–Wesley. ISBN&nbsp;978-0-201-89683-1.</li>\n  <li>Knuth, Donald (1969). <i>Volume 2/Seminumerical Algorithms, The Art of Computer Programming First Edition</i>. Reading, Massachusetts: Addison–Wesley.</li>\n  <li>科索沃 <i>数理逻辑元素及其在子算法理论中的应用</i>，LSU Publ。列宁格勒，1981年</li>\n  <li>Kowalski, Robert (1979). \"Algorithm=Logic+Control\". <i>Communications of the ACM</i>. <b>22</b> (7): 424–436. doi:10.1145/359131.359136.</li>\n  <li>马可夫(1954) <i>算法理论</i>。[译自雅克·舒尔-孔和科普特工作人员]印刻莫斯科，苏联科学院，1954年[，即耶路撒冷，以色列科学翻译方案，1961年；可从华盛顿美国商务部技术服务办公室获得]描述444页&nbsp;28&nbsp;cm。苏联科学院数学研究所作品俄文翻译，第五版&nbsp;42.原标题:Teoriya algerifmov。[QA248。达特茅斯学院图书馆。美国商务部技术服务办公室，电话:OTS 60-51085。]</li>\n  <li>Minsky, Marvin (1967). <i>Computation: Finite and Infinite Machines</i> (First ed.). Prentice-Hall, Englewood Cliffs, NJ. ISBN&nbsp;978-0-13-165449-5. 明斯基扩展了他的”...算法的想法——一个有效的程序……”在第5.1章中 <i>可计算性、有效程序和算法。无限的机器。</i></li>\n  <li>Post, Emil (1936). \"Finite Combinatory Processes, Formulation I\". <i>The Journal of Symbolic Logic</i>. <b>1</b> (3): 103–105. doi:10.2307/2269031. JSTOR&nbsp;2269031. 重印于 <i>不可判定的</i>，第页。&nbsp;289ff。Post定义了一个简单的类似算法的过程，一个人写标记或擦除标记，然后从一个盒子到另一个盒子，最后停下来，按照简单的指令列表。这被克莱尼引用为他的“论文一”的一个来源，即所谓的邱奇－图灵论题。</li>\n  <li>Rogers, Jr, Hartley (1987). <i>Theory of Recursive Functions and Effective Computability</i>. The MIT Press. ISBN&nbsp;978-0-262-68052-3.</li>\n  <li>Rosser, J.B. (1939). \"An Informal Exposition of Proofs of Godel's Theorem and Church's Theorem\". <i>Journal of Symbolic Logic</i>. <b>4</b> (2): 53–60. doi:10.2307/2269059. JSTOR&nbsp;2269059. 重印于 <i>不可判定的</i>，p。&nbsp;223ff。这是罗斯尔对“有效方法”的著名定义...一种方法，其每一步都是精确预先确定的，并且一定会在有限的步骤中产生答案...一种机器，除了插入问题和(稍后)阅读答案之外，无需人工干预就能解决集合中的任何问题。&nbsp;225–226， <i>不可判定的</i>)</li>\n  <li>Santos-Lang, Christopher (2014). \"Moral Ecology Approaches to Machine Ethics\" (PDF). In van Rysewyk, Simon; Pontier, Matthijs. <i>Machine Medical Ethics</i>. Intelligent Systems, Control and Automation: Science and Engineering. <b>74</b>. Switzerland: Springer. pp.&nbsp;111–127. doi:10.1007/978-3-319-08108-3_8. ISBN&nbsp;978-3-319-08107-6.</li>\n  <li>Scott, Michael L. (2009). <i>Programming Language Pragmatics</i> (3rd ed.). Morgan Kaufmann Publishers/Elsevier. ISBN&nbsp;978-0-12-374514-9.</li>\n  <li>Sipser, Michael (2006). <i>Introduction to the Theory of Computation</i>. PWS Publishing Company. ISBN&nbsp;978-0-534-94728-6.</li>\n  <li>Sober, Elliott; Wilson, David Sloan (1998). <i>Unto Others: The Evolution and Psychology of Unselfish Behavior</i>. Cambridge: Harvard University Press.</li>\n  <li>Stone, Harold S. (1972). <i>Introduction to Computer Organization and Data Structures</i> (1972 ed.). McGraw-Hill, New York. ISBN&nbsp;978-0-07-061726-1. 特别参见第一章，标题为: <i>算法、图灵机和程序</i>。”他简洁的非正式定义...机器人可以遵循的任何指令序列称为 <i>算法</i>\"(p .&nbsp;4)。</li>\n  <li>Tausworthe, Robert C (1977). <i>Standardized Development of Computer Software Part 1 Methods</i>. Englewood Cliffs NJ: Prentice–Hall, Inc. ISBN&nbsp;978-0-13-842195-3.</li>\n  <li>Turing, Alan M. (1936–37). \"On Computable Numbers, With An Application to the Entscheidungsproblem\". <i>Proceedings of the London Mathematical Society</i>. Series 2. <b>42</b>: 230–265. doi:10.1112/plms/s2-42.1.230.。更正，同上，第43卷(1937)页&nbsp;544–546。重印于 <i>不可判定的</i>，p。&nbsp;116ff。图灵的著名论文是在英国美国国王学院剑桥大学完成的硕士论文。</li>\n  <li>Turing, Alan M. (1939). \"Systems of Logic Based on Ordinals\". <i>Proceedings of the London Mathematical Society</i>. <b>45</b>: 161–228. doi:10.1112/plms/s2-45.1.161. hdl:21.11116/0000-0001-91CE-3. 重印于 <i>不可判定的</i>，第页。&nbsp;155ff。图灵定义“神谕”的论文是他在普林斯顿时的博士论文。</li>\n  <li>美国专利及商标局(2006)， <i>2106.02 **&gt;Mathematical Algorithms: 2100 Patentability</i>《专利审查程序手册》(MPEP)。最新修订于2006年8月</li>\n </ul></p>","pics":null,"card":null,"references":[],"versionCount":0}],"references":[{"id":1,"type":"book","title":"\"Any classical mathematical algorithm, for example, can be described in a finite number of English words\" (Rogers 1987:2).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":2,"type":"book","title":"Well defined with respect to the agent that executes the algorithm: \"There is a computing agent, usually human, which can react to the instructions and carry out the computations\" (Rogers 1987:2).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":3,"type":"book","title":"\"an algorithm is a procedure for computing a function (with respect to some chosen notation for integers) ... this limitation (to numerical functions) results in no loss of generality\", (Rogers 1987:1).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":4,"type":"book","title":"\"An algorithm has zero or more inputs, i.e., quantities which are given to it initially before the algorithm begins\" (Knuth 1973:5).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":5,"type":"book","title":"\"A procedure which has all the characteristics of an algorithm except that it possibly lacks finiteness may be called a 'computational method'\" (Knuth 1973:5).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":6,"type":"book","title":"\"An algorithm has one or more outputs, i.e. quantities which have a specified relation to the inputs\" (Knuth 1973:5).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":7,"type":"book","title":"Whether or not a process with random interior processes (not including the input) is an algorithm is debatable. Rogers opines that: \"a computation is carried out in a discrete stepwise fashion, without the use of continuous methods or analogue devices ... carried forward deterministically, without resort to random methods or devices, e.g., dice\" (Rogers 1987:2).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":8,"type":"book","title":"Kleene 1943 in Davis 1965:274","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":9,"type":"book","title":"Rosser 1939 in Davis 1965:225","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":10,"type":"book","title":"\"Al-Khwarizmi biography\". www-history.mcs.st-andrews.ac.uk.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":11,"type":"book","title":"\"Etymology of algorithm\". Chambers Dictionary. Retrieved December 13, 2016.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":12,"type":"book","title":"Hogendijk, Jan P. (1998). \"al-Khwarzimi\". Pythagoras. 38 (2): 4–5. Archived from the original on April 12, 2009.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":13,"type":"book","title":"Oaks, Jeffrey A. \"Was al-Khwarizmi an applied algebraist?\". University of Indianapolis. Archived from the original on November 15, 2010. Retrieved May 30, 2008.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":14,"type":"book","title":"Brezina, Corona (2006). Al-Khwarizmi: The Inventor Of Algebra. The Rosen Publishing Group. ISBN 978-1-4042-0513-0.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":15,"type":"book","title":"Foremost mathematical texts in history, according to Carl B. Boyer.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":16,"type":"book","title":"Oxford English Dictionary, Third Edition, 2012 s.v.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":17,"type":"book","title":"Stone 1973:4","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":18,"type":"book","title":"Simanowski, Roberto (2018). The Death Algorithm and Other Digital Dilemmas. Untimely Meditations. 14. Translated by Chase, Jefferson. Cambridge, Massachusetts: MIT Press. p. 147. ISBN 9780262536370. Retrieved 27 May 2019. [...] the next level of abstraction of central bureaucracy: globally operating algorithms.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":19,"type":"book","title":"Stone simply requires that \"it must terminate in a finite number of steps\" (Stone 1973:7–8).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":20,"type":"book","title":"Boolos and Jeffrey 1974,1999:19","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":21,"type":"book","title":"cf Stone 1972:5","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":22,"type":"book","title":"Knuth 1973:7 states: \"In practice we not only want algorithms, we want good algorithms ... one criterion of goodness is the length of time taken to perform the algorithm ... other criteria are the adaptability of the algorithm to computers, its simplicity, and elegance, etc.\"","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":23,"type":"book","title":"cf Stone 1973:6","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":24,"type":"book","title":"Stone 1973:7–8 states that there must be, \"...a procedure that a robot [i.e., computer] can follow in order to determine precisely how to obey the instruction\". Stone adds finiteness of the process, and definiteness (having no ambiguity in the instructions) to this definition.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":25,"type":"book","title":"Knuth, loc. cit","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":26,"type":"book","title":"Minsky 1967","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":27,"type":"book","title":"Gurevich 2000:1, 3","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":28,"type":"book","title":"Sipser 2006:157","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":29,"type":"book","title":"Goodrich, Michael T.; Tamassia, Roberto (2002), Algorithm Design: Foundations, Analysis, and Internet Examples, John Wiley & Sons, Inc., ISBN 978-0-471-38365-9","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":30,"type":"book","title":"Knuth 1973:7","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":31,"type":"book","title":"Chaitin 2005:32","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":32,"type":"book","title":"Rogers 1987:1–2","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":33,"type":"book","title":"In his essay \"Calculations by Man and Machine: Conceptual Analysis\" Seig 2002:390 credits this distinction to Robin Gandy, cf Wilfred Seig, et al., 2002 Reflections on the foundations of mathematics: Essays in honor of Solomon Feferman, Association for Symbolic Logic, A.K. Peters Ltd, Natick, MA.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":34,"type":"book","title":"cf Gandy 1980:126, Robin Gandy Church's Thesis and Principles for Mechanisms appearing on pp. 123–148 in J. Barwise et al. 1980 The Kleene Symposium, North-Holland Publishing Company.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":35,"type":"book","title":"A \"robot\": \"A computer is a robot that performs any task that can be described as a sequence of instructions.\" cf Stone 1972:3","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":36,"type":"book","title":"Lambek's \"abacus\" is a \"countably infinite number of locations (holes, wires etc.) together with an unlimited supply of counters (pebbles, beads, etc). The locations are distinguishable, the counters are not\". The holes have unlimited capacity, and standing by is an agent who understands and is able to carry out the list of instructions\" (Lambek 1961:295). Lambek references Melzak who defines his Q-machine as \"an indefinitely large number of locations ... an indefinitely large supply of counters distributed among these locations, a program, and an operator whose sole purpose is to carry out the program\" (Melzak 1961:283). B-B-J (loc. cit.) add the stipulation that the holes are \"capable of holding any number of stones\" (p. 46). Both Melzak and Lambek appear in The Canadian Mathematical Bulletin, vol. 4, no. 3, September 1961.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":37,"type":"book","title":"If no confusion results, the word \"counters\" can be dropped, and a location can be said to contain a single \"number\".","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":38,"type":"book","title":"\"We say that an instruction is effective if there is a procedure that the robot can follow in order to determine precisely how to obey the instruction.\" (Stone 1972:6)","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":39,"type":"book","title":"cf Minsky 1967: Chapter 11 \"Computer models\" and Chapter 14 \"Very Simple Bases for Computability\" pp. 255–281 in particular","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":40,"type":"book","title":"cf Knuth 1973:3.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":41,"type":"book","title":"But always preceded by IF–THEN to avoid improper subtraction.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":42,"type":"book","title":"Knuth 1973:4","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":43,"type":"book","title":"Stone 1972:5. Methods for extracting roots are not trivial: see Methods of computing square roots.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":44,"type":"book","title":"Leeuwen, Jan (1990). Handbook of Theoretical Computer Science: Algorithms and complexity. Volume A. Elsevier. p. 85. ISBN 978-0-444-88071-0.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":45,"type":"book","title":"John G. Kemeny and Thomas E. Kurtz 1985 Back to Basic: The History, Corruption, and Future of the Language, Addison-Wesley Publishing Company, Inc. Reading, MA, ISBN 0-201-13433-0.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":46,"type":"book","title":"Tausworthe 1977:101","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":47,"type":"book","title":"Tausworthe 1977:142","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":48,"type":"book","title":"Knuth 1973 section 1.2.1, expanded by Tausworthe 1977 at pages 100ff and Chapter 9.1","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":49,"type":"book","title":"cf Tausworthe 1977","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":50,"type":"book","title":"Heath 1908:300; Hawking's Dover 2005 edition derives from Heath.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":51,"type":"book","title":"\" 'Let CD, measuring BF, leave FA less than itself.' This is a neat abbreviation for saying, measure along BA successive lengths equal to CD until a point F is reached such that the length FA remaining is less than CD; in other words, let BF be the largest exact multiple of CD contained in BA\" (Heath 1908:297)","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":52,"type":"book","title":"For modern treatments using division in the algorithm, see Hardy and Wright 1979:180, Knuth 1973:2 (Volume 1), plus more discussion of Euclid's algorithm in Knuth 1969:293–297 (Volume 2).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":53,"type":"book","title":"Euclid covers this question in his Proposition 1.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":54,"type":"book","title":"\"Euclid's Elements, Book VII, Proposition 2\". Aleph0.clarku.edu. Retrieved May 20, 2012.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":55,"type":"book","title":"While this notion is in widespread use, it cannot be defined precisely.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":56,"type":"book","title":"Knuth 1973:13–18. He credits \"the formulation of algorithm-proving in terms of assertions and induction\" to R W. Floyd, Peter Naur, C.A.R. Hoare, H.H. Goldstine and J. von Neumann. Tausworth 1977 borrows Knuth's Euclid example and extends Knuth's method in section 9.1 Formal Proofs (pp. 288–298).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":57,"type":"book","title":"Tausworthe 1997:294","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":58,"type":"book","title":"cf Knuth 1973:7 (Vol. I), and his more-detailed analyses on pp. 1969:294–313 (Vol II).","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":59,"type":"book","title":"Breakdown occurs when an algorithm tries to compact itself. Success would solve the Halting problem.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":60,"type":"book","title":"Kriegel, Hans-Peter; Schubert, Erich; Zimek, Arthur (2016). \"The (black) art of run-time evaluation: Are we comparing algorithms or implementations?\". Knowledge and Information Systems. 52 (2): 341–378. doi:10.1007/s10115-016-1004-2. ISSN 0219-1377.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":61,"type":"book","title":"Gillian Conahan (January 2013). \"Better Math Makes Faster Data Networks\". discovermagazine.com.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":62,"type":"book","title":"Haitham Hassanieh, Piotr Indyk, Dina Katabi, and Eric Price, \"ACM-SIAM Symposium On Discrete Algorithms (SODA) Archived 7月 4, 2013 at the Wayback Machine, Kyoto, January 2012. See also the sFFT Web Page.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":63,"type":"book","title":"Kowalski 1979","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":64,"type":"book","title":"Knapsack Problems | Hans Kellerer | Springer (in 英语). Springer. 2004. ISBN 978-3-540-40286-2.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":65,"type":"book","title":"Carroll, Sue; Daughtrey, Taz (July 4, 2007). Fundamental Concepts for the Software Quality Engineer. American Society for Quality. pp. 282 et seq. ISBN 978-0-87389-720-4.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":66,"type":"book","title":"George B. Dantzig and Mukund N. Thapa. 2003. Linear Programming 2: Theory and Extensions. Springer-Verlag.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":67,"type":"book","title":"Tsypkin (1971). Adaptation and learning in automatic systems. Academic Press. p. 54. ISBN 978-0-08-095582-7.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":68,"type":"book","title":"Ast, Courtney. \"Eratosthenes\". Wichita State University: Department of Mathematics and Statistics.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":69,"type":"book","title":"Cooke, Roger L. (2005). The History of Mathematics: A Brief Course. John Wiley & Sons. ISBN 978-1-118-46029-0.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":70,"type":"book","title":"Davis 2000:18","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":71,"type":"book","title":"Bolter 1984:24","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":72,"type":"book","title":"Bolter 1984:26","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":73,"type":"book","title":"Bolter 1984:33–34, 204–206.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":74,"type":"book","title":"All quotes from W. Stanley Jevons 1880 Elementary Lessons in Logic: Deductive and Inductive, Macmillan and Co., London and New York. Republished as a googlebook; cf Jevons 1880:199–201. Louis Couturat 1914 the Algebra of Logic, The Open Court Publishing Company, Chicago and London. Republished as a googlebook; cf Couturat 1914:75–76 gives a few more details; he compares this to a typewriter as well as a piano. Jevons states that the account is to be found at January 20, 1870 The Proceedings of the Royal Society.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":75,"type":"book","title":"Jevons 1880:199–200","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":76,"type":"book","title":"All quotes from John Venn 1881 Symbolic Logic, Macmillan and Co., London. Republished as a googlebook. cf Venn 1881:120–125. The interested reader can find a deeper explanation in those pages.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":77,"type":"book","title":"Bell and Newell diagram 1971:39, cf. Davis 2000","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":78,"type":"book","title":"* Melina Hill, Valley News Correspondent, A Tinkerer Gets a Place in History, Valley News West Lebanon NH, Thursday, March 31, 1983, p. 13.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":79,"type":"book","title":"Davis 2000:14","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":80,"type":"book","title":"van Heijenoort 1967:81ff","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":81,"type":"book","title":"van Heijenoort's commentary on Frege's Begriffsschrift, a formula language, modeled upon that of arithmetic, for pure thought in van Heijenoort 1967:1","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":82,"type":"book","title":"Dixon 1906, cf. Kleene 1952:36–40","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":83,"type":"book","title":"cf. footnote in Alonzo Church 1936a in Davis 1965:90 and 1936b in Davis 1965:110","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":84,"type":"book","title":"Kleene 1935–6 in Davis 1965:237ff, Kleene 1943 in Davis 1965:255ff","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":85,"type":"book","title":"Church 1936 in Davis 1965:88ff","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":86,"type":"book","title":"cf. \"Finite Combinatory Processes – formulation 1\", Post 1936 in Davis 1965:289–290","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":87,"type":"book","title":"Turing 1936–37 in Davis 1965:116ff","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":88,"type":"book","title":"Rosser 1939 in Davis 1965:226","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":89,"type":"book","title":"Kleene 1943 in Davis 1965:273–274","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":90,"type":"book","title":"Kleene 1952:300, 317","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":91,"type":"book","title":"Kleene 1952:376","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":92,"type":"book","title":"Turing 1936–37 in Davis 1965:289–290","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":93,"type":"book","title":"Turing 1936 in Davis 1965, Turing 1939 in Davis 1965:160","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":94,"type":"book","title":"Hodges, p. 96","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":95,"type":"book","title":"Turing 1936–37:116","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":96,"type":"book","title":"Turing 1936–37 in Davis 1965:136","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":97,"type":"book","title":"Turing 1939 in Davis 1965:160","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false}],"recommendReferences":null,"auditState":2,"lemmaLevel":1,"origin":0,"originEnTitle":null,"originZhTitle":null,"pv":29699,"auditType":0,"synonyms":["Algorithm"],"showEditTime":"2019.12.13 18:45","auditors":[{"uid":0,"name":"Ki.κe","pic":"https://web.archive.org/web/20221025113656/https://wx.qlogo.cn/mmopen/vi_32/y67kfr32Doib4wg71Jiau7jVWvharic3nRKgdRRQSl6koeQJCo0GQs2Krw0vwdFRsOWnHIQOwAZsSg5lIkIrFCOcQ/132","introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false}],"hasZhishiNav":false,"auditInfos":{},"isHistory":false};</script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/aegis.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/main_2020092401.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/react.production.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/react-dom.production.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/jquery-1.11.1.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/main_2022062701.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/main_66bbe21.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/react.production.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/react-dom.production.min.js.download"></script><script crossorigin="anonymous" src="./392.算法 - 搜狗科学百科_files/main_edf0f08.js.download"></script>
</body></html>