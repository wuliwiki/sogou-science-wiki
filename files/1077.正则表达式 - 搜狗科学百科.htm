<!DOCTYPE html>
<!-- saved from url=(0083)https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm -->
<html class="" data-reactroot=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script src="./1077.正则表达式 - 搜狗科学百科_files/analytics.js.download" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app227.us.archive.org';v.server_ms=251;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="./1077.正则表达式 - 搜狗科学百科_files/bundle-playback.js.download" charset="utf-8"></script>
<script type="text/javascript" src="./1077.正则表达式 - 搜狗科学百科_files/wombat.js.download" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("https://baike.sogou.com/kexue/d11077.htm","20221025114527","https://web.archive.org/","web","/_static/",
	      "1666698327");
</script>
<link rel="stylesheet" type="text/css" href="./1077.正则表达式 - 搜狗科学百科_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./1077.正则表达式 - 搜狗科学百科_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->
<meta name="save" content="history"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="VWGb6TyYx8"><meta content="正则表达式 - 搜狗科学百科" name="keywords"><meta content="搜狗科学百科是一部有着平等、协作、分享、自由理念的网络科学全书，为每一个互联网用户创造一个涵盖所有领域知识、服务的中文知识性平台。" name="description"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="server" baike="235" ip="210" env="online"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://cache.soso.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://hhy.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://pic.baike.soso.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://ugc.qpic.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://xui.ptlogin2.qq.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://q1.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://q2.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://q3.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://q4.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://q.qlogo.cn/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://img01.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://img02.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://img03.sogoucdn.com/"><link rel="dns-prefetch" href="https://web.archive.org/web/20221025114527/https://img04.sogoucdn.com/"><link rel="Shortcut Icon" href="https://web.archive.org/web/20221025114527im_/https://www.sogou.com/images/logo/new/favicon.ico?v=4"><link rel="Bookmark" href="https://www.sogou.com/images/logo/new/favicon.ico?v=4"><link href="./1077.正则表达式 - 搜狗科学百科_files/base_b849887.css" rel="stylesheet"><link href="./1077.正则表达式 - 搜狗科学百科_files/detail_378aed5.css" rel="stylesheet"><link href="./1077.正则表达式 - 搜狗科学百科_files/inviteAudit_7894507.css" rel="stylesheet"><link rel="stylesheet" href="./1077.正则表达式 - 搜狗科学百科_files/highlight.min.css"><title>正则表达式 - 搜狗科学百科</title><style>.onekey-close {
	position: absolute;
	top: 16px;
	right: 16px;
	width: 24px;
	height: 24px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	text-indent: -999em;
	background-size: 84px;
	background-position: -63px 0;
}

.onekey-login {
	position: absolute;
	top: 16.4%;
	left: 0;
	right: 0;
	width: 100%;
}

/* .onekey-login-img {
    width: 75px;
    height: 75px;
    background: url("https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/images/sprite_wap_baike.png") no-repeat;
    background-size: 100px 91px;
    background-position: 0 0;
    background-repeat: no-repeat;
    margin: 0 auto;
} */

.onekey-login-title {
	text-align: center;
	padding-bottom: 3px;
	font-size: 21px;
	font-weight: bold;
	line-height: 30px;
	color: #000;
}

.onekey-login-txt {
	text-align: center;
	font-family: PingFangSC;
	font-size: 14px;
	line-height: 20px;
	color: #8f8f8f;
}

.onekey-login-qq,
.onekey-login-wx,
.onekey-login-phone {
	display: block;
	width: 245px;
	height: 54px;
	border-radius: 45px;
	text-align: center;

	margin: 0 auto;
	font-size: 17px;
	line-height: 24px;
	color: #000;
	/* padding: 16px 77px; */
	border-radius: 12px;
	border: solid 1px #e0e0e0;
}
.onekey-qq-content,
.onekey-vx-content,
.onekey-phone-content {
	display: inline-block;
	margin-top: 16px;
}
.onekey-qq-content {
	padding: 0 5px;
}

.onekey-login-qq {
	margin-top: 48px;
	margin-bottom: 24px;
}

.onekey-login-qq:before {
	display: inline-block;
	content: "";
	width: 20px;
	height: 20px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 80px;
	background-position: -20px 0;
	vertical-align: top;
	margin: 17px 8px 0 0;
}

.onekey-login-wx {
	margin-bottom: 24px;
}

.onekey-login-wx:before {
	display: inline-block;
	content: "";
	width: 21px;
	height: 21px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 84px;
	background-position: 0 0;
	vertical-align: top;
	margin: 17px 10px 0 0;
}

.onekey-login-phone {
}

.onekey-login-phone:before {
	display: inline-block;
	content: "";
	width: 21px;
	height: 21px;
	background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/sprite_wap_baike_37443f3.png) no-repeat;
	background-size: 84px;
	background-position: -42px 0;
	vertical-align: top;
	margin: 17px 10px 0 0;
}

.onekey-fixed {
	z-index: 100;
	position: fixed;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0;
	background: #fff;
	width: 100%;
	height: 100%;
}

.onekey-fixed.forbid {
	z-index: 100;
	position: fixed;
	top: auto;
	bottom: 68px;
	left: 9%;
	right: 0;
	background: rgba(0, 0, 0, 0.7);
	width: 82%;
	height: 43px;
	border-radius: 25px;
	color: #ffffff;
}
.onekey-login-title.forbid {
	text-align: center;
	padding-bottom: 3px;
	font-size: 14px;
	font-weight: normal;
	line-height: 30px;
	color: white;
}
</style><style>#login_mask {
  background: #000;
  opacity: 0.5;
  filter: alpha(opacity=50);
  position: fixed;
  /*fixed好像在哪个IE上有BUG，先用用*/
  left: 0;
  top: 0;
  z-index: 999;
  height: 100%;
}

#login_iframe_container {
  position: fixed;
  width: 550px;
  height: 360px;
  z-index: 1020;
  background-color: #ffffff;
}

@media screen and (max-width: 828px) {
  #login_iframe_container {
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%);
  }
}

#login_iframe_container.new-login {
  width: 550px;
  height: 360px;
  background-image: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/background_2a4a8a6.png);
}

#login_iframe_container.new-login.no-bg {
  background: #fff;
}

#login_iframe_container.new-login .login-title {
  width: 100%;
  height: 42px;
  line-height: 42px;
  text-align: center;
  font-size: 30px;
  letter-spacing: 0.19px;
  color: #ffffff;
  margin-top: 62px;
}
#login_iframe_container.new-login .forbid-title {
  width: 100%;
  height: 42px;
  line-height: 42px;
  text-align: center;
  font-size: 24px;
  letter-spacing: 0.19px;
  color: #333333;
  margin-top: 150px;
}

#login_iframe_container.new-login.no-bg .login-title {
  color: #333333;
}

#login_iframe_container.new-login .login-subtitle {
  width: 100%;
  height: 18px;
  line-height: 18px;
  font-size: 13px;
  letter-spacing: 0.08px;
  color: #ffffff;
  text-align: center;
  margin-top: 9px;
  margin-bottom: 43px;
}

#login_iframe_container.new-login.no-bg .login-subtitle {
  color: #999999;
}

#login_iframe_container.new-login .login-subtitle::before {
  content: '';
  display: inline-block;
  width: 10px;
  height: 1px;
  background-color: #ffffff;
  position: relative;
  top: -4px;
  left: -5px;
}

#login_iframe_container.new-login .login-subtitle::after {
  content: '';
  display: inline-block;
  width: 10px;
  height: 1px;
  background-color: #ffffff;
  position: relative;
  top: -4px;
  left: 5px;
}

#login_iframe_container.new-login.no-bg .login-subtitle::before {
  background-color: #999999;
}

#login_iframe_container.new-login.no-bg .login-subtitle::after {
  background-color: #999999;
}

#login_iframe_container.new-login .close-btn {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 12px;
  height: 12px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -59px -10px;
  background-size: 81px 91px;
  cursor: pointer;
}

#login_iframe_container.new-login .login-btn {
  width: 220px;
  height: 47px;
  border-radius: 24px;
  border: solid 1px #dddddd;
  background-color: #ffffff;
  margin: 0 auto;
  margin-top: 28px;
  position: relative;
  display: block;
}

#login_iframe_container.new-login .login-btn .login-icon {
  position: absolute;
}

#login_iframe_container.new-login .login-btn .login-text {
  width: 61px;
  height: 47px;
  line-height: 47px;
  vertical-align: middle;
  font-size: 15px;
  letter-spacing: 0.1px;
  color: #666666;
  position: absolute;
  right: 62px;
}

#login_iframe_container.new-login .login-btn.qq-btn .login-icon {
  width: 22px;
  height: 27px;
  top: 10px;
  left: 67px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -10px -54px;
  background-size: 81px 91px;
}

#login_iframe_container.new-login .login-btn.qq-btn .login-text {
  right: 59px;
}

#login_iframe_container.new-login .login-btn.wechat-btn .login-icon {
  width: 29px;
  height: 24px;
  top: 12px;
  left: 62px;
  background: url(//web.archive.org/web/20221025113757/https://hhy.sogoucdn.com/js/common/hhy/login-sprites_e3853e5.png) -10px -10px;
  background-size: 81px 91px;
}</style><style>/* -- container -- */
.rodal,
.rodal-mask {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
}

.rodal {
    position: fixed;
}

/* -- mask -- */
.rodal-mask {
    position: fixed;
    background: rgba(0, 0, 0, .5);
}

/* -- dialog -- */
.rodal-dialog {
    position: absolute;
    z-index: 101;
    background: #fff;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, .2);
}

.rodal-center {
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    right: 0;
    margin: 0 auto;
}

.rodal-bottom {
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

.rodal-top {
    left: 0;
    right: 0;
    top: 0;
    margin: auto;
}

.rodal-left {
    top: 0;
    left: 0;
    bottom: 0;
    margin: auto;
}

.rodal-right {
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

/* -- close button -- */
.rodal-close {
    position: absolute;
    cursor: pointer;
    top: 16px;
    right: 16px;
    width: 16px;
    height: 16px;
}

.rodal-close:before,
.rodal-close:after {
    position: absolute;
    content: '';
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: #999;
    border-radius: 100%;
    -webkit-transition: background .2s;
    transition: background .2s;
}

.rodal-close:before {
    -webkit-transform: rotate(45deg);
    transform: rotate(45deg);
}

.rodal-close:after {
    -webkit-transform: rotate(-45deg);
    transform: rotate(-45deg);
}

.rodal-close:hover:before,
.rodal-close:hover:after {
    background: #333;
}

/* -- fade -- */
/* @-webkit-keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

@keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

.rodal-fade-enter {
    -webkit-animation: rodal-fade-enter both ease-in;
    animation: rodal-fade-enter both ease-in;
} */

@-webkit-keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

@keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

.rodal-fade-leave {
    -webkit-animation: rodal-fade-leave both ease-out;
    animation: rodal-fade-leave both ease-out;
}

/* -- zoom -- */
@-webkit-keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-enter {
    -webkit-animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-leave {
    -webkit-animation: rodal-zoom-leave both;
    animation: rodal-zoom-leave both;
}

/* -- slideDown -- */
@-webkit-keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-enter {
    -webkit-animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-leave {
    -webkit-animation: rodal-slideDown-leave both;
    animation: rodal-slideDown-leave both;
}

/* -- slideLeft -- */
@-webkit-keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-enter {
    -webkit-animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-leave {
    -webkit-animation: rodal-slideLeft-leave both;
    animation: rodal-slideLeft-leave both;
}

/* -- slideRight -- */
@-webkit-keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-enter {
    -webkit-animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-leave {
    -webkit-animation: rodal-slideRight-leave both;
    animation: rodal-slideRight-leave both;
}

/* -- slideUp -- */
@-webkit-keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-enter {
    -webkit-animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
    animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
}

@-webkit-keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-leave {
    -webkit-animation: rodal-slideUp-leave both;
    animation: rodal-slideUp-leave both;
}

/* -- flip -- */
@-webkit-keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.rodal-flip-enter {
    -webkit-animation: rodal-flip-enter both ease-in;
    animation: rodal-flip-enter both ease-in;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

@-webkit-keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

@keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

.rodal-flip-leave {
    -webkit-animation: rodal-flip-leave both;
    animation: rodal-flip-leave both;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

/* -- rotate -- */
@-webkit-keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-enter {
    -webkit-animation: rodal-rotate-enter both;
    animation: rodal-rotate-enter both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

@-webkit-keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-leave {
    -webkit-animation: rodal-rotate-leave both;
    animation: rodal-rotate-leave both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

/* -- door -- */
@-webkit-keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

@keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

.rodal-door-enter {
    -webkit-animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

@keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

.rodal-door-leave {
    -webkit-animation: rodal-door-leave both;
    animation: rodal-door-leave both;
}</style><style>/* -- container -- */
.rodal,
.rodal-mask {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 100;
}

.rodal {
    position: fixed;
}

/* -- mask -- */
.rodal-mask {
    position: fixed;
    background: rgba(0, 0, 0, .5);
}

/* -- dialog -- */
.rodal-dialog {
    position: absolute;
    z-index: 101;
    background: #fff;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, .2);
}

.rodal-center {
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    right: 0;
    margin: 0 auto;
}

.rodal-bottom {
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

.rodal-top {
    left: 0;
    right: 0;
    top: 0;
    margin: auto;
}

.rodal-left {
    top: 0;
    left: 0;
    bottom: 0;
    margin: auto;
}

.rodal-right {
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

/* -- close button -- */
.rodal-close {
    position: absolute;
    cursor: pointer;
    top: 16px;
    right: 16px;
    width: 16px;
    height: 16px;
}

.rodal-close:before,
.rodal-close:after {
    position: absolute;
    content: '';
    height: 2px;
    width: 100%;
    top: 50%;
    left: 0;
    margin-top: -1px;
    background: #999;
    border-radius: 100%;
    -webkit-transition: background .2s;
    transition: background .2s;
}

.rodal-close:before {
    -webkit-transform: rotate(45deg);
    transform: rotate(45deg);
}

.rodal-close:after {
    -webkit-transform: rotate(-45deg);
    transform: rotate(-45deg);
}

.rodal-close:hover:before,
.rodal-close:hover:after {
    background: #333;
}

/* -- fade -- */
/* @-webkit-keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

@keyframes rodal-fade-enter {
    from {
        opacity: 0;
    }
}

.rodal-fade-enter {
    -webkit-animation: rodal-fade-enter both ease-in;
    animation: rodal-fade-enter both ease-in;
} */

@-webkit-keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

@keyframes rodal-fade-leave {
    to {
        opacity: 0
    }
}

.rodal-fade-leave {
    -webkit-animation: rodal-fade-leave both ease-out;
    animation: rodal-fade-leave both ease-out;
}

/* -- zoom -- */
@-webkit-keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-enter {
    from {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-enter {
    -webkit-animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-zoom-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

@keyframes rodal-zoom-leave {
    to {
        -webkit-transform: scale3d(.3, .3, .3);
        transform: scale3d(.3, .3, .3);
    }
}

.rodal-zoom-leave {
    -webkit-animation: rodal-zoom-leave both;
    animation: rodal-zoom-leave both;
}

/* -- slideDown -- */
@-webkit-keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-enter {
    from {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-enter {
    -webkit-animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideDown-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

@keyframes rodal-slideDown-leave {
    to {
        -webkit-transform: translate3d(0, -100px, 0);
        transform: translate3d(0, -100px, 0);
    }
}

.rodal-slideDown-leave {
    -webkit-animation: rodal-slideDown-leave both;
    animation: rodal-slideDown-leave both;
}

/* -- slideLeft -- */
@-webkit-keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-enter {
    from {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-enter {
    -webkit-animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideLeft-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

@keyframes rodal-slideLeft-leave {
    to {
        -webkit-transform: translate3d(-150px, 0, 0);
        transform: translate3d(-150px, 0, 0);
    }
}

.rodal-slideLeft-leave {
    -webkit-animation: rodal-slideLeft-leave both;
    animation: rodal-slideLeft-leave both;
}

/* -- slideRight -- */
@-webkit-keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-enter {
    from {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-enter {
    -webkit-animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-slideRight-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

@keyframes rodal-slideRight-leave {
    to {
        -webkit-transform: translate3d(150px, 0, 0);
        transform: translate3d(150px, 0, 0);
    }
}

.rodal-slideRight-leave {
    -webkit-animation: rodal-slideRight-leave both;
    animation: rodal-slideRight-leave both;
}

/* -- slideUp -- */
@-webkit-keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-enter {
    from {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-enter {
    -webkit-animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
    animation: rodal-slideUp-enter both cubic-bezier(0.23, 1, 0.32, 1);
}

@-webkit-keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

@keyframes rodal-slideUp-leave {
    to {
        -webkit-transform: translate3d(0, 100px, 0);
        transform: translate3d(0, 100px, 0);
    }
}

.rodal-slideUp-leave {
    -webkit-animation: rodal-slideUp-leave both;
    animation: rodal-slideUp-leave both;
}

/* -- flip -- */
@-webkit-keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

@keyframes rodal-flip-enter {
    from {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 60deg);
    }

    70% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }
}

.rodal-flip-enter {
    -webkit-animation: rodal-flip-enter both ease-in;
    animation: rodal-flip-enter both ease-in;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

@-webkit-keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

@keyframes rodal-flip-leave {
    from {
        -webkit-transform: perspective(400px);
        transform: perspective(400px);
    }

    30% {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
        transform: perspective(400px) rotate3d(1, 0, 0, -15deg);
    }

    to {
        -webkit-transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
        transform: perspective(400px) rotate3d(1, 0, 0, 45deg);
    }
}

.rodal-flip-leave {
    -webkit-animation: rodal-flip-leave both;
    animation: rodal-flip-leave both;
    -webkit-backface-visibility: visible !important;
    backface-visibility: visible !important;
}

/* -- rotate -- */
@-webkit-keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-enter {
    from {
        -webkit-transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, -180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-enter {
    -webkit-animation: rodal-rotate-enter both;
    animation: rodal-rotate-enter both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

@-webkit-keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

@keyframes rodal-rotate-leave {
    to {
        -webkit-transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
        transform: rotate3d(0, 0, 1, 180deg) scale3d(.3, .3, .3);
    }
}

.rodal-rotate-leave {
    -webkit-animation: rodal-rotate-leave both;
    animation: rodal-rotate-leave both;
    -webkit-transform-origin: center;
    transform-origin: center;
}

/* -- door -- */
@-webkit-keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

@keyframes rodal-door-enter {
    from {
        -webkit-transform: scale3d(0, 1, 1);
        transform: scale3d(0, 1, 1);
    }
}

.rodal-door-enter {
    -webkit-animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
    animation: rodal-door-enter both cubic-bezier(0.4, 0, 0, 1.5);
}

@-webkit-keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

@keyframes rodal-door-leave {
    60% {
        -webkit-transform: scale3d(.01, 1, 1);
        transform: scale3d(.01, 1, 1);
    }

    to {
        -webkit-transform: scale3d(0, 1, .1);
        transform: scale3d(0, 1, .1);
    }
}

.rodal-door-leave {
    -webkit-animation: rodal-door-leave both;
    animation: rodal-door-leave both;
}</style></head><body class=""><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;">
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(675,27,25,2,"web","https://baike.sogou.com/kexue/d11077.htm","20221025114527",1996,"/_static/",["/_static/css/banner-styles.css?v=S1zqJCYt","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT --><script>window._gtag=window._gtag||{};window._gtag.shouldGrayed = false;if ('1cb90366e2e64a4ca14f8db5b0ef42fe') window._gtag.traceId = '1cb90366e2e64a4ca14f8db5b0ef42fe';if ({"illegality":true}) window.userInfo = {"illegality":true};</script><div class="topnavbox"><ul class="topnav"><li><a href="https://web.archive.org/web/20221025114527/https://www.sogou.com/web?query=">网页</a></li><li><a href="https://web.archive.org/web/20221025114527/https://weixin.sogou.com/weixin?p=75351201">微信</a></li><li><a href="https://web.archive.org/web/20221025114527/https://zhihu.sogou.com/zhihu?p=75351218">知乎</a></li><li><a href="https://web.archive.org/web/20221025114527/https://pic.sogou.com/pics?query=">图片</a></li><li><a href="https://web.archive.org/web/20221025114527/https://v.sogou.com/v?query=">视频</a></li><li><a href="https://web.archive.org/web/20221025114527/https://mingyi.sogou.com/">医疗</a></li><li class="cur"><strong>科学</strong></li><li><a href="https://web.archive.org/web/20221025114527/https://hanyu.sogou.com/">汉语</a></li><li><a href="https://web.archive.org/web/20221025114527/https://wenwen.sogou.com/">问问</a></li><li><a href="https://web.archive.org/web/20221025114527/https://www.sogou.com/docs/more.htm">更多<span class="topraquo">»</span></a></li></ul></div><div id="header"><div class="header-wrap"><a class="header-logo" href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue"></a><div class="header-search"><div class="querybox" id="suggBox"><form><input id="searchInput" class="query" type="text" placeholder="搜科学领域专业百科词条" name="query" autocomplete="off" value=""><a href="javascript:;" class="query-search"></a></form></div></div><div class="header-rgt"><span class="btn-header-rgt btn-edit" id="editLemma">创建</span><div class="header-user no-login"></div></div></div></div><div class="fixed-placeholder" style="visibility:none"></div><div id="container" class=""><div class="content lemma-level1"><div class="detail-title" id="abstract-title"><h1>正则表达式</h1><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#!" class="detail-edit">编辑</a></div><div class="section_content" data-id="14996301821247770"><div class="text_img ed_imgfloat_right"><a class="ed_image_link" data-src="https://img01.sogoucdn.com/app/a/200698/sogou_science_5826" data-bigsrc="https://img01.sogoucdn.com/app/a/200698/sogou_science_5826?w=300&amp;h=173&amp;titlename=%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%20(?%3C%3D%5C.)%20%7B2,%7D(?%3D%5BA-Z%5D)%0A%20%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%A4%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E4%BD%86%E5%89%8D%E6%8F%90%E6%98%AF%E5%AE%83%E4%BB%AC%E7%9B%B4%E6%8E%A5%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8F%A5%E5%8F%B7%EF%BC%88.%EF%BC%89%E4%B9%8B%E5%90%8E%E5%92%8C%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E4%B9%8B%E5%89%8D" title="点击查看大图" data-w="300" data-h="173" style="background-image:url(https://web.archive.org/web/20221025114527im_/https://img01.sogoucdn.com/app/a/200698/sogou_science_5826)" href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#!"></a><div class="text_img_title">模式的匹配结果 (?&lt;=\.) {2,}(?=[A-Z])
 至少匹配两个空格，但前提是它们直接出现在句号（.）之后和大写字母之前</div></div><div><p></p> 
<p></p> 
<p></p> 
<p><b>正则表达式</b>, <b>regex</b> 或者 <b>regexp</b><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_1" class="kx_ref">[1]</a></sup> (有时称为<b>有理表达式</b>)<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_2" class="kx_ref">[2]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_3" class="kx_ref">[3]</a></sup>是定义<i>搜索 模式 的</i> 字符 序列。通常这种模式通过 字符串搜索算法用于字符串上的“查找”或“查找并替换”操作 ，或者用于输入验证。它是在 理论计算机科学 和 形式语言 理论中发展起来的一种技术。 </p>
<p>这个概念产生于20世纪50年代，当时美国数学家 斯蒂芬·科尔·克莱尼 <i>形式化了正规语言的描述</i>。这一概念和 Unix 文本处理实用程序一起开始被普遍使用。自20世纪80年代以来，存在着不同的用于编写正则表达式 语法 ，一种是 POSIX 标准，另一种是广泛使用的是 Perl 语法。 </p>
<p>正则表达式用于 搜索引擎、搜索和替换 文字处理器和 文本编辑器的对话框、文本处理实用程序（如 sed 和 AWK）和 词汇分析。许多 程序设计语言提供regex功能，内置或通过 库。 </p></div></div><div id="catalog"><h2 class="title2">目录<a href="javascript:" class="detail-edit">编辑</a></h2><div class="catalog_wrap" style=""><ul class="catalog_list col3"><li><span class="order">1</span><a href="javascript:" data-level="1" data-id="14996301821247771">模式</a></li><li><span class="order">2</span><a href="javascript:" data-level="1" data-id="14996301838024972">历史</a></li><li><span class="order">3</span><a href="javascript:" data-level="1" data-id="14996301838024973">基本概念</a></li><li><span class="order">4</span><a href="javascript:" data-level="1" data-id="14996301838024974">形式语言理论</a></li><li class="secondary_catalog"><span>4.1 </span><a href="javascript:" data-id="14996301838024974">正式定义</a></li><li class="secondary_catalog"><span>4.2 </span><a href="javascript:" data-id="14996301838024974">表达能力和紧凑性</a></li><li class="secondary_catalog"><span>4.3 </span><a href="javascript:" data-id="14996301838024974">判定正则表达式的等价性</a></li><li><span class="order">5</span><a href="javascript:" data-level="1" data-id="14996301838024975">语法</a></li></ul><ul class="catalog_list col3"><li class="secondary_catalog"><span>5.1 </span><a href="javascript:" data-id="14996301838024975">分隔符</a></li><li class="secondary_catalog"><span>5.2 </span><a href="javascript:" data-id="14996301838024975">标准</a></li><li class="secondary_catalog"><span>5.3 </span><a href="javascript:" data-id="14996301838024975">Perl和PCRE</a></li><li class="secondary_catalog"><span>5.4 </span><a href="javascript:" data-id="14996301838024975">懒惰匹配</a></li><li class="secondary_catalog"><span>5.5 </span><a href="javascript:" data-id="14996301838024975">占有匹配</a></li><li><span class="order">6</span><a href="javascript:" data-level="1" data-id="14996301854802176">非正则语言的模式</a></li><li><span class="order">7</span><a href="javascript:" data-level="1" data-id="14996301854802177">实现和运行时间</a></li><li><span class="order">8</span><a href="javascript:" data-level="1" data-id="14996301854802178">Unicode</a></li></ul><ul class="catalog_list col3"><li><span class="order">9</span><a href="javascript:" data-level="1" data-id="14996301854802179">使用</a></li><li><span class="order">10</span><a href="javascript:" data-level="1" data-id="14996301854802180">示例</a></li><li><span class="order">11</span><a href="javascript:" data-level="1" data-id="14996301871579400">归纳</a></li><li><span class="order">12</span><a href="javascript:" data-level="1" data-id="14996301871579401">笔记</a></li><li><span class="order">13</span><a href="javascript:" data-level="1" data-id="references">参考文献</a></li></ul></div></div><div id="paragraphs"><div><div id="par_14996301821247771"><h2 class="title">1 模式<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>短语<i>正则表达式，</i>因此<i>regexes</i>，通常是指特定的标准文本语法(不同于下面描述的数学符号),用于表示匹配文本的模式。正则表达式中的每个字符(即描述其模式的字符串中的每个字符)要么是 具有特殊意义的元字符，要么是具有字面意义的常规字符。例如，在正则表达式中 <code>a.</code>, <i>a</i> 是一个仅匹配‘a’的字面值字符，而‘.'是与除换行符以外的每个字符都匹配的元字符。因此，该正则表达式匹配，例如，'a'、'ax'或'a0'。元字符和字面值字符一起可以用来识别给定模式的文本，或者处理它的多个实例。模式匹配可能从精确相等到由元字符控制的非常概括性的相似性不等。例如， <code>.</code> 是一个非常概括性的模式， <code>[a-z]</code> (匹配从‘a’到‘z’的所有小写字母)不太概括， <code>a</code> 是一个精确的模式(只匹配“a”)。元字符语法是专为以简洁灵活的方式表示指定目标而设计的，以便于使用标准 ASCII 键盘键入的形式指导各种输入数据文本处理的自动化。 </p>
<p>这种语法中正则表达式的一个非常简单的例子是在 文字编辑器中定位以两种不同方式拼写的单词，正则表达式 <code>seriali[sz]e</code> 匹配“serialise”和“serialize”。通配符 也可以实现这一点，但它们在模式上的局限性更大，因为它们具有更少的元字符和简单的语言基础。 </p>
<p>通配符的通常上下文是在文件列表中通配相似的名称，而正则表达式通常用于模式匹配文本字符串的应用程序中。例如，正则表达式 <code class="mw-highlight" dir="ltr"><span class="o">^</span><span class="s">[ \t]</span><span class="o">+|</span><span class="s">[ \t]</span><span class="o">+$</span><span class="w"></span></code> 匹配行首或行尾多余的空格。匹配任何数字的高级正则表达式是 <code class="mw-highlight" dir="ltr"><span class="s">[+-]</span><span class="o">?(</span><span class="err">\</span><span class="nv">d</span><span class="o">+(</span><span class="err">\</span><span class="o">.</span><span class="err">\</span><span class="nv">d</span><span class="o">+)?|</span><span class="err">\</span><span class="o">.</span><span class="err">\</span><span class="nv">d</span><span class="o">+)(</span><span class="s">[eE][+-]</span><span class="o">?</span><span class="err">\</span><span class="nv">d</span><span class="o">+)?</span><span class="w"></span></code>。 </p> 
<p></p><p></p><div class="text_img ed_imgfloat_right">
            <a class="ed_image_link lazyLoad" data-src="https://img03.sogoucdn.com/app/a/200698/sogou_science_5828" data-bigsrc="" title="点击查看大图" href="javascript:" data-observer="true"></a>
            <div class="text_img_title">转换 Kleene星号(s* 表示 '零 个或多个s ')</div>   
        </div> <p></p><p></p> 
<p><b>正则表达式处理器</b> 将上述语法中的正则表达式转换为内部表示，该表示可以对表示要搜索的文本的字符串执行和匹配。一种可能的方法是 汤普森构造算法 ，构建一个 非确定有限自动机 (NFA)，然后使其成为确定性的，生成的确定性有限自动机 (DFA)在目标文本字符串上运行，以识别与正则表达式匹配的子字符串。图显示了从正则表达式 <code><i>s</i>*</code>获得的NFA方案 <code><i>N</i>(<i>s</i>*)</code> ，这里<i>s</i> 表示一个更简单的正则表达式，<code><i>N</i>(<i>s</i>*)</code>已经被 递归地 转换为NFA <i>N</i>（<i>s</i>)。 </p></div></div><div id="par_14996301838024972"><h2 class="title">2 历史<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式起源于1951年，当时数学家 斯蒂芬·科尔·克莱尼 使用他的名为<i>正则集合</i>的数学符号描述 正规语言。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_4" class="kx_ref">[4]</a></sup> 这些出现于 理论计算机科学，自动机理论 (计算模型)的子领域以及形式语言的描述和分类中。模式匹配 的其他早期实现包括 SNOBOL 语言，它不使用正则表达式，而是使用自己的模式匹配结构。 </p>
<p>正则表达式从1968年开始普遍使用，有两种用途:文本编辑器中的模式匹配<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_5" class="kx_ref">[5]</a></sup> 和编辑器中的词法分析。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_6" class="kx_ref">[6]</a></sup> 正则表达式以程序形式首次出现是在 肯·汤普森 将Kleene的符号构建到编辑器 QED 中，作为在文本文件匹配模式的一种手段 .<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_5" class="kx_ref">[5]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_7" class="kx_ref">[7]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_8" class="kx_ref">[8]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_9" class="kx_ref">[9]</a></sup> 为了提高速度，汤普森通过即时编译(JIT)在一台装有兼容分时操作系统的IBM 7094机器上实现了正则表达式匹配 ，这是JIT编译的一个重要早期示例。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_10" class="kx_ref">[10]</a></sup> 他后来将这一功能添加到了Unix编辑器中 ed，这最终导致了正则表达式的流行搜索工具 grep的使用(“grep”是一个源自ed编辑器中正则表达式搜索命令的单词: <code>g/<i>re</i>/p</code> 意思是“对正则表达式进行全局搜索和打印匹配行”<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_11" class="kx_ref">[11]</a></sup>)。大约在汤普森开发QED的同时，一组研究人员（包括 道格拉斯·罗斯 ）实现了一个基于正则表达式的工具， 该工具在编译器 设计中用于 词法分析。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_6" class="kx_ref">[6]</a></sup> </p>
<p>在20世纪70年代这些正则表达式的原始形式的许多变体在 贝尔实验室被用于 Unix<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_9" class="kx_ref">[9]</a></sup> 程序 ，包括 vi、lex、 sed 、AWK和 expr，以及在例如 Emacs的其他程序中。正则表达式随后被广泛的程序采用，这些早期形式在 1992年的POSIX.2 标准中被标准化。 </p>
<p>20世纪80年代在 Perl出现了更复杂的正则表达式，它最初源于 亨利·斯宾塞 (1986)写的一个正则表达式库，他后来为 Tcl写了一个 <i>高级正则表达式</i>的实现 。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_12" class="kx_ref">[12]</a></sup> Tcl库是一个具有改进性能特征的混合 NFA/DFA 实现。采用Spencer的Tcl正则表达式实现的软件项目包括 PostgreSQL。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_13" class="kx_ref">[13]</a></sup> Perl后来扩展了Spencer的原始库，增加了许多新特性，<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_14" class="kx_ref">[14]</a></sup> 但是在性能或 Unicode 处理方面还没有赶上Spencer的高级正则表达式实现。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_15" class="kx_ref">[15]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_16" class="kx_ref">[16]</a></sup> Perl 6 设计的部分工作是改进Perl的正则表达式集成，并增加它们的范围和能力，以允许 解析表达式语法的定义。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_17" class="kx_ref">[17]</a></sup> 结果是一种叫做 Perl 6规则 迷你语言 ，用于定义Perl 6语法，并为程序员提供该语言的工具。这些规则维护了Perl 5.x正则表达式的现有特性，但也允许通过子规则定义递归下降分析器的BNF风格。 </p>
<p>在文档和数据库建模的结构化信息标准中使用正则表达式始于20世纪60年代，并在20世纪80年代扩展，当时 ISO SGML (由ANSI“GCA 101-1983”引入）等行业标准得到了巩固。结构规范语言标准的核心由正则表达式组成。它的用法在DTD元素组语法中很明显。 </p>
<p>从1997年开始，菲利普·黑兹尔 开发了PCRE (Perl兼容正则表达式)，它试图模仿Perl的正则表达式功能，并被许多现代工具(包括 PHP 和 Apache HTTP 服务器）使用。 </p>
<p>如今，在编程语言、文本处理程序(特别是词法分析器lexers)、高级文本编辑器和一些其他程序中普遍支持正则表达式。正则表达式支持是许多编程语言（包括 Java 和 Python） 标准库 的一部分，并内置于其他语法中，包括Perl和 ECMAScript。正则表达式功能的实现通常被称为 <b>regex引擎</b>，许多库可供重用。 </p></div></div><div id="par_14996301838024973"><h2 class="title">3 基本概念<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式，通常称为 <b>模式</b>，是用于指定特定目的所需的字符串集的表达式。指定有限字符串集的一个简单方法是列出它的 元素 或者成员。然而，通常有更简洁的方法来指定所需的字符串集。例如，包含三个字符串“Handel”、“Händel”和“Haendel”的集合可以由 <b>模式</b> <code>H(ä|ae?)ndel</code>指定；我们说这种模式 <b>匹配</b> 三个字符串中的每一个。在大多数 形式中，如果存在至少一个与特定集合相匹配的正则表达式，那么就存在无限多的也与之匹配正则表达式——规范并不是唯一的。大多数形式提供以下操作来构造正则表达式。 </p> 
<dl>
 <dt>
  布尔“或”
 </dt> 
 <dd>
  竖线 分离选项。例如， 
  <code class="mw-highlight" dir="ltr"><span class="n">gray</span><span class="o">|</span><span class="n">grey</span></code> 可以匹配“gray”或“grey”。
 </dd> 
 <dt>
  分组
 </dt> 
 <dd>
  圆括号 用于定义运算符的范围和优先级 (以及其他用途)。例如， 
  <code>gray|grey</code> 和 
  <code class="mw-highlight" dir="ltr"><span class="n">gr</span><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="n">e</span><span class="p">)</span><span class="n">y</span></code> 是描述“gray”或“grey”集合的等价模式。
 </dd> 
 <dt>
  以数量表示
 </dt> 
 <dd>
  量词 之后 标记 (例如字符)或组指定允许前一个元素出现的频率。最常见的量词是 问号 
  <code>?</code>， 星号 
  <code>*</code> (源于 Kleene 星号)，以及 加号 
  <code>+</code> （Kleene加号)。 {| | style=" width:15px；垂直对齐:顶部；" | 
  <code><b>?</b></code> |问号表示问号前一个元素
  <i>出现零次或一次</i>。例如，
  <code>colou?r</code>匹配“color"和“colour”。 |- | style="垂直对齐:顶部；" | 
  <code><b>*</b></code> |星号表示星号前一个元素
  <i>出现零次或多次</i>。例如， 
  <code>ab*c</code> 匹配“ac”、“abc”、“abbc”、“abbc”等。 |- | style="垂直对齐:顶部；" | 
  <code><b>+</b></code> |加号表示加号前一个元素
  <i>出现一次或多次</i>。例如， 
  <code>ab+c</code> 匹配“abc”、“abbc”、“abbbc”等，但不匹配“ac”。 |- |
  <code><b>{n}</b></code>
  <sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_18" class="kx_ref">[18]</a></sup> |前面的项被匹配
  <i>n</i> 次。 |- |
  <code><b>{min,}</b></code>
  <sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_18" class="kx_ref">[18]</a></sup> |前面的项被匹配
  <i>min</i>次或者更多次。 |- |
  <code><b>{min,max}</b></code>
  <sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_18" class="kx_ref">[18]</a></sup> |前面的项被匹配至少
  <i>min</i>次，但不超过 
  <i>max</i> 次。|}
 </dd> 
 <dt>
  通配符
 </dt>
</dl> 
<p>通配符 <code><b>.</b></code> 匹配任何字符。例如， <code>a.b</code> 匹配任何包含一个“a”，然后是任何其他字符和一个“b”的字符串， a.*b 匹配任何包含一个“a”和后面包含一个“b”的字符串。 </p>
<p>这些结构可以组合起来形成任意复杂的表达式，就像可以从数字和运算符 <b>+</b>, <b>−</b>, <b>×</b>，<b>÷</b>中构造算术表达式一样。例如，<code>H(ae?|ä)ndel</code> 和 <code class="mw-highlight" dir="ltr"><span class="n">H</span><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="n">ae</span><span class="o">|</span><span class="n">ä</span><span class="p">)</span><span class="n">ndel</span></code> 都是匹配与前面示例相同字符串的有效模式，<code>H(ä|ae?)ndel</code>。 </p>
<p>正则表达式精确的 语法 因工具和程序语言而异。 </p></div></div><div id="par_14996301838024974"><h2 class="title">4 形式语言理论<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式在 形式语言理论中描述 正规语言。它们具有与正则语法相同的表达能力。 </p> 
<h3>4.1 <span>正式定义</span></h3> 
<p>正则表达式由常量（表示字符串集）和运算符（表示对这些集合的运算）组成。下面的定义是标准的，在大多数关于形式语言理论的教科书中也是如此。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_19" class="kx_ref">[19]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_20" class="kx_ref">[20]</a></sup> 给定一个有限的 字母表 Σ，以下常量被定义为正则表达式: </p> 
<ul>
 <li>（<i>空集</i>)∅表示集合∅.</li> 
 <li>（<i>空字符串</i>)ε表示只包含“空”字符串的集合，没有任何字符。</li> 
 <li>（<i>字面值字符</i>) <code>a</code> 在Σ表示只包含字符<i>a</i>的集合 。</li>
</ul> 
<p>给定正则表达式R和S，定义了以下对它们的操作以生成正则表达式: </p> 
<ul>
 <li>（<i>连接</i>) <i>RS</i>表示可以通过连接R中的一个字符串和S中的一个字符串来获得的字符串集。例如，让R = {"ab "，" c"}和S = {"d "，" ef"}。然后，RS = {"abd "，" abef "，" cd "，" cef"}。</li> 
 <li>（<i>间隔</i>) <i>R</i> | <i>S</i> 表示由<i>R</i>和<i>S</i> 描述的集合的并集 。例如，如果R={"ab "，" c"}，S={"ab "，" d "、" ef"}，表达式 R | <i>S</i> ={"ab "，" c "，" d "，" ef"}。</li> 
 <li>（<i>Kleene 星号</i>) <i>R</i>*表示由包含ε的<i>R</i>描述的集合的最小 超集 并且在字符串连接下是闭合的。这是所有字符串的集合，可以通过从R所描述的集合中连接任意有限数量(包括零)的字符串来生成。例如，{“0”，”1”} *是所有有限 二进制字符串(包括空字符串)的集合和{"ab "，" c"}* = {ε，" ab "，" c "，" abab "，" abc "，" cab "，" cc "，" ababab "，" abcab "，...}。</li>
</ul> 
<p>为了避免圆括号，假设Kleene星号具有最高优先级，然后是连接和间隔。如果没有歧义，圆括号可以省略。例如，<code>(ab)c</code> 可以写成 <code>abc</code>，和 <code>a|(b(c*))</code> 可以写成 <code>a|bc*</code>。许多教科书使用符号∪、+、或∨来代替竖线进行间隔。 </p>
<p><b>示例:</b> </p> 
<ul>
 <li><code>a|b*</code> 表示{ε, "a", "b", "bb", "bbb", ...}</li> 
 <li><code>(a|b)*</code> 表示除“a”和“b”以外没有符号的所有字符串的集合，包括空字符串: {ε, "a", "b", "aa", "ab", "ba", "bb", "aaa", ...}</li> 
 <li><code>ab*(c|ε)</code> 表示从“a”开始，然后是零个或多个“b”，最后可选的是一个“c”的一组字符串:{"a", "ac", "ab", "abc", "abb", "abbc", ...}</li> 
 <li><code>(0|(1(01*0)*1))*</code> 表示3的倍数的二进制数集合:{ ε, "0", "00", "11", "000", "011", "110", "0000", "0011", "0110", "1001", "1100", "1111", "00000", ... }</li>
</ul> 
<h3>4.2 <span>表达能力和紧凑性</span></h3> 
<p>正则表达式的正式定义是有意最小化的，并且避免定义 <code>?</code> 和 <code>+</code>—这些可以表达为: <code>a+</code> = <code>aa*</code>，和 <code>a?</code> = <code>(a|ε)</code>。有时候添加 求补 运算符，以给出一个 <i>广义正则表达式</i>；这里 <i>R<sup>c</sup></i> 匹配Σ*上不匹配<i>R</i>所有字符串。原则上，求补运算符是多余的，因为它不再赋予任何表达能力。但是，它可以使正则表达式更加简洁——从正则表达式中消除所有求补运算符会导致其长度的双倍指数爆炸。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_21" class="kx_ref">[21]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_22" class="kx_ref">[22]</a></sup> </p>
<p>从这个意义上说，正则表达式可以表达正则语言，确切地说是被确定有限自动机接受的语言类。然而，紧凑性有很大的不同。某些正则语言类只能由确定性有限自动机来描述，其大小以最短等价正则表达式的大小呈指数增长 。这里的标准例子是由字母表{a,b}上的所有字符串组成的语言<i>L<sub>k</sub></i> ，它的第<i>k</i>个到最后一个字母等于<i>a</i>。一方面，正则表达式由 （a|b)*a(a|b)(a|b)(a|b)描述 <i>L</i><sub>4</sub> 。 </p>
<p>将这种模式推广到 <i>L<sub>k</sub></i> 给出了表达式:<b>解析失败 (带SVG或PNG备选的MathML（建议用于现代的浏览器和辅助工具）：从服务器“/mathoid/local/v1/”返回无效的响应（“Math extension cannot connect to Restbase.”）：): {\displaystyle (a\mid b)^*a\underbrace{(a\mid b)(a\mid b)\cdots(a\mid b)}_{k-1\text{ times}}. \, }</b> </p>
<p>另一方面，众所周知，每个接受语言<i>L<sub>k</sub></i> 的确定有限自动机必须至少有2<sup><i>k</i></sup> 个状态。幸运的是，有一个从正则表达式到更一般的非确定有限自动机（NFAs)的简单映射，NFAs不会导致如此大规模的爆炸；因此，NFAs经常被用作正则语言的替代表示。NFAs是 乔姆斯基层次结构的3型语言的简单变体。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_19" class="kx_ref">[19]</a></sup> </p>
<p>相反，DFA很容易描述许多语言，而DFA却不容易被正则表达式描述。例如，确定给定 ISBN 的有效性需要计算整数基数11的模数，并且可以容易地用11态DFA来实现。然而，回答相同的可除性问题的正则表达式的长度至少为几兆字节。 </p>
<p>给定一个正则表达式， 汤普森构造算法 计算等价的非确定有限自动机。相反方向的转换由克莱尼算法实现。 </p>
<p>最后，值得注意的是，许多现实世界中的“正则表达式”引擎实现了形式语言理论意义上正则表达式无法描述的特性；相反，它们实现了<i>正则表达式</i>。 </p> 
<h3>4.3 <span>判定正则表达式的等价性</span></h3> 
<p>从上面的许多例子中可以看出，有多种方法可以构造正则表达式来获得相同的结果。 </p>
<p>有可能写一个 算法 对于两个给定的正则表达式，决定所描述的语言是否等价；该算法将每个表达式简化为 最小确定有限状态机，并确定它们是否是 同形的 (等价的)。 </p>
<p>正则表达式的代数定律可以通过Gischer的一种方法获得，这种方法最好通过一个例子来解释:为了检查(<i>X</i>+<i>Y</i>)<sup>*</sup> 和(<i>X</i><sup>*</sup> <i>Y</i><sup>*</sup>)<sup>*</sup> 对于所有正则表达式<i>X</i>, <i>Y</i>，表示相同的正则语言 ，检查特定正则表达式(<i>a</i>+<i>b</i>)<sup>*</sup> 和(<i>a</i><sup>*</sup> <i>b</i><sup>*</sup>)<sup>*</sup> 是否表示字母表Σ= {<i>a</i>,<i>b</i>}上的相同语言是必要且充分的。更一般地说，一个等式 <i>E</i>=<i>F</i> 在有变量的正则表达式项之间，当且仅当用不同符号常量替换的不同变量的实例化成立时才成立。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_23" class="kx_ref">[23]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_24" class="kx_ref">[24]</a></sup> </p>
<p>通过使用 Kleene星号 和 并集 寻找一个仍然完全表达的正则表达式有趣子集来消除冗余，但也许它们的使用可能会受到限制。这是一个令人惊讶的难题。尽管正则表达式很简单，但是没有办法将它们系统地重写为某种形式。过去公理的缺乏导致了 星高度问题。1991年， Dexter Kozen 公理化正则表达式作为 Kleene代数，使用等式和 霍恩条款 公理。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_25" class="kx_ref">[25]</a></sup> 早在1964年，Redko就已经证明了没有一组有限的纯等式公理可以描述正则语言的代数。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_26" class="kx_ref">[26]</a></sup> </p></div></div><div id="par_14996301838024975"><h2 class="title">5 语法<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式 <i>模式</i> 匹配目标<i>字符串</i>。该模式由 <i>原子</i>序列组成。原子是正则表达式模式中的单个点，它试图匹配目标字符串。最简单的原子是字面量，但是将模式的部分分组以匹配原子需要使用 <code>(&nbsp;)</code> 作为元字符。元字符有助于形成: <i>原子</i>； <i>量词</i> 告诉我们有多少原子(以及它是否是一个  )；一个逻辑“或”字符，它提供了一组选择；一个逻辑“非”字符，它否定了原子的存在；和反向引用来引用完整原子模式的先前原子。不是当字符串的所有原子都匹配时，而是当正则表达式中的所有模式原子都匹配时，才进行匹配。这个想法是让一个小的字符模式代表大量可能的字符串，而不是编译一个包含所有字面值可能性的大列表。 </p>
<p>根据正则表达式处理器的不同，大约有14个元字符，这些字符可能有也可能没有 字面的 字符含义，取决于上下文或它们是否“被转义”，即前面有一个 转义序列，在这种情况下是反斜杠 <code>\</code>。现代扩展正则表达式和POSIX扩展正则表达式使用元字符的频率超过了它们的字面含义，因此为了避免“反斜杠”或 倾斜牙签综合征 ，将元字符转义为字面模式是有意义的；但是首先，让四个括号元字符 <code>(&nbsp;)</code> 和 <code>{&nbsp;}</code> 是字面意思并“转义”这个通常的意思成为元字符更有意义。通用标准实现了两者。通常的元字符是 <code> {}[]()^$.|*+?</code> 和 <code>\</code>。转义后成为元字符的常见字符有 <code>dswDSW</code> 和 <code>N</code>。 </p> 
<h3>5.1 <span>分隔符</span></h3> 
<p>当在编程语言中输入正则表达式时，它们可能被表示为通常的字符串字面量，因此通常被引用；例如，这在C、Java和Python中很常见，其中正则表达式 <code>re</code> 输入为 <code>"re"</code>。然而，它们通常将斜杠作为分割符，如正则表达式 <code>re</code>写成<code>/re/</code>。这源于 ed, <code>/</code> 是用于搜索的编辑器命令，是一个表达式 <code>/re/</code> 可以用来指定一系列的行(匹配模式)，这些行可以与任一侧的其他命令相结合，最著名的是 <code>g/re/p</code> ，如 grep (“全局正则表达式版本”)，包含在大多数 基于Unix的操作系统，例如 Linux 发行版。类似的约定用于 sed，其中搜索和替换由 <code>s/re/replacement/</code> 给出和模式可以用逗号连接，以指定一系列行，如 <code>/re1/,/re2/</code>。这种用法因在 Perl中的使用而特别有名，它构成了语法中与普通字符串字面值不同的一部分。在某些情况下，例如sed和Perl，可以使用替代分隔符来避免与内容冲突，并避免必须转义内容中分隔符的出现。例如，在sed命令中 <code>s,/,X,</code> ，使用逗号作为分隔符，将替换一个 <code>/</code> 和一个 <code>X</code>。 </p> 
<h3>5.2 <span>标准</span></h3> 
<p>这 IEEE POSIX 标准有三组合规性:BRE(基本正则表达式)，<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_27" class="kx_ref">[27]</a></sup> ERE(扩展正则表达式）和SRE（简单正则表达式)。 不推荐使用SRE<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_28" class="kx_ref">[28]</a></sup> ，而赞成使用BRE，因为两者都提供向后兼容性。 </p>
<p>BRE和ERE一起工作。ERE添加了 <code>?</code>, <code>+</code>，和 <code>|</code>，它消除了转义元字符 <code>(&nbsp;)</code> 和 <code>{&nbsp;}</code>的需要，而其在BRE中是需要的。此外，只要遵守正则表达式的POSIX标准语法，就可以是，而且通常是，额外的语法来服务于特定的(但是符合POSIX)应用程序。虽然POSIX.2没有定义一些实现细节，但是BRE和ERE提供了一个“标准”，这个“标准”后来被作为许多工具的默认语法，其中BRE或ERE模式的选择通常是受支持的选项。例如，GNU grep有以下选项:“grep -E”代表ERE，“grep -G”代表BRE(默认)，而“grep -P”代表Perl正则表达式。 </p>
<p>Perl正则表达式已经成为de事实上的标准，拥有丰富而强大的原子表达式集。Perl没有“基本”或“扩展”级别。与在POSIX EREs中一样， <code>(&nbsp;)</code> 和 <code>{&nbsp;}</code> 除非转义，否则将被视为元字符；其他元字符仅基于上下文被认为是字面的或符号的。附加功能包括 , 回溯，命名捕获组，以及 递归模式。 </p> 
<p><strong>POSIX基础和扩展</strong></p> 
<p>在 POSIX 标准中，基本正则语法(<b>BRE</b>)要求 元字符 <code>(&nbsp;)</code> 和 <code>{&nbsp;}</code> 被指定为 <code>\(\)</code> 和 <code>\{\}</code>，而扩展正则语法(<b>ERE</b>)没有。 </p> 
<table class="wikitable"> 
 <tbody>
  <tr> 
   <th>元字符 </th> 
   <th>描 述 </th>
  </tr> 
  <tr> 
   <th><code>^</code> </th> 
   <td>匹配字符串中的起始位置。在基于行的工具中，它匹配任何行的起始位置。 </td>
  </tr> 
  <tr> 
   <th><code>.</code> </th> 
   <td>匹配任何单个字符（许多应用程序不包括换行符，确切地说哪些字符被视为换行符是风格-、字符编码和平台特定的，但可以安全地假定包含换行符）。在POSIX括号表达式中，点字符与字面值点匹配。例如，a.c匹配“abc”等，但[a.c]只匹配“a”、“.”或“c”。 </td>
  </tr> 
  <tr> 
   <th><code>[&nbsp;]</code> </th> 
   <td>括号表达式。匹配括号中包含的单个字符。例如， <code>[abc]</code>匹配“a”、“b”或“c”。 <code>[a-z]</code>指定与“a”到“z”之间的任何小写字母匹配的范围。这些形式可以混合使用：<code>[abcx-z]</code> 与“a”、“b”、“c”、“x”、“y”或“z”匹配，和 <code>[a-cx-z]</code>一样。 <p>如果<code>-</code> 字符是括号内的最后一个或第一个（如果在 <code>^</code>之后）字符，则将字符视为字面值字符： <code>[abc-]</code>，<code>[-abc]</code>。 请注意，不允许使用反斜杠转义。 如果字符 <code>]</code>是第一个（在 <code>^</code>后面）字符，则可以将其括在括号表达式中：<code>[]abc]</code>。 </p> </td>
  </tr> 
  <tr> 
   <th><code>[^&nbsp;]</code> </th> 
   <td>匹配不包含在括号内的单个字符。例如， <code>[^abc]</code>匹配除“a”、“b”或“c”以外的任何字符。 <code>[^a-z]</code> 匹配任何不是从“a”到“z”的小写字母的单个字符。同样，字面值字符和范围可以混合使用。 </td>
  </tr> 
  <tr> 
   <th><code>$</code> </th> 
   <td>匹配字符串的结束位置或字符串结尾换行符之前的位置。在基于行的工具中，它匹配任何行的结束位置。 </td>
  </tr> 
  <tr> 
   <th><code>( )</code> </th> 
   <td>定义标记的子表达式。括号内匹配的字符串可以稍后调用。标记的子表达式也称为块或捕获组。<b>BRE模式需要 <code>\( \)</code></b>。 </td>
  </tr> 
  <tr> 
   <th><code>\<i>n</i></code> </th> 
   <td>匹配第n个标记的子表达式所匹配的内容，其中n是1到9之间的数字。这个构造在posix.2标准中模糊地被定义。有些工具允许引用9个以上的捕获组。 </td>
  </tr> 
  <tr> 
   <th><code>*</code> </th> 
   <td>与前面的元素匹配零次或多次。例如， <code>ab*c</code> 匹配"ac"、 "abc"、 "abbbc"等。 <code>[xyz]*</code> 匹配""、"x"、 "y"、"z"、 "zx"、 "zyx"、 "xyzzy"等。 <code>(ab)*</code> 匹配""、 "ab"、"abab"、"ababab"等。 </td>
  </tr> 
  <tr> 
   <th><code>{<i>m</i>,<i>n</i>}</code> </th> 
   <td>与前面的元素匹配至少<i>m</i>次，但不超过<i>n</i>次。例如， <code>a{3,5}</code> 仅匹配 "aaa"、 "aaaa"和"aaaaa"。在一些旧版本的正则表达式中找不到。<b>BRE模式需要 <code><span class="nowrap">\{<i>m</i>,<i>n</i>\</span>}</code></b>. </td>
  </tr>
 </tbody>
</table> 
<p><b>示例:</b> </p> 
<ul>
 <li><code>.at</code> 匹配任何以“at”结尾的三个字符的字符串，包括“hat”、“cat”和“bat”。</li> 
 <li><code>[hc]at</code> 匹配“hat”和“cat”。</li> 
 <li><code>[^b]at</code> 匹配所有可以由 <code>.at</code>匹配的字符串， 除了“bat”。</li> 
 <li><code>[^hc]at</code> 匹配所有可以由 <code>.at</code>匹配的字符串，除了“hat”和“cat”。</li> 
 <li><code>^[hc]at</code> 匹配“hat”和“cat”，但仅在字符串或行首。</li> 
 <li><code>[hc]at$</code> 匹配“hat”和“cat”，但仅在字符串或行尾。</li> 
 <li><code>\[.\]</code> 匹配由“[”和“]”包围的任何单个字符，因为括号是被转义的，例如:“[a]”和“[b]”。</li> 
 <li><code>s.*</code> 匹配后跟零个或多个字符的s，例如:“s”、“saw”和“seed”。</li>
</ul> 
<p><strong>POSIX扩展</strong></p> 
<p>在POSIX扩展正则表达式(<b>ERE</b>)语法中，对于某些字符，使用反斜杠转义的元字符的含义是相反的。使用这种语法，反斜杠会导致元字符被视为字面值字符。比如说， <code>\(&nbsp;\)</code> 现在是 <code>(&nbsp;)</code> 和 <code>\{&nbsp;\}</code> 现在是 <code>{&nbsp;}</code>。此外，将移除对 <code>\<i>n</i></code> 反向引用的支持，并添加以下元字符: </p> 
<table class="wikitable"> 
 <tbody>
  <tr> 
   <th>元字符 </th> 
   <th>描述 </th>
  </tr> 
  <tr> 
   <th><code>?</code> </th> 
   <td>匹配前面的元素零次或一次。例如， <code>ab?c</code> 只匹配 "ac" 或 "abc"。 </td>
  </tr> 
  <tr> 
   <th><code>+</code> </th> 
   <td>匹配前面的元素一次或多次。例如， <code>ab+c</code> 匹配 "abc", "abbc", "abbbc"等， 但不匹配"ac". </td>
  </tr> 
  <tr> 
   <th><code>|</code> </th>
   <td>选择（也称为间隔或并集）运算符匹配运算符之前的表达式或运算符之后的表达式。例如， <code>abc|def</code> 匹配 "abc" 或 "def".</td> 
  </tr>
 </tbody>
</table> 
<p><b>示例:</b> </p> 
<ul>
 <li><code>[hc]?at</code> 匹配“at”、“hat”和“cat”。</li> 
 <li><code>[hc]*at</code> 匹配"at"、"hat"、"cat"、 "hhat"、 "chat"、 "hcat"、"cchchat"等。</li> 
 <li><code>[hc]+at</code> 匹配"hat"、"cat" 、"hhat"、 "chat"、"hcat"、 "cchchat"等，但不匹配“at”。</li> 
 <li><code>cat|dog</code> 匹配"cat" or "dog"。</li>
</ul> 
<p>通过包含 命令行标志-E，POSIX扩展正则表达式通常可以与现代Unix实用程序一起使用。 </p> 
<p><strong>字符类</strong></p> 
<p>字符类是字面值匹配后最基本的正则表达式概念。它使一个小的字符序列与一组大的字符相匹配。例如， <code class="mw-highlight" dir="ltr"><span class="s">[A-Z]</span><span class="w"></span></code> 代表大写字母，并且 <code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">d</span><span class="w"></span></code> 可能意味着任何数字。字符类适用于两种POSIX级别。 </p>
<p>指定字符范围时，例如 <code class="mw-highlight" dir="ltr"><span class="s">[a-Z]</span><span class="w"></span></code> (即小写 <i><code class="mw-highlight" dir="ltr"><span class="nv">a</span><span class="w"></span></code></i>到大写 <i><code class="mw-highlight" dir="ltr"><span class="nv">z</span><span class="w"></span></code></i>)，计算机的区域设置通过字符编码的数字顺序来确定内容。他们可以存储序列中的数字，或者顺序可以是 <i>abc…zABC…Z</i>，或 <i>aAbBcC…zZ</i>。因此POSIX标准定义了一个字符类，它将被安装的regex处理器所知。这些定义见下表: </p> 
<table class="wikitable sortable"> 
 <tbody>
  <tr> 
   <th>POSIX</th> 
   <th>Non-standard</th> 
   <th>Perl/Tcl</th> 
   <th>Vim</th> 
   <th>Java</th> 
   <th>ASCII</th> 
   <th>描述 </th>
  </tr> 
  <tr> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:ascii:]</span><span class="w"></span></code><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_29" class="kx_ref">[29]</a></sup> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">ASCII</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[\x00-\x7F]</span><span class="w"></span></code> </td> 
   <td>ASCII 字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:alnum:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Alnum</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[A-Za-z0-9]</span><span class="w"></span></code> </td> 
   <td>字母和数字字符 </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:word:]</span><span class="w"></span></code><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_29" class="kx_ref">[29]</a></sup> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">w</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">w</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">w</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[A-Za-z0-9_]</span><span class="w"></span></code> </td> 
   <td>字母和数字字符加上 "_" </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">W</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">W</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">W</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[^A-Za-z0-9_]</span><span class="w"></span></code> </td> 
   <td>非单词字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:alpha:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">a</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Alpha</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[A-Za-z]</span><span class="w"></span></code> </td> 
   <td>字母和数字字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:blank:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">s</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Blank</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[ \t]</span><span class="w"></span></code> </td> 
   <td>空格和水平制表符 </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">b</span><span class="w"></span></code> </td> 
   <td><code>\&lt; \&gt;</code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">b</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="o">(?</span><span class="err">&lt;</span><span class="o">=</span><span class="err">\</span><span class="nv">W</span><span class="o">)(?=</span><span class="err">\</span><span class="nv">w</span><span class="o">)|(?</span><span class="err">&lt;</span><span class="o">=</span><span class="err">\</span><span class="nv">w</span><span class="o">)(?=</span><span class="err">\</span><span class="nv">W</span><span class="o">)</span><span class="w"></span></code> </td> 
   <td>单词边界 </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">B</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="o">(?</span><span class="err">&lt;</span><span class="o">=</span><span class="err">\</span><span class="nv">W</span><span class="o">)(?=</span><span class="err">\</span><span class="nv">W</span><span class="o">)|(?</span><span class="err">&lt;</span><span class="o">=</span><span class="err">\</span><span class="nv">w</span><span class="o">)(?=</span><span class="err">\</span><span class="nv">w</span><span class="o">)</span><span class="w"></span></code> </td> 
   <td>非单词边界 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:cntrl:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Cntrl</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[\x00-\x1F\x7F]</span><span class="w"></span></code> </td> 
   <td>控制字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:digit:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">d</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">d</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Digit</span><span class="p">}</span><span class="w"></span></code> or <code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">d</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[0-9]</span><span class="w"></span></code> </td> 
   <td>十进制数字 </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">D</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">D</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">D</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[^0-9]</span><span class="w"></span></code> </td> 
   <td>非十进制数字 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:graph:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Graph</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[\x21-\x7E]</span><span class="w"></span></code> </td> 
   <td>可见字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:lower:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">l</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Lower</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[a-z]</span><span class="w"></span></code> </td> 
   <td>小写字母 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:print:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Print</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[\x20-\x7E]</span><span class="w"></span></code> </td> 
   <td>可见字符和空格字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:punct:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Punct</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[][!"#$%&amp;'()*+,./:;&lt;=&gt;?@\^_`{|}~-]</span><span class="w"></span></code> </td> 
   <td>标点符号 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:space:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">s</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">_s</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Space</span><span class="p">}</span><span class="w"></span></code> or <code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">s</span><span class="w"></span></code> </td> 
   <td><code>[ ]</code> </td> 
   <td>空白字符 </td>
  </tr> 
  <tr> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">S</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">S</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">S</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[^ \t\r\n\v\f]</span><span class="w"></span></code> </td> 
   <td>非空白字符 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:upper:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">u</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">Upper</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[A-Z]</span><span class="w"></span></code> </td> 
   <td>大写字母 </td>
  </tr> 
  <tr> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[:xdigit:]</span><span class="w"></span></code> </td> 
   <td> </td> 
   <td> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">x</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">p</span><span class="p">{</span><span class="x">XDigit</span><span class="p">}</span><span class="w"></span></code> </td> 
   <td><code class="mw-highlight" dir="ltr"><span class="s">[A-Fa-f0-9]</span><span class="w"></span></code> </td> 
   <td>十六进制数字 </td>
  </tr>
 </tbody>
</table> 
<p>POSIX字符类只能在括号表达式中使用。例如， <code class="mw-highlight" dir="ltr"><span class="s">[[:upper:]</span><span class="nv">ab</span><span class="err">]</span><span class="w"></span></code> 匹配大写字母和小写字母“a”和“b”。 </p>
<p>某些工具理解的另一个非POSIX类是 <code class="mw-highlight" dir="ltr"><span class="s">[:word:]</span><span class="w"></span></code>，通常定义为 <code class="mw-highlight" dir="ltr"><span class="s">[:alnum:]</span><span class="w"></span></code> 加下划线。这反映了这样一个事实，即在许多编程语言中，这些字符可以用在标识符中。编辑 Vim 进一步区分 <i>word</i> 和 <i>word-head</i> 类(使用符号 <code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">w</span><span class="w"></span></code> 和 <code class="mw-highlight" dir="ltr"><span class="err">\</span><span class="nv">h</span><span class="w"></span></code>)因为在许多编程语言中，可以开始一个标识符的字符与可以出现在其他位置的字符不同。 </p>
<p>请注意POSIX正则表达式标准所称的 <i>字符类</i> 通常在其他支持它们的正则表达式风格被称为 <i>POSIX字符类</i> 。对于大多数其他正则表达式风格，术语 <i>字符类</i> 用于描述POSIX所称的<i>括号表达式</i>。 </p> 
<h3>5.3 <span>Perl和PCRE</span></h3> 
<p>由于它的表达能力和(相对)易读性，许多其他实用程序和编程语言都采用了类似于Perl的语法——例如， Java、 JavaScript、 Julia、 Python、 Ruby、 Qt、 微软 的 .NET框架、和 XML模式。一些语言和工具，例如 Boost 和 PHP 支持多种正则表达式风格。Perl派生正则表达式的实现并不相同，通常实现1994年发布的Perl 5.0中的一部分特性，Perl有时会包含了最初在其他语言中发现的特性，例如，Perl 5.10实现了最初在 PCRE和Python中开发的语法扩展。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_30" class="kx_ref">[30]</a></sup> </p> 
<h3>5.4 <span>懒惰匹配</span></h3> 
<p>Python和一些其他实现方式(例如，Java)，三个常用量词(<code>*</code>, <code>+</code> 和 <code>?</code>)默认是贪婪的， 因为它们匹配尽可能多的字符。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_31" class="kx_ref">[31]</a></sup> 正则表达式 <code>".+"</code> (包括双引号)应用于字符串 </p> 
<pre class="kx_code">"Ganymede," he continued, "is the largest moon in the Solar System."
</pre> 
<p>匹配整行(因为整行以双引号开始和结束),而不是只匹配第一部分， <code>"Ganymede,"</code>。然而，通过添加问号: <code>".+?"</code> ，来匹配尽可能少的字符，上述量词 可能会变得<i>懒惰</i> 或者<i>最小</i>或者<i>不情愿</i>，仅匹配 <code>"Ganymede,"</code>。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_31" class="kx_ref">[31]</a></sup> </p>
<p>然而，在某些情况下，整个句子仍然可以匹配。问号运算符不会改变点运算符的含义，因此它仍然可以匹配输入中的双引号。像这样的模式 <code>".*?" EOF</code> 如果这是字符串，将仍然匹配整个输入: </p> 
<pre class="kx_code">"Ganymede," he continued, "is the largest moon in the Solar System." EOF
</pre> 
<p>为了确保双引号不成为匹配的一部分，必须替换点，例如: <code>"[^"]*"</code> 这将匹配引用的文本部分，其中没有附加双引号。 </p> 
<h3>5.5 <span>占有匹配</span></h3> 
<p>在Java中，通过在量词后面加上一个加号，可以使量词变为<i>占有的</i> ，这会禁止后退，即使这样做会使整个匹配成功:<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_32" class="kx_ref">[32]</a></sup> 当正则表达式 <code>".*"</code> 应用于字符串 </p> 
<pre class="kx_code">"Ganymede," he continued, "is the largest moon in the Solar System."
</pre> 
<p>匹配整行，正则表达式 <code>".*+"</code> 根本没有匹配，因为 <code>.*+</code> 消耗整个输入，包括最后的<code>"</code>。因此，占有量词对负字符类最有用 ，例如，当应用于同一字符串时，<code>"[^"]*+"</code>匹配 <code>"Ganymede,"</code>。 </p>
<p>占有量词比贪婪量词和懒惰量词更容易实现，并且通常在运行时效率更高。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_32" class="kx_ref">[32]</a></sup> </p></div></div><div id="par_14996301854802176"><h2 class="title">6 非正则语言的模式<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>几乎所有现代正则表达式库中的许多特性都提供了远远超过 正则语言的表达能力。例如，许多实现允许用括号将子表达式分组，并在同一表达式（反向引用）中回忆它们匹配的值。这意味着，除了别的以外，一个模式可以匹配重复单词的字符串，如“papa”或“WikiWiki”，在形式语言理论中叫做 <i>squares</i> 。这些字符串的模式是 <code>(.+)\1</code>。 </p>
<p>由于 泵引理，正方形的语言不规则，也不是 上下文无关。然而，在众多现代工具的支持下，模式匹配与无限数量的反向引用仍然是 上下文敏感的。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_33" class="kx_ref">[33]</a></sup> </p>
<p>然而，许多提供这种结构的工具、库和引擎仍然使用这个术语 <i>正规表达式</i> 作为其模式。这导致了一种命名法，在 形式语言理论和模式匹配中，术语正则表达式具有不同的含义。出于这个原因，有些人已经习惯使用这个术语 <i>regex</i>, <i>regexp</i>，或者简单的<i>模式</i> 来描述后者。Perl编程语言的作者 拉里·沃尔在一篇关于Perl 6设计的文章中写道: </p> 
<p>"Regular expressions" […] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I'm not going to try to fight linguistic necessity here. I will, however, generally call them "regexes" (or "regexen", when I'm in an Anglo-Saxon mood).<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_17" class="kx_ref">[17]</a></sup> </p></div></div><div id="par_14996301854802177"><h2 class="title">7 实现和运行时间<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>至少有三种不同的算法决定给定正则表达式是否匹配字符串以及如何匹配字符串。 </p>
<p>在形式语言理论中，一个结果上的最古老和最快的依赖是允许每个非确定有限自动机 (NFA)被转换为确定性有限自动机 (DFA)。DFA可以被显式构建，然后在生成的输入字符串上一次运行一个符号。为大小为m的一个正则表达式构造DFA的时间和内存开销<i>O</i>(2<sup><i>m</i></sup>)，但它可以在时间o（n）内运行在大小为n的字符串上。 </p>
<p>另一种方法是直接模拟NFA，本质上是按需构建每个DFA状态，然后在下一步丢弃它。这保持了DFA的隐式性，避免了指数级的构建成本，但运行成本上升到 <i>O</i>（<i>mn</i>)。显式方法被称为DFA算法，隐式方法被称为NFA算法。将缓存添加到NFA算法中通常被称为“懒惰DFA”算法，或者只是没有区别的DFA算法。这些算法速度很快，但是使用它们来调用分组的子表达式、懒惰量词和类似的特征是很棘手的。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_34" class="kx_ref">[34]</a></sup><sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_35" class="kx_ref">[35]</a></sup> </p>
<p>第三种算法是通过回溯将模式与输入字符串进行匹配。这种算法通常被称为NFA，但这个术语可能会令人困惑。它的运行时间可以是指数级的，当与包含交替和无界量化的表达式（如 <code class="mw-highlight" dir="ltr"><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">b</span></code>）匹配时，简单的实现显示出来，并迫使算法考虑数量呈指数增长的子情况。这种行为会导致称为正则表达式拒绝服务 (ReDoS)的安全问题。 </p>
<p>尽管回溯实现仅在最坏的情况下提供指数保证，但它们提供了更大的灵活性和表达能力。例如，任何允许使用回溯的实现，或者实现Perl引入的各种扩展，都必须包括某种回溯。一些实现<sup class="noprint">[哪个／哪些？]</sup> 尝试通过首先运行一个快速DFA算法来提供两种算法中的最佳算法，并且只有在匹配过程中遇到反向引用时，才恢复到可能较慢的回溯算法。 </p></div></div><div id="par_14996301854802178"><h2 class="title">8 Unicode<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>从理论上讲，任何标记集只要是预定义的，都可以通过正则表达式匹配。就历史实现而言，正则表达式最初是用ASCII字符作为标记集编写的，尽管正则表达式库支持许多其他的字符集。许多现代正则表达式引擎至少提供了对 Unicode 的一些支持。在大多数方面，字符集并没有什么区别，但是当扩展正则表达式以支持Unicode时，确实会出现一些问题。 </p> 
<ul>
 <li><b>支持的编码</b>。一些正则表达式库期望在某些特定的编码上，而不是抽象的Unicode字符上工作。其中许多要求 UTF-8 编码，而其他人可能会期望UTF-16或 UTF-32。相比之下，Perl和Java在编码上是不可知的，而是在内部对解码的字符进行操作。</li> 
 <li><b>支持的Unicode范围</b>。许多正则表达式引擎只支持 基本多语言平面，即只能用16位编码的字符。目前(截至2016年)，只有少数正则表达式引擎(如Perl和Java)可以处理全部21位Unicode范围。</li> 
 <li><b>将面向ASCII的结构扩展到Unicode</b>。例如，在基于ASCII的实现中，如果x和y的代码点在[0x00,0x7f]范围内且代码点（x）≤代码点（y），则形式为<code>[x-y]</code>的字符范围有效。这种字符范围自然扩展到Unicode将端点位于[0x00，0x7F]的要求更改为端点位于[0x0000，0x10FFFF]的要求。然而，实际上情况往往并非如此。某些实现，例如 gawk的实现，不允许字符范围跨越Unicode块。像[0x61，0x7F]这样的范围是有效的，因为两个端点都在基本拉丁文块内，像[0x0530，0x0560]一样，因为两个端点都在亚美尼亚语块内，但是im像[0x0061，0x0532]这样的范围是无效的，因为它包括多个Unicode块。其他引擎，如 Vim 编辑器，允许块交叉，但字符值之间的间隔不得超过256。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_36" class="kx_ref">[36]</a></sup></li> 
 <li><b>不区分大小写</b>。一些不区分大小写的标志只影响ASCII字符。其他标志影响所有字符。一些引擎有两个不同的标志，一个用于ASCII，另一个用于Unicode。到底哪些字符属于POSIX类也各不相同。</li> 
 <li><b>不区分大小写的表亲</b>。由于ASCII具有区分大小写的特性，不区分大小写成为文本搜索中的一个逻辑特征。Unicode引入了不区分大小写的字母脚本 Devanagari。对于这些， 区分大小写不适用。对于像中文这样的文字，另一个区别看似合乎逻辑:传统和简化之间。在阿拉伯文字中，可能需要对 初始、中间、最终和孤立位置 不敏感。在日语中，平假名 和 片假名 之间的不敏感有时是有用的。</li> 
 <li><b>正常化</b>。Unicode具有 组合字符。像旧打字机一样，普通字母后面可以跟随一个或多个非间隔符号(通常是音调符号，如重音符号)，以形成单个打印字符，但也提供预先组合的字符，即已经包括一个或多个组合字符的字符。字符序列+组合字符序列应该与相同的单个预组合字符相匹配。标准化字符序列+组合字符序列的过程被称为标准化。</li> 
 <li><b>新的控制代码</b>。其中引入了Unicode，字节顺序标记和文本方向标记。这些代码可能必须以特殊的方式处理。</li> 
 <li><b>Unicode块、文字系统和许多其他字符属性的字符类介绍</b>。块属性远不如文字系统属性有用，因为一个块可以有来自几个不同文字系统的代码点，而一个文字系统可以有来自几个不同块的代码点。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_37" class="kx_ref">[37]</a></sup> 在 Perl 还有 <code></code> 库，形式 <code>\p{InX}</code> 或者 <code>\p{Block=X}</code> 的属性匹配块中的字符<i>X</i> 和 <code>\P{InX}</code> 或者 <code>\P{Block=X}</code> 匹配不在该块中的代码点。同样地， <code>\p{Armenian}</code>, <code>\p{IsArmenian}</code>或 <code>\p{Script=Armenian}</code> 匹配亚美尼亚文字系统中的任何字符。总的来说， <code>\p{X}</code> 匹配任何具有二进制属性的字符 <i>X</i> 或一般类别 <i>X</i>。例如， <code>\p{Lu}</code>, <code>\p{Uppercase_Letter}</code>或 <code>\p{GC=Lu}</code> 匹配任意大写字母。二进制属性是 <i>不</i> 一般类别包括 <code>\p{White_Space}</code>, <code>\p{Alphabetic}</code>, <code>\p{Math}</code>，和 <code>\p{Dash}</code>。非二进制属性的例子有 <code>\p{Bidi_Class=Right_to_Left}</code>, <code>\p{Word_Break=A_Letter}</code>和 <code>\p{Numeric_Value=10}</code>。</li>
</ul></div></div><div id="par_14996301854802179"><h2 class="title">9 使用<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式在各种各样的 文本处理 任务中很有用，更一般地是字符串处理，其中数据不必是文本的。常见应用程序包括 数据验证、 数据抓取 (尤其是 网页抓取)、 数据打包、简单 解析、 语法突出显示系统的生成和许多其他任务。 </p>
<p>虽然正则表达式在互联网搜索引擎上很有用，但在整个数据库中处理它们可能会消耗过多的计算机资源，这取决于正则表达式的复杂性和设计。尽管在许多情况下，系统管理员可以在内部运行基于正则表达式的查询，但大多数搜索引擎不向公众提供正则表达式支持。值得注意的例外: 谷歌代码搜索, Exalead。谷歌代码搜索已于2012年1月关闭。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_38" class="kx_ref">[38]</a></sup> 它使用Trigram索引来加速查询。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_39" class="kx_ref">[39]</a></sup> </p></div></div><div id="par_14996301854802180"><h2 class="title">10 示例<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>具体的语法规则因具体的实现，编程语言，或使用的 库 而异。此外，正则表达式实现的功能在不同 版本之间可能有所不同。 </p>
<p>因为如果没有示例，正则表达式很难解释和理解，所以测试正则表达式的交互式网站是通过实验学习正则表达式的有用资源。本节通过示例的方式提供了正则表达式的一些属性的基本描述。 </p>
<p>示例中使用了以下约定。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_40" class="kx_ref">[40]</a></sup> </p> 
<pre class="kx_code">metacharacter(s)；；元字符列指定正在演示的正则表达式语法
=~ m//           ；；指Perl中的正则表达式<b>匹配</b>操作
=~ s//          ；；指Perl中的正则表达式<b>代替</b>操作
</pre> 
<p>同样值得注意的是，这些正则表达式都是类似Perl的语法。标准  正则表达式是不同的。 </p>
<p>除非另有说明，以下示例符合 Perl 编程语言，5.8.8版，2006年1月31日。这意味着其他实现可能缺乏对这里所示语法的某些部分的支持(例如，基本正则表达式 vs. 扩展正则表达式， <code>\( \)</code> vs . <code>()</code>，或缺乏的 <code>\d</code> 代替 POSIX <code>[:digit:]</code>)。 </p>
<p>这些示例中使用的语法和约定也与其他编程环境一致。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_41" class="kx_ref">[41]</a></sup> </p> 
<div class="shadow-tb show-rgt"><table class="wikitable"> 
 <tbody>
  <tr> 
   <th>Meta-<br>character(s) </th> 
   <th>描述 </th> 
   <th>示例<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_42" class="kx_ref">[42]</a></sup> </th>
  </tr> 
  <tr> 
   <th><code>.</code> </th> 
   <td>通常匹配除换行符之外的任何字符。 <p>在方括号内，点是字面值。 </p> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/...../) {
  print "$string1 has length &gt;= 5.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 has length &gt;= 5.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>( )</code> </th> 
   <td>将一系列模式元素分组到单个元素。 <p>当您在括号内匹配一个模式时，您可以使用$1，$2，……后面参考先前匹配的模式。 </p> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/(H..).(o..)/) {
  print "We matched '$1' and '$2'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">We matched 'Hel' and 'o W'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>+</code> </th> 
   <td>匹配前面的模式元素一次或多次。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/l+/) {
  print "There are one or more consecutive letter \"l\"'s in $string1.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There are one or more consecutive letter "l"'s in Hello World.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>?</code> </th> 
   <td>匹配前面的模式元素零次或一次。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/H.?e/) {
  print "There is an 'H' and a 'e' separated by ";
  print "0-1 characters (e.g., He Hue Hee).\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There is an 'H' and a 'e' separated by 0-1 characters (e.g., He Hue Hee).
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>?</code> </th> 
   <td>修改*, +,&nbsp;?或者前面出现的{M,N}正则表达式，以尽可能少的匹配。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/(l.+?o)/) {
  print "The non-greedy match with 'l' followed by one or\n";
  print "more characters is 'llo' rather than 'llo Wo'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">The non-greedy match with 'l' followed by one or
more characters is 'llo' rather than 'llo Wo'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>*</code> </th> 
   <td>匹配前面的模式元素零次或多次。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/el*o/) {
  print "There is an 'e' followed by zero to many ";
  print "'l' followed by 'o' (e.g., eo, elo, ello, elllo).\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There is an 'e' followed by zero to many 'l' followed by 'o' (e.g., eo, elo, ello, elllo).
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>{M,N}</code> </th> 
   <td>表示最小M和最大N匹配计数。<br>N可以省略，M可以是0： <code>{M}</code> 精确匹配M 次; <code>{M,}</code> 匹配至少M次; <code>{0,N}</code> 最多匹配N次。<br><code>x* y+ z?</code>因此等价于<code>x{0,} y{1,} z{0,1}</code>。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/l{1,2}/) {
  print "There exists a substring with at least 1 ";
  print "and at most 2 l's in $string1\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There exists a substring with at least 1 and at most 2 l's in Hello World
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>[…]</code> </th> 
   <td>表示一组可能的字符匹配。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/[aeiou]+/) {
  print "$string1 contains one or more vowels.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 contains one or more vowels.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>|</code> </th> 
   <td>分开备选 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/(Hello|Hi|Pogo)/) {
  print "$string1 contains at least one of Hello, Hi, or Pogo.";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 contains at least one of Hello, Hi, or Pogo.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\b</code> </th> 
   <td>在一个单词类字符和非单词类字符或一个边界之间匹配一个零宽度边界; 和<code>(^\w|\w$|\W\w|\w\W)</code>一样。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/llo\b/) {
  print "There is a word that ends with 'llo'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There is a word that ends with 'llo'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\w</code> </th> 
   <td>匹配一个包括"_"的字母数字字符；与ASCII中的 <code>[A-Za-z0-9_]</code> , Unicode中的 
    <dl>
     <dd>
      <code>[\p{Alphabetic}<wbr>\p{GC=Mark}<wbr>\p{GC=Decimal_Number}<wbr>\p{GC=Connector_Punctuation}]相同</code>,
      <sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_37" class="kx_ref">[37]</a></sup> 其中
      <code>Alphabetic</code> 属性包含多个拉丁字母， 
      <code>Decimal_Number</code> 属性包含多个阿拉伯数字。
     </dd>
    </dl> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/\w/) {
  print "There is at least one alphanumeric ";
  print "character in $string1 (A-Z, a-z, 0-9, _).\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There is at least one alphanumeric character in Hello World
 (A-Z, a-z, 0-9, _).
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\W</code> </th> 
   <td>匹配一个包括"_"的非字母数字字符；与ASCII中的 <code>[^A-Za-z0-9_]</code> , Unicode中的 
    <dl>
     <dd>
      <code>[^\p{Alphabetic}<wbr>\p{GC=Mark}<wbr>\p{GC=Decimal_Number}<wbr>\p{GC=Connector_Punctuation}]</code>
     </dd> 
     <dd>
      相同。
     </dd>
    </dl> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/\W/) {
  print "The space between Hello and ";
  print "World is not alphanumeric.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">The space between Hello and World is not alphanumeric.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\s</code> </th> 
   <td>匹配空白字符， <p>ASCII中包括制表符、换行、换页、回车和空格； </p><p>在Unicode中，还匹配无分隔空格、下一行和可变宽度空格（以及其他空格）。 </p> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/\s.*\s/) {
  print "In $string1 there are TWO whitespace characters, which may";
  print " be separated by other characters.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">In Hello World
 there are TWO whitespace characters, which may be separated by other characters.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\S</code> </th> 
   <td>匹配任何非空白字符。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/\S.*\S/) {
  print "In $string1 there are TWO non-whitespace characters, which";
  print " may be separated by other characters.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">In Hello World
 there are TWO non-whitespace characters, which may be separated by other characters.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\d</code> </th> 
   <td>匹配一个数字；与ASCII中的[0-9]相同，在Unicode中，与<br><code>\p{Digit}</code> 或 <code>\p{GC=Decimal_Number}</code><br>的属性相同, 它本身与<code>\p{Numeric_Type=Decimal}</code> 的属性相同. </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "99 bottles of beer on the wall.";
if ($string1 =~ m/(\d+)/) {
  print "$1 is the first number in '$string1'\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">99 is the first number in '99 bottles of beer on the wall.'
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\D</code> </th> 
   <td>匹配一个非数字字符；与ASCII中的<br> <code>[^0-9]</code> 或Unicode中的 <code>\P{Digit}</code> 相同。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/\D/) {
  print "There is at least one character in $string1";
  print " that is not a digit.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">There is at least one character in Hello World
 that is not a digit.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>^</code> </th> 
   <td>匹配行或字符串的开始位置。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/^He/) {
  print "$string1 starts with the characters 'He'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 starts with the characters 'He'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>$</code> </th> 
   <td>匹配行或字符串的结束位置。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/rld$/) {
  print "$string1 is a line or string ";
  print "that ends with 'rld'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 is a line or string that ends with 'rld'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\A</code> </th> 
   <td>匹配字符串的开头（但不匹配内部行）。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello\nWorld\n";
if ($string1 =~ m/\AH/) {
  print "$string1 is a string ";
  print "that starts with 'H'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello
World
 is a string that starts with 'H'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>\z</code> </th> 
   <td>匹配字符串的结尾（但不匹配内部行）。<sup><a href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/d11077.htm#quote_43" class="kx_ref">[43]</a></sup> </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello\nWorld\n";
if ($string1 =~ m/d\n\z/) {
  print "$string1 is a string ";
  print "that ends with 'd\\n'.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello
World
 is a string that ends with 'd\n'.
</code></pre><p></p> </td>
  </tr> 
  <tr> 
   <th><code>[^…]</code> </th> 
   <td>匹配除括号内的每个字符。 </td> 
   <td><p></p><pre class="kx_code"><code class="text">$string1 = "Hello World\n";
if ($string1 =~ m/[^abc]/) {
 print "$string1 contains a character other than ";
 print "a, b, and c.\n";
}
</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class="kx_code"><code class="text">Hello World
 contains a character other than a, b, and c.
</code></pre><p></p> </td>
  </tr>
 </tbody>
</table></div></div></div><div id="par_14996301871579400"><h2 class="title">11 归纳<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><p>正则表达式通常可以基于一组示例字符串来创建(“归纳”或“学习”)。这就是众所周知的 正则语言的归纳，并且是计算学习理论中语法归纳一般问题的一部分 。形式上，给出了正则语言中字符串的示例，也可能还给出了<i>不</i> 在那种正则语言中的字符串的例子 ，归纳出该语言的语法是可能的，即生成该语言的正则表达式。并非所有的正则语言都可以用这种方式归纳(参见 极限中的语言识别)，但许多人可以。例如，示例集{1，10，100}和负集(反例){11，1001，101，0}可用于归纳正则表达式1⋅0* (1后跟零个或更多个0)。 </p></div></div><div id="par_14996301871579401"><h2 class="title">12 笔记<a href="javascript:" class="detail-edit">编辑</a></h2><div class="section_content"><ol> 
 <li id="cite-ref-2"> Goyvaerts, Jan. "Regular Expression Tutorial - Learn How to Use Regular Expressions". <i>www.regular-expressions.info</i>. </li> 
 <li id="cite-ref-4"> Ruslan Mitkov (2003). <i>The Oxford Handbook of Computational Linguistics</i>. Oxford University Press. p.&nbsp;754. ISBN&nbsp;978-0-19-927634-9. </li> 
 <li id="cite-ref-6"> Mark V. Lawson (17 September 2003). <i>Finite Automata</i>. CRC Press. pp.&nbsp;98–100. ISBN&nbsp;978-1-58488-255-8. </li> 
 <li id="cite-ref-8"> . </li> 
 <li id="cite-ref-10"> . </li> 
 <li id="cite-ref-12"> . </li> 
 <li id="cite-ref-14"> Kernighan, Brian (2007-08-08). "A Regular Expressions Matcher". <i>Beautiful Code</i>. O'Reilly Media. pp.&nbsp;1–2. ISBN&nbsp;978-0-596-51004-6. Retrieved 2013-05-15. </li> 
 <li id="cite-ref-16"> Ritchie, Dennis M. "An incomplete history of the QED Text Editor". Archived from the original on 1999-02-21. Retrieved 9 October 2013. </li> 
 <li id="cite-ref-18"> , 10.11 Bibliographic Notes for Chapter 10, p. 589. </li> 
 <li id="cite-ref-20"> , 2. JIT Compilation Techniques, 2.1 Genesis, p. 98. </li> 
 <li id="cite-ref-22"> Raymond, Eric S. citing Dennis Ritchie (2003). "Jargon File 4.4.7: grep". </li> 
 <li id="cite-ref-24"> "New Regular Expression Features in Tcl 8.1". Retrieved 2013-10-11. </li> 
 <li id="cite-ref-26"> "PostgreSQL 9.3.1 Documentation: 9.7. Pattern Matching". Retrieved 2013-10-12. </li> 
 <li id="cite-ref-28"> Wall, Larry and the Perl 5 development team (2006). "perlre: Perl regular expressions". </li> 
 <li id="cite-ref-30"> "Unicode and Localisation Support". Retrieved 2013-10-11. </li> 
 <li id="cite-ref-32"> Russ Cox (2007). "Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, …)". Retrieved 2013-10-11. </li> 
 <li id="cite-ref-34">  </li> 
 <li id="cite-ref-36"> grep(1) man page </li> 
 <li id="cite-ref-38">  </li> 
 <li id="cite-ref-40">  </li> 
 <li id="cite-ref-42">  </li> 
 <li id="cite-ref-44">  </li> 
 <li id="cite-ref-46"> Jay L. Gischer (1984). <i>(Title unknown)</i> (Technical Report). Stanford Univ., Dept. of Comp. Sc. </li> 
 <li id="cite-ref-48"> John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman (2003). <i>Introduction to Automata Theory, Languages, and Computation</i>. Upper Saddle River/NJ: Addison Wesley. ISBN&nbsp;978-0-201-44124-6. Here: Sect.3.4.6, p.117-120. — This property need not hold for extended regular expressions, even if they describe no larger class than regular languages; cf. p.121. </li> 
 <li id="cite-ref-50"> <sup class="noprint Inline-Template">[页码请求]</sup> </li> 
 <li id="cite-ref-52"> V.N. Redko (1964). "On defining relations for the algebra of regular events". <i>Ukrainskii Matematicheskii Zhurnal</i>. <b>16</b> (1): 120–126. (In Russian) </li> 
 <li id="cite-ref-54"> ISO/IEC 9945-2:1993 <i>Information technology – Portable Operating System Interface (POSIX) – Part 2: Shell and Utilities</i>, successively revised as ISO/IEC 9945-2:2002 <i>Information technology – Portable Operating System Interface (POSIX) – Part 2: System Interfaces</i>, ISO/IEC 9945-2:2003, and currently ISO/IEC/IEEE 9945:2009 <i>Information technology – Portable Operating System Interface (POSIX®) Base Specifications, Issue 7</i> </li> 
 <li id="cite-ref-56"> The Single Unix Specification (Version 2) </li> 
 <li id="cite-ref-58"> "33.3.1.2 Character Classes — Emacs lisp manual — Version 25.1". <i>gnu.org</i>. 2016. Retrieved 2017-04-13. </li> 
 <li id="cite-ref-60"> "Perl Regular Expression Documentation". perldoc.perl.org. Retrieved January 8, 2012. </li> 
 <li id="cite-ref-62"> "Regular Expression Syntax". <i>Python 3.5.0 documentation</i>. Python Software Foundation. Retrieved 10 October 2015. </li> 
 <li id="cite-ref-64"> "Essential classes: Regular Expressions: Quantifiers: Differences Among Greedy, Reluctant, and Possessive Quantifiers". <i>The Java Tutorials</i>. Oracle. Retrieved 23 December 2016. </li> 
 <li id="cite-ref-66"> Cezar Câmpeanu and Kai Salomaa, and Sheng Yu (Dec 2003). "A Formal Study of Practical Regular Expressions". <i>International Journal of Foundations of Computer Science</i>. <b>14</b> (6): 1007–1018. doi:10.1142/S012905410300214X. Theorem 3 (p.9) </li> 
 <li id="cite-ref-68">  </li> 
 <li id="cite-ref-70">  </li> 
 <li id="cite-ref-72"> "Vim documentation: pattern". Vimdoc.sourceforge.net. Retrieved 2013-09-25. </li> 
 <li id="cite-ref-74"> "UTS#18 on Unicode Regular Expressions, Annex A: Character Blocks". Retrieved 2010-02-05. </li> 
 <li id="cite-ref-76"> Horowitz, Bradley (24 October 2011). "A fall sweep". <i>Google Blog</i>. Retrieved 4 May 2019. </li> 
 <li id="cite-ref-78"> Cox, Russ (January 2012). "Regular Expression Matching with a Trigram Index, or How Google Code Search Worked". <i>swtch.com</i>. Retrieved 4 May 2019. </li> 
 <li id="cite-ref-80"> The character 'm' is not always required to specify a Perl match operation. For example, <code>m/[^abc]/</code> could also be rendered as <code>/[^abc]/</code>. The 'm' is only necessary if the user wishes to specify a match operation without using a forward-slash as the regex delimiter. Sometimes it is useful to specify an alternate regex delimiter in order to avoid "delimiter collision". See 'perldoc perlre' for more details. </li> 
 <li id="cite-ref-82"> E.g., see <i>Java in a Nutshell</i>, p. 213; <i>Python Scripting for Computational Science</i>, p. 320; Programming PHP, p. 106. </li> 
 <li id="cite-ref-84"> Note that all the if statements return a TRUE value </li> 
 <li id="cite-ref-86"> Conway, Damian (2005). "Regular Expressions, End of String". <i>Perl Best Practices</i>. O'Reilly. p.&nbsp;240. ISBN&nbsp;978-0-596-00173-5. </li> 
</ol></div></div></div></div><div id="references"><h2 class="title" id="par_references">参考文献</h2><ul class="references"><li id="quote_1"><span class="references-num">[1]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Goyvaerts, Jan. "Regular Expression Tutorial - Learn How to Use Regular Expressions". www.regular-expressions.info..</span></p></li><li id="quote_2"><span class="references-num">[2]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Ruslan Mitkov (2003). The Oxford Handbook of Computational Linguistics. Oxford University Press. p. 754. ISBN 978-0-19-927634-9..</span></p></li><li id="quote_3"><span class="references-num">[3]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Mark V. Lawson (17 September 2003). Finite Automata. CRC Press. pp. 98–100. ISBN 978-1-58488-255-8..</span></p></li><li id="quote_4"><span class="references-num">[4]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kleene 1951..</span></p></li><li id="quote_5"><span class="references-num">[5]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Thompson 1968..</span></p></li><li id="quote_6"><span class="references-num">[6]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Johnson et al. 1968..</span></p></li><li id="quote_7"><span class="references-num">[7]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kernighan, Brian (2007-08-08). "A Regular Expressions Matcher". Beautiful Code. O'Reilly Media. pp. 1–2. ISBN 978-0-596-51004-6. Retrieved 2013-05-15..</span></p></li><li id="quote_8"><span class="references-num">[8]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Ritchie, Dennis M. "An incomplete history of the QED Text Editor". Archived from the original on 1999-02-21. Retrieved 9 October 2013..</span></p></li><li id="quote_9"><span class="references-num">[9]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Aho &amp; Ullman 1992, 10.11 Bibliographic Notes for Chapter 10, p. 589..</span></p></li><li id="quote_10"><span class="references-num">[10]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Aycock 2003, 2. JIT Compilation Techniques, 2.1 Genesis, p. 98..</span></p></li><li id="quote_11"><span class="references-num">[11]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Raymond, Eric S. citing Dennis Ritchie (2003). "Jargon File 4.4.7: grep"..</span></p></li><li id="quote_12"><span class="references-num">[12]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"New Regular Expression Features in Tcl 8.1". Retrieved 2013-10-11..</span></p></li><li id="quote_13"><span class="references-num">[13]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"PostgreSQL 9.3.1 Documentation: 9.7. Pattern Matching". Retrieved 2013-10-12..</span></p></li><li id="quote_14"><span class="references-num">[14]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Wall, Larry and the Perl 5 development team (2006). "perlre: Perl regular expressions"..</span></p></li><li id="quote_15"><span class="references-num">[15]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Unicode and Localisation Support". Retrieved 2013-10-11..</span></p></li><li id="quote_16"><span class="references-num">[16]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Russ Cox (2007). "Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, …)". Retrieved 2013-10-11..</span></p></li><li id="quote_17"><span class="references-num">[17]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Wall（2002）.</span></p></li><li id="quote_18"><span class="references-num">[18]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">grep(1) man page.</span></p></li><li id="quote_19"><span class="references-num">[19]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Hopcroft， Motwani &amp; Ullman（2000）.</span></p></li><li id="quote_20"><span class="references-num">[20]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Sipser（1998）.</span></p></li><li id="quote_21"><span class="references-num">[21]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Gelade &amp; Neven（2008）.</span></p></li><li id="quote_22"><span class="references-num">[22]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Gruber &amp; Holzer（2008）.</span></p></li><li id="quote_23"><span class="references-num">[23]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Jay L. Gischer (1984). (Title unknown) (Technical Report). Stanford Univ., Dept. of Comp. Sc..</span></p></li><li id="quote_24"><span class="references-num">[24]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman (2003). Introduction to Automata Theory, Languages, and Computation. Upper Saddle River/NJ: Addison Wesley. ISBN 978-0-201-44124-6. Here: Sect.3.4.6, p.117-120. — This property need not hold for extended regular expressions, even if they describe no larger class than regular languages; cf. p.121..</span></p></li><li id="quote_25"><span class="references-num">[25]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Kozen（1991）[页码请求].</span></p></li><li id="quote_26"><span class="references-num">[26]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">V.N. Redko (1964). "On defining relations for the algebra of regular events". Ukrainskii Matematicheskii Zhurnal. 16 (1): 120–126. (In Russian).</span></p></li><li id="quote_27"><span class="references-num">[27]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">ISO/IEC 9945-2:1993 Information technology – Portable Operating System Interface (POSIX) – Part 2: Shell and Utilities, successively revised as ISO/IEC 9945-2:2002 Information technology – Portable Operating System Interface (POSIX) – Part 2: System Interfaces, ISO/IEC 9945-2:2003, and currently ISO/IEC/IEEE 9945:2009 Information technology – Portable Operating System Interface (POSIX®) Base Specifications, Issue 7.</span></p></li><li id="quote_28"><span class="references-num">[28]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">The Single Unix Specification (Version 2).</span></p></li><li id="quote_29"><span class="references-num">[29]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"33.3.1.2 Character Classes — Emacs lisp manual — Version 25.1". gnu.org. 2016. Retrieved 2017-04-13..</span></p></li><li id="quote_30"><span class="references-num">[30]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Perl Regular Expression Documentation". perldoc.perl.org. Retrieved January 8, 2012..</span></p></li><li id="quote_31"><span class="references-num">[31]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Regular Expression Syntax". Python 3.5.0 documentation. Python Software Foundation. Retrieved 10 October 2015..</span></p></li><li id="quote_32"><span class="references-num">[32]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Essential classes: Regular Expressions: Quantifiers: Differences Among Greedy, Reluctant, and Possessive Quantifiers". The Java Tutorials. Oracle. Retrieved 23 December 2016..</span></p></li><li id="quote_33"><span class="references-num">[33]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Cezar Câmpeanu and Kai Salomaa, and Sheng Yu (Dec 2003). "A Formal Study of Practical Regular Expressions". International Journal of Foundations of Computer Science. 14 (6): 1007–1018. doi:10.1142/S012905410300214X. Theorem 3 (p.9).</span></p></li><li id="quote_34"><span class="references-num">[34]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Cox（2007）.</span></p></li><li id="quote_35"><span class="references-num">[35]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Laurikari（2009）.</span></p></li><li id="quote_36"><span class="references-num">[36]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"Vim documentation: pattern". Vimdoc.sourceforge.net. Retrieved 2013-09-25..</span></p></li><li id="quote_37"><span class="references-num">[37]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">"UTS#18 on Unicode Regular Expressions, Annex A: Character Blocks". Retrieved 2010-02-05..</span></p></li><li id="quote_38"><span class="references-num">[38]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Horowitz, Bradley (24 October 2011). "A fall sweep". Google Blog. Retrieved 4 May 2019..</span></p></li><li id="quote_39"><span class="references-num">[39]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Cox, Russ (January 2012). "Regular Expression Matching with a Trigram Index, or How Google Code Search Worked". swtch.com. Retrieved 4 May 2019..</span></p></li><li id="quote_40"><span class="references-num">[40]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">The character 'm' is not always required to specify a Perl match operation. For example, m/[^abc]/ could also be rendered as /[^abc]/. The 'm' is only necessary if the user wishes to specify a match operation without using a forward-slash as the regex delimiter. Sometimes it is useful to specify an alternate regex delimiter in order to avoid "delimiter collision". See 'perldoc perlre' for more details..</span></p></li><li id="quote_41"><span class="references-num">[41]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">E.g., see Java in a Nutshell, p. 213; Python Scripting for Computational Science, p. 320; Programming PHP, p. 106..</span></p></li><li id="quote_42"><span class="references-num">[42]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Note that all the if statements return a TRUE value.</span></p></li><li id="quote_43"><span class="references-num">[43]</span><p><a class="ref-back-btn">^</a><span data-url="" class="">Conway, Damian (2005). "Regular Expressions, End of String". Perl Best Practices. O'Reilly. p. 240. ISBN 978-0-596-00173-5..</span></p></li></ul></div><div class="read-num">阅读 <!-- -->3.0<!-- -->w</div></div><div class="right-side" id="rightSide"><div class="side" id="lemma-side"><div class="side-title">版本记录</div><ul class="side-lst"><li><p class="side-lst-txt">暂无</p></li></ul><div class="user-card userCard"></div></div><div class="side"><div class="side-event"></div></div></div></div><div class="footer-box"><div id="footer"><div class="footer-logo-wrap"><div class="footer-logo"></div><div class="footer-logo-text">知识·传播·科普</div></div><div class="footer-info">本网站内容采用<a target="_blank" href="https://web.archive.org/web/20221025114527/https://creativecommons.org/licenses/by-sa/3.0/deed.zh?tdsourcetag=s_pctim_aiomsg">CC-BY-SA 3.0</a>授权</div><div class="footer-btn-wrap"><a target="_blank" href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/help/#user_protocol">用户协议</a><a target="_blank" href="https://web.archive.org/web/20221025114527/http://www.sogou.com/docs/terms.htm?v=1">免责声明</a><a target="_blank" href="https://web.archive.org/web/20221025114527/http://corp.sogou.com/private.html">隐私政策</a><a target="_blank" href="https://web.archive.org/web/20221025114527/https://baike.sogou.com/kexue/intro.htm">关于我们</a></div></div></div><script>window.lemmaInfo ={"lemmaId":"11077","versionId":"14996301821247756","title":"正则表达式","subtitle":"","abstracts":{"paragraphId":"14996301821247770","title":"简介","versionId":"14996301821247757","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":2,"content":"<p></p> \n<p></p> \n<p></p> \n<p><b>正则表达式</b>, <b>regex</b> 或者 <b>regexp</b><sup><a href=\"#quote_1\" class=\"kx_ref\">[1]</a></sup> (有时称为<b>有理表达式</b>)<sup><a href=\"#quote_2\" class=\"kx_ref\">[2]</a></sup><sup><a href=\"#quote_3\" class=\"kx_ref\">[3]</a></sup>是定义<i>搜索 模式 的</i> 字符 序列。通常这种模式通过 字符串搜索算法用于字符串上的“查找”或“查找并替换”操作 ，或者用于输入验证。它是在 理论计算机科学 和 形式语言 理论中发展起来的一种技术。 </p>\n<p>这个概念产生于20世纪50年代，当时美国数学家 斯蒂芬·科尔·克莱尼 <i>形式化了正规语言的描述</i>。这一概念和 Unix 文本处理实用程序一起开始被普遍使用。自20世纪80年代以来，存在着不同的用于编写正则表达式 语法 ，一种是 POSIX 标准，另一种是广泛使用的是 Perl 语法。 </p>\n<p>正则表达式用于 搜索引擎、搜索和替换 文字处理器和 文本编辑器的对话框、文本处理实用程序（如 sed 和 AWK）和 词汇分析。许多 程序设计语言提供regex功能，内置或通过 库。 </p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025114527/https://img01.sogoucdn.com/app/a/200698/sogou_science_5826?w=300&h=173&titlename=%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%20(?%3C%3D%5C.)%20%7B2,%7D(?%3D%5BA-Z%5D)%0A%20%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%A4%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E4%BD%86%E5%89%8D%E6%8F%90%E6%98%AF%E5%AE%83%E4%BB%AC%E7%9B%B4%E6%8E%A5%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8F%A5%E5%8F%B7%EF%BC%88.%EF%BC%89%E4%B9%8B%E5%90%8E%E5%92%8C%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E4%B9%8B%E5%89%8D","url":"https://web.archive.org/web/20221025114527/https://img01.sogoucdn.com/app/a/200698/sogou_science_5826","rw":300,"rh":173,"title":"模式的匹配结果 (?<=\\.) {2,}(?=[A-Z])\n 至少匹配两个空格，但前提是它们直接出现在句号（.）之后和大写字母之前","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},"card":{"paragraphId":"0","title":null,"versionId":"0","lemmaId":0,"createType":0,"creator":null,"createTime":0,"versionEditor":null,"editTime":0,"comment":null,"dependVersionId":0,"contentType":0,"content":null,"pics":null,"card":null,"references":null,"versionCount":0},"categories":[{"id":1,"name":"计算机","parents":[]}],"creator":{"uid":56906306,"name":"水吉","pic":"https://web.archive.org/web/20221025114527/https://cache.soso.com/qlogo/g?b=oidb&k=LoUR4bkBHUmNBZIl7SebQA&s=100&t=1557753541","introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":142,"partnerIdCreateTime":1595844881,"partnerIdPoped":false},"createTime":1571038534,"editor":{"uid":56906306,"name":"水吉","pic":"https://web.archive.org/web/20221025114527/https://cache.soso.com/qlogo/g?b=oidb&k=LoUR4bkBHUmNBZIl7SebQA&s=100&t=1557753541","introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":142,"partnerIdCreateTime":1595844881,"partnerIdPoped":false},"editTime":1576234491,"state":1,"versionCount":1,"upNum":4,"downNum":0,"pics":[{"originalUrl":"https://web.archive.org/web/20221025114527/https://img01.sogoucdn.com/app/a/200698/sogou_science_5826?w=300&h=173&titlename=%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C%20(?%3C%3D%5C.)%20%7B2,%7D(?%3D%5BA-Z%5D)%0A%20%E8%87%B3%E5%B0%91%E5%8C%B9%E9%85%8D%E4%B8%A4%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%8C%E4%BD%86%E5%89%8D%E6%8F%90%E6%98%AF%E5%AE%83%E4%BB%AC%E7%9B%B4%E6%8E%A5%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8F%A5%E5%8F%B7%EF%BC%88.%EF%BC%89%E4%B9%8B%E5%90%8E%E5%92%8C%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D%E4%B9%8B%E5%89%8D","url":"https://web.archive.org/web/20221025114527/https://img01.sogoucdn.com/app/a/200698/sogou_science_5826","rw":300,"rh":173,"title":"模式的匹配结果 (?<=\\.) {2,}(?=[A-Z])\n 至少匹配两个空格，但前提是它们直接出现在句号（.）之后和大写字母之前","alt":null,"width":0,"height":0},{"originalUrl":"https://web.archive.org/web/20221025114527/https://img03.sogoucdn.com/app/a/200698/sogou_science_5828?w=300&h=150&titlename=%E8%BD%AC%E6%8D%A2%20Kleene%E6%98%9F%E5%8F%B7(s*%20%E8%A1%A8%E7%A4%BA%20'%E9%9B%B6%20%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAs%20')","url":"https://web.archive.org/web/20221025114527/https://img03.sogoucdn.com/app/a/200698/sogou_science_5828","rw":300,"rh":150,"title":"转换 Kleene星号(s* 表示 '零 个或多个s ')","alt":null,"width":0,"height":0}],"catalogs":[{"level":1,"title":"模式","paragraphId":"14996301821247771","subCatalogs":null},{"level":1,"title":"历史","paragraphId":"14996301838024972","subCatalogs":null},{"level":1,"title":"基本概念","paragraphId":"14996301838024973","subCatalogs":null},{"level":1,"title":"形式语言理论","paragraphId":"14996301838024974","subCatalogs":[{"level":2,"title":"正式定义","paragraphId":"14996301838024974","subCatalogs":null},{"level":2,"title":"表达能力和紧凑性","paragraphId":"14996301838024974","subCatalogs":null},{"level":2,"title":"判定正则表达式的等价性","paragraphId":"14996301838024974","subCatalogs":null}]},{"level":1,"title":"语法","paragraphId":"14996301838024975","subCatalogs":[{"level":2,"title":"分隔符","paragraphId":"14996301838024975","subCatalogs":null},{"level":2,"title":"标准","paragraphId":"14996301838024975","subCatalogs":null},{"level":2,"title":"Perl和PCRE","paragraphId":"14996301838024975","subCatalogs":null},{"level":2,"title":"懒惰匹配","paragraphId":"14996301838024975","subCatalogs":null},{"level":2,"title":"占有匹配","paragraphId":"14996301838024975","subCatalogs":null}]},{"level":1,"title":"非正则语言的模式","paragraphId":"14996301854802176","subCatalogs":null},{"level":1,"title":"实现和运行时间","paragraphId":"14996301854802177","subCatalogs":null},{"level":1,"title":"Unicode","paragraphId":"14996301854802178","subCatalogs":null},{"level":1,"title":"使用","paragraphId":"14996301854802179","subCatalogs":null},{"level":1,"title":"示例","paragraphId":"14996301854802180","subCatalogs":null},{"level":1,"title":"归纳","paragraphId":"14996301871579400","subCatalogs":null},{"level":1,"title":"笔记","paragraphId":"14996301871579401","subCatalogs":null},{"level":1,"title":"参考文献","paragraphId":"-1","subCatalogs":null}],"paragraphs":[{"paragraphId":"14996301821247771","title":"模式","versionId":"14996301821247758","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>短语<i>正则表达式，</i>因此<i>regexes</i>，通常是指特定的标准文本语法(不同于下面描述的数学符号),用于表示匹配文本的模式。正则表达式中的每个字符(即描述其模式的字符串中的每个字符)要么是 具有特殊意义的元字符，要么是具有字面意义的常规字符。例如，在正则表达式中 <code>a.</code>, <i>a</i> 是一个仅匹配‘a’的字面值字符，而‘.'是与除换行符以外的每个字符都匹配的元字符。因此，该正则表达式匹配，例如，'a'、'ax'或'a0'。元字符和字面值字符一起可以用来识别给定模式的文本，或者处理它的多个实例。模式匹配可能从精确相等到由元字符控制的非常概括性的相似性不等。例如， <code>.</code> 是一个非常概括性的模式， <code>[a-z]</code> (匹配从‘a’到‘z’的所有小写字母)不太概括， <code>a</code> 是一个精确的模式(只匹配“a”)。元字符语法是专为以简洁灵活的方式表示指定目标而设计的，以便于使用标准 ASCII 键盘键入的形式指导各种输入数据文本处理的自动化。 </p>\n<p>这种语法中正则表达式的一个非常简单的例子是在 文字编辑器中定位以两种不同方式拼写的单词，正则表达式 <code>seriali[sz]e</code> 匹配“serialise”和“serialize”。通配符 也可以实现这一点，但它们在模式上的局限性更大，因为它们具有更少的元字符和简单的语言基础。 </p>\n<p>通配符的通常上下文是在文件列表中通配相似的名称，而正则表达式通常用于模式匹配文本字符串的应用程序中。例如，正则表达式 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"o\">^</span><span class=\"s\">[ \\t]</span><span class=\"o\">+|</span><span class=\"s\">[ \\t]</span><span class=\"o\">+$</span><span class=\"w\"></span></code> 匹配行首或行尾多余的空格。匹配任何数字的高级正则表达式是 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[+-]</span><span class=\"o\">?(</span><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"o\">+(</span><span class=\"err\">\\</span><span class=\"o\">.</span><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"o\">+)?|</span><span class=\"err\">\\</span><span class=\"o\">.</span><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"o\">+)(</span><span class=\"s\">[eE][+-]</span><span class=\"o\">?</span><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"o\">+)?</span><span class=\"w\"></span></code>。 </p> \n<p></p><p><img alt=\"\" class=\"fileimage kx_img ed_imgfloat_right\" img_height=\"150\" img_width=\"300\" titlename=\"转换 Kleene星号(s* 表示 '零 个或多个s ')\" data-src=\"https://img03.sogoucdn.com/app/a/200698/sogou_science_5828\"> </p><p></p> \n<p><b>正则表达式处理器</b> 将上述语法中的正则表达式转换为内部表示，该表示可以对表示要搜索的文本的字符串执行和匹配。一种可能的方法是 汤普森构造算法 ，构建一个 非确定有限自动机 (NFA)，然后使其成为确定性的，生成的确定性有限自动机 (DFA)在目标文本字符串上运行，以识别与正则表达式匹配的子字符串。图显示了从正则表达式 <code><i>s</i>*</code>获得的NFA方案 <code><i>N</i>(<i>s</i>*)</code> ，这里<i>s</i> 表示一个更简单的正则表达式，<code><i>N</i>(<i>s</i>*)</code>已经被 递归地 转换为NFA <i>N</i>（<i>s</i>)。 </p>","pics":[{"originalUrl":"https://web.archive.org/web/20221025114527/https://img03.sogoucdn.com/app/a/200698/sogou_science_5828?w=300&h=150&titlename=%E8%BD%AC%E6%8D%A2%20Kleene%E6%98%9F%E5%8F%B7(s*%20%E8%A1%A8%E7%A4%BA%20'%E9%9B%B6%20%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAs%20')","url":"https://web.archive.org/web/20221025114527/https://img03.sogoucdn.com/app/a/200698/sogou_science_5828","rw":300,"rh":150,"title":"转换 Kleene星号(s* 表示 '零 个或多个s ')","alt":null,"width":0,"height":0}],"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301838024972","title":"历史","versionId":"14996301821247759","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式起源于1951年，当时数学家 斯蒂芬·科尔·克莱尼 使用他的名为<i>正则集合</i>的数学符号描述 正规语言。<sup><a href=\"#quote_4\" class=\"kx_ref\">[4]</a></sup> 这些出现于 理论计算机科学，自动机理论 (计算模型)的子领域以及形式语言的描述和分类中。模式匹配 的其他早期实现包括 SNOBOL 语言，它不使用正则表达式，而是使用自己的模式匹配结构。 </p>\n<p>正则表达式从1968年开始普遍使用，有两种用途:文本编辑器中的模式匹配<sup><a href=\"#quote_5\" class=\"kx_ref\">[5]</a></sup> 和编辑器中的词法分析。<sup><a href=\"#quote_6\" class=\"kx_ref\">[6]</a></sup> 正则表达式以程序形式首次出现是在 肯·汤普森 将Kleene的符号构建到编辑器 QED 中，作为在文本文件匹配模式的一种手段 .<sup><a href=\"#quote_5\" class=\"kx_ref\">[5]</a></sup><sup><a href=\"#quote_7\" class=\"kx_ref\">[7]</a></sup><sup><a href=\"#quote_8\" class=\"kx_ref\">[8]</a></sup><sup><a href=\"#quote_9\" class=\"kx_ref\">[9]</a></sup> 为了提高速度，汤普森通过即时编译(JIT)在一台装有兼容分时操作系统的IBM 7094机器上实现了正则表达式匹配 ，这是JIT编译的一个重要早期示例。<sup><a href=\"#quote_10\" class=\"kx_ref\">[10]</a></sup> 他后来将这一功能添加到了Unix编辑器中 ed，这最终导致了正则表达式的流行搜索工具 grep的使用(“grep”是一个源自ed编辑器中正则表达式搜索命令的单词: <code>g/<i>re</i>/p</code> 意思是“对正则表达式进行全局搜索和打印匹配行”<sup><a href=\"#quote_11\" class=\"kx_ref\">[11]</a></sup>)。大约在汤普森开发QED的同时，一组研究人员（包括 道格拉斯·罗斯 ）实现了一个基于正则表达式的工具， 该工具在编译器 设计中用于 词法分析。<sup><a href=\"#quote_6\" class=\"kx_ref\">[6]</a></sup> </p>\n<p>在20世纪70年代这些正则表达式的原始形式的许多变体在 贝尔实验室被用于 Unix<sup><a href=\"#quote_9\" class=\"kx_ref\">[9]</a></sup> 程序 ，包括 vi、lex、 sed 、AWK和 expr，以及在例如 Emacs的其他程序中。正则表达式随后被广泛的程序采用，这些早期形式在 1992年的POSIX.2 标准中被标准化。 </p>\n<p>20世纪80年代在 Perl出现了更复杂的正则表达式，它最初源于 亨利·斯宾塞 (1986)写的一个正则表达式库，他后来为 Tcl写了一个 <i>高级正则表达式</i>的实现 。<sup><a href=\"#quote_12\" class=\"kx_ref\">[12]</a></sup> Tcl库是一个具有改进性能特征的混合 NFA/DFA 实现。采用Spencer的Tcl正则表达式实现的软件项目包括 PostgreSQL。<sup><a href=\"#quote_13\" class=\"kx_ref\">[13]</a></sup> Perl后来扩展了Spencer的原始库，增加了许多新特性，<sup><a href=\"#quote_14\" class=\"kx_ref\">[14]</a></sup> 但是在性能或 Unicode 处理方面还没有赶上Spencer的高级正则表达式实现。<sup><a href=\"#quote_15\" class=\"kx_ref\">[15]</a></sup><sup><a href=\"#quote_16\" class=\"kx_ref\">[16]</a></sup> Perl 6 设计的部分工作是改进Perl的正则表达式集成，并增加它们的范围和能力，以允许 解析表达式语法的定义。<sup><a href=\"#quote_17\" class=\"kx_ref\">[17]</a></sup> 结果是一种叫做 Perl 6规则 迷你语言 ，用于定义Perl 6语法，并为程序员提供该语言的工具。这些规则维护了Perl 5.x正则表达式的现有特性，但也允许通过子规则定义递归下降分析器的BNF风格。 </p>\n<p>在文档和数据库建模的结构化信息标准中使用正则表达式始于20世纪60年代，并在20世纪80年代扩展，当时 ISO SGML (由ANSI“GCA 101-1983”引入）等行业标准得到了巩固。结构规范语言标准的核心由正则表达式组成。它的用法在DTD元素组语法中很明显。 </p>\n<p>从1997年开始，菲利普·黑兹尔 开发了PCRE (Perl兼容正则表达式)，它试图模仿Perl的正则表达式功能，并被许多现代工具(包括 PHP 和 Apache HTTP 服务器）使用。 </p>\n<p>如今，在编程语言、文本处理程序(特别是词法分析器lexers)、高级文本编辑器和一些其他程序中普遍支持正则表达式。正则表达式支持是许多编程语言（包括 Java 和 Python） 标准库 的一部分，并内置于其他语法中，包括Perl和 ECMAScript。正则表达式功能的实现通常被称为 <b>regex引擎</b>，许多库可供重用。 </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301838024973","title":"基本概念","versionId":"14996301821247760","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式，通常称为 <b>模式</b>，是用于指定特定目的所需的字符串集的表达式。指定有限字符串集的一个简单方法是列出它的 元素 或者成员。然而，通常有更简洁的方法来指定所需的字符串集。例如，包含三个字符串“Handel”、“Händel”和“Haendel”的集合可以由 <b>模式</b> <code>H(ä|ae?)ndel</code>指定；我们说这种模式 <b>匹配</b> 三个字符串中的每一个。在大多数 形式中，如果存在至少一个与特定集合相匹配的正则表达式，那么就存在无限多的也与之匹配正则表达式——规范并不是唯一的。大多数形式提供以下操作来构造正则表达式。 </p> \n<dl>\n <dt>\n  布尔“或”\n </dt> \n <dd>\n  竖线 分离选项。例如， \n  <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"n\">gray</span><span class=\"o\">|</span><span class=\"n\">grey</span></code> 可以匹配“gray”或“grey”。\n </dd> \n <dt>\n  分组\n </dt> \n <dd>\n  圆括号 用于定义运算符的范围和优先级 (以及其他用途)。例如， \n  <code>gray|grey</code> 和 \n  <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"n\">gr</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">|</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"n\">y</span></code> 是描述“gray”或“grey”集合的等价模式。\n </dd> \n <dt>\n  以数量表示\n </dt> \n <dd>\n  量词 之后 标记 (例如字符)或组指定允许前一个元素出现的频率。最常见的量词是 问号 \n  <code>?</code>， 星号 \n  <code>*</code> (源于 Kleene 星号)，以及 加号 \n  <code>+</code> （Kleene加号)。 {| | style=&#34; width:15px；垂直对齐:顶部；&#34; | \n  <code><b>?</b></code> |问号表示问号前一个元素\n  <i>出现零次或一次</i>。例如，\n  <code>colou?r</code>匹配“color&#34;和“colour”。 |- | style=&#34;垂直对齐:顶部；&#34; | \n  <code><b>*</b></code> |星号表示星号前一个元素\n  <i>出现零次或多次</i>。例如， \n  <code>ab*c</code> 匹配“ac”、“abc”、“abbc”、“abbc”等。 |- | style=&#34;垂直对齐:顶部；&#34; | \n  <code><b>+</b></code> |加号表示加号前一个元素\n  <i>出现一次或多次</i>。例如， \n  <code>ab+c</code> 匹配“abc”、“abbc”、“abbbc”等，但不匹配“ac”。 |- |\n  <code><b>{n}</b></code>\n  <sup><a href=\"#quote_18\" class=\"kx_ref\">[18]</a></sup> |前面的项被匹配\n  <i>n</i> 次。 |- |\n  <code><b>{min,}</b></code>\n  <sup><a href=\"#quote_18\" class=\"kx_ref\">[18]</a></sup> |前面的项被匹配\n  <i>min</i>次或者更多次。 |- |\n  <code><b>{min,max}</b></code>\n  <sup><a href=\"#quote_18\" class=\"kx_ref\">[18]</a></sup> |前面的项被匹配至少\n  <i>min</i>次，但不超过 \n  <i>max</i> 次。|}\n </dd> \n <dt>\n  通配符\n </dt>\n</dl> \n<p>通配符 <code><b>.</b></code> 匹配任何字符。例如， <code>a.b</code> 匹配任何包含一个“a”，然后是任何其他字符和一个“b”的字符串， a.*b 匹配任何包含一个“a”和后面包含一个“b”的字符串。 </p>\n<p>这些结构可以组合起来形成任意复杂的表达式，就像可以从数字和运算符 <b>+</b>, <b>−</b>, <b>×</b>，<b>÷</b>中构造算术表达式一样。例如，<code>H(ae?|ä)ndel</code> 和 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"n\">H</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">|</span><span class=\"n\">ae</span><span class=\"o\">|</span><span class=\"n\">ä</span><span class=\"p\">)</span><span class=\"n\">ndel</span></code> 都是匹配与前面示例相同字符串的有效模式，<code>H(ä|ae?)ndel</code>。 </p>\n<p>正则表达式精确的 语法 因工具和程序语言而异。 </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301838024974","title":"形式语言理论","versionId":"14996301821247761","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式在 形式语言理论中描述 正规语言。它们具有与正则语法相同的表达能力。 </p> \n<h3>正式定义</h3> \n<p>正则表达式由常量（表示字符串集）和运算符（表示对这些集合的运算）组成。下面的定义是标准的，在大多数关于形式语言理论的教科书中也是如此。<sup><a href=\"#quote_19\" class=\"kx_ref\">[19]</a></sup><sup><a href=\"#quote_20\" class=\"kx_ref\">[20]</a></sup> 给定一个有限的 字母表 Σ，以下常量被定义为正则表达式: </p> \n<ul>\n <li>（<i>空集</i>)∅表示集合∅.</li> \n <li>（<i>空字符串</i>)ε表示只包含“空”字符串的集合，没有任何字符。</li> \n <li>（<i>字面值字符</i>) <code>a</code> 在Σ表示只包含字符<i>a</i>的集合 。</li>\n</ul> \n<p>给定正则表达式R和S，定义了以下对它们的操作以生成正则表达式: </p> \n<ul>\n <li>（<i>连接</i>) <i>RS</i>表示可以通过连接R中的一个字符串和S中的一个字符串来获得的字符串集。例如，让R = {&#34;ab &#34;，&#34; c&#34;}和S = {&#34;d &#34;，&#34; ef&#34;}。然后，RS = {&#34;abd &#34;，&#34; abef &#34;，&#34; cd &#34;，&#34; cef&#34;}。</li> \n <li>（<i>间隔</i>) <i>R</i> | <i>S</i> 表示由<i>R</i>和<i>S</i> 描述的集合的并集 。例如，如果R={&#34;ab &#34;，&#34; c&#34;}，S={&#34;ab &#34;，&#34; d &#34;、&#34; ef&#34;}，表达式 R | <i>S</i> ={&#34;ab &#34;，&#34; c &#34;，&#34; d &#34;，&#34; ef&#34;}。</li> \n <li>（<i>Kleene 星号</i>) <i>R</i>*表示由包含ε的<i>R</i>描述的集合的最小 超集 并且在字符串连接下是闭合的。这是所有字符串的集合，可以通过从R所描述的集合中连接任意有限数量(包括零)的字符串来生成。例如，{“0”，”1”} *是所有有限 二进制字符串(包括空字符串)的集合和{&#34;ab &#34;，&#34; c&#34;}* = {ε，&#34; ab &#34;，&#34; c &#34;，&#34; abab &#34;，&#34; abc &#34;，&#34; cab &#34;，&#34; cc &#34;，&#34; ababab &#34;，&#34; abcab &#34;，...}。</li>\n</ul> \n<p>为了避免圆括号，假设Kleene星号具有最高优先级，然后是连接和间隔。如果没有歧义，圆括号可以省略。例如，<code>(ab)c</code> 可以写成 <code>abc</code>，和 <code>a|(b(c*))</code> 可以写成 <code>a|bc*</code>。许多教科书使用符号∪、+、或∨来代替竖线进行间隔。 </p>\n<p><b>示例:</b> </p> \n<ul>\n <li><code>a|b*</code> 表示{ε, &#34;a&#34;, &#34;b&#34;, &#34;bb&#34;, &#34;bbb&#34;, ...}</li> \n <li><code>(a|b)*</code> 表示除“a”和“b”以外没有符号的所有字符串的集合，包括空字符串: {ε, &#34;a&#34;, &#34;b&#34;, &#34;aa&#34;, &#34;ab&#34;, &#34;ba&#34;, &#34;bb&#34;, &#34;aaa&#34;, ...}</li> \n <li><code>ab*(c|ε)</code> 表示从“a”开始，然后是零个或多个“b”，最后可选的是一个“c”的一组字符串:{&#34;a&#34;, &#34;ac&#34;, &#34;ab&#34;, &#34;abc&#34;, &#34;abb&#34;, &#34;abbc&#34;, ...}</li> \n <li><code>(0|(1(01*0)*1))*</code> 表示3的倍数的二进制数集合:{ ε, &#34;0&#34;, &#34;00&#34;, &#34;11&#34;, &#34;000&#34;, &#34;011&#34;, &#34;110&#34;, &#34;0000&#34;, &#34;0011&#34;, &#34;0110&#34;, &#34;1001&#34;, &#34;1100&#34;, &#34;1111&#34;, &#34;00000&#34;, ... }</li>\n</ul> \n<h3>表达能力和紧凑性</h3> \n<p>正则表达式的正式定义是有意最小化的，并且避免定义 <code>?</code> 和 <code>+</code>—这些可以表达为: <code>a+</code> = <code>aa*</code>，和 <code>a?</code> = <code>(a|ε)</code>。有时候添加 求补 运算符，以给出一个 <i>广义正则表达式</i>；这里 <i>R<sup>c</sup></i> 匹配Σ*上不匹配<i>R</i>所有字符串。原则上，求补运算符是多余的，因为它不再赋予任何表达能力。但是，它可以使正则表达式更加简洁——从正则表达式中消除所有求补运算符会导致其长度的双倍指数爆炸。<sup><a href=\"#quote_21\" class=\"kx_ref\">[21]</a></sup><sup><a href=\"#quote_22\" class=\"kx_ref\">[22]</a></sup> </p>\n<p>从这个意义上说，正则表达式可以表达正则语言，确切地说是被确定有限自动机接受的语言类。然而，紧凑性有很大的不同。某些正则语言类只能由确定性有限自动机来描述，其大小以最短等价正则表达式的大小呈指数增长 。这里的标准例子是由字母表{a,b}上的所有字符串组成的语言<i>L<sub>k</sub></i> ，它的第<i>k</i>个到最后一个字母等于<i>a</i>。一方面，正则表达式由 （a|b)*a(a|b)(a|b)(a|b)描述 <i>L</i><sub>4</sub> 。 </p>\n<p>将这种模式推广到 <i>L<sub>k</sub></i> 给出了表达式:<b>解析失败 (带SVG或PNG备选的MathML（建议用于现代的浏览器和辅助工具）：从服务器“/mathoid/local/v1/”返回无效的响应（“Math extension cannot connect to Restbase.”）：): {\\displaystyle (a\\mid b)^*a\\underbrace{(a\\mid b)(a\\mid b)\\cdots(a\\mid b)}_{k-1\\text{ times}}. \\, }</b> </p>\n<p>另一方面，众所周知，每个接受语言<i>L<sub>k</sub></i> 的确定有限自动机必须至少有2<sup><i>k</i></sup> 个状态。幸运的是，有一个从正则表达式到更一般的非确定有限自动机（NFAs)的简单映射，NFAs不会导致如此大规模的爆炸；因此，NFAs经常被用作正则语言的替代表示。NFAs是 乔姆斯基层次结构的3型语言的简单变体。<sup><a href=\"#quote_19\" class=\"kx_ref\">[19]</a></sup> </p>\n<p>相反，DFA很容易描述许多语言，而DFA却不容易被正则表达式描述。例如，确定给定 ISBN 的有效性需要计算整数基数11的模数，并且可以容易地用11态DFA来实现。然而，回答相同的可除性问题的正则表达式的长度至少为几兆字节。 </p>\n<p>给定一个正则表达式， 汤普森构造算法 计算等价的非确定有限自动机。相反方向的转换由克莱尼算法实现。 </p>\n<p>最后，值得注意的是，许多现实世界中的“正则表达式”引擎实现了形式语言理论意义上正则表达式无法描述的特性；相反，它们实现了<i>正则表达式</i>。 </p> \n<h3>判定正则表达式的等价性</h3> \n<p>从上面的许多例子中可以看出，有多种方法可以构造正则表达式来获得相同的结果。 </p>\n<p>有可能写一个 算法 对于两个给定的正则表达式，决定所描述的语言是否等价；该算法将每个表达式简化为 最小确定有限状态机，并确定它们是否是 同形的 (等价的)。 </p>\n<p>正则表达式的代数定律可以通过Gischer的一种方法获得，这种方法最好通过一个例子来解释:为了检查(<i>X</i>+<i>Y</i>)<sup>*</sup> 和(<i>X</i><sup>*</sup> <i>Y</i><sup>*</sup>)<sup>*</sup> 对于所有正则表达式<i>X</i>, <i>Y</i>，表示相同的正则语言 ，检查特定正则表达式(<i>a</i>+<i>b</i>)<sup>*</sup> 和(<i>a</i><sup>*</sup> <i>b</i><sup>*</sup>)<sup>*</sup> 是否表示字母表Σ= {<i>a</i>,<i>b</i>}上的相同语言是必要且充分的。更一般地说，一个等式 <i>E</i>=<i>F</i> 在有变量的正则表达式项之间，当且仅当用不同符号常量替换的不同变量的实例化成立时才成立。<sup><a href=\"#quote_23\" class=\"kx_ref\">[23]</a></sup><sup><a href=\"#quote_24\" class=\"kx_ref\">[24]</a></sup> </p>\n<p>通过使用 Kleene星号 和 并集 寻找一个仍然完全表达的正则表达式有趣子集来消除冗余，但也许它们的使用可能会受到限制。这是一个令人惊讶的难题。尽管正则表达式很简单，但是没有办法将它们系统地重写为某种形式。过去公理的缺乏导致了 星高度问题。1991年， Dexter Kozen 公理化正则表达式作为 Kleene代数，使用等式和 霍恩条款 公理。<sup><a href=\"#quote_25\" class=\"kx_ref\">[25]</a></sup> 早在1964年，Redko就已经证明了没有一组有限的纯等式公理可以描述正则语言的代数。<sup><a href=\"#quote_26\" class=\"kx_ref\">[26]</a></sup> </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301838024975","title":"语法","versionId":"14996301821247762","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式 <i>模式</i> 匹配目标<i>字符串</i>。该模式由 <i>原子</i>序列组成。原子是正则表达式模式中的单个点，它试图匹配目标字符串。最简单的原子是字面量，但是将模式的部分分组以匹配原子需要使用 <code>( )</code> 作为元字符。元字符有助于形成: <i>原子</i>； <i>量词</i> 告诉我们有多少原子(以及它是否是一个  )；一个逻辑“或”字符，它提供了一组选择；一个逻辑“非”字符，它否定了原子的存在；和反向引用来引用完整原子模式的先前原子。不是当字符串的所有原子都匹配时，而是当正则表达式中的所有模式原子都匹配时，才进行匹配。这个想法是让一个小的字符模式代表大量可能的字符串，而不是编译一个包含所有字面值可能性的大列表。 </p>\n<p>根据正则表达式处理器的不同，大约有14个元字符，这些字符可能有也可能没有 字面的 字符含义，取决于上下文或它们是否“被转义”，即前面有一个 转义序列，在这种情况下是反斜杠 <code>\\</code>。现代扩展正则表达式和POSIX扩展正则表达式使用元字符的频率超过了它们的字面含义，因此为了避免“反斜杠”或 倾斜牙签综合征 ，将元字符转义为字面模式是有意义的；但是首先，让四个括号元字符 <code>( )</code> 和 <code>{ }</code> 是字面意思并“转义”这个通常的意思成为元字符更有意义。通用标准实现了两者。通常的元字符是 <code> {}[]()^$.|*+?</code> 和 <code>\\</code>。转义后成为元字符的常见字符有 <code>dswDSW</code> 和 <code>N</code>。 </p> \n<h3>分隔符</h3> \n<p>当在编程语言中输入正则表达式时，它们可能被表示为通常的字符串字面量，因此通常被引用；例如，这在C、Java和Python中很常见，其中正则表达式 <code>re</code> 输入为 <code>&#34;re&#34;</code>。然而，它们通常将斜杠作为分割符，如正则表达式 <code>re</code>写成<code>/re/</code>。这源于 ed, <code>/</code> 是用于搜索的编辑器命令，是一个表达式 <code>/re/</code> 可以用来指定一系列的行(匹配模式)，这些行可以与任一侧的其他命令相结合，最著名的是 <code>g/re/p</code> ，如 grep (“全局正则表达式版本”)，包含在大多数 基于Unix的操作系统，例如 Linux 发行版。类似的约定用于 sed，其中搜索和替换由 <code>s/re/replacement/</code> 给出和模式可以用逗号连接，以指定一系列行，如 <code>/re1/,/re2/</code>。这种用法因在 Perl中的使用而特别有名，它构成了语法中与普通字符串字面值不同的一部分。在某些情况下，例如sed和Perl，可以使用替代分隔符来避免与内容冲突，并避免必须转义内容中分隔符的出现。例如，在sed命令中 <code>s,/,X,</code> ，使用逗号作为分隔符，将替换一个 <code>/</code> 和一个 <code>X</code>。 </p> \n<h3>标准</h3> \n<p>这 IEEE POSIX 标准有三组合规性:BRE(基本正则表达式)，<sup><a href=\"#quote_27\" class=\"kx_ref\">[27]</a></sup> ERE(扩展正则表达式）和SRE（简单正则表达式)。 不推荐使用SRE<sup><a href=\"#quote_28\" class=\"kx_ref\">[28]</a></sup> ，而赞成使用BRE，因为两者都提供向后兼容性。 </p>\n<p>BRE和ERE一起工作。ERE添加了 <code>?</code>, <code>+</code>，和 <code>|</code>，它消除了转义元字符 <code>( )</code> 和 <code>{ }</code>的需要，而其在BRE中是需要的。此外，只要遵守正则表达式的POSIX标准语法，就可以是，而且通常是，额外的语法来服务于特定的(但是符合POSIX)应用程序。虽然POSIX.2没有定义一些实现细节，但是BRE和ERE提供了一个“标准”，这个“标准”后来被作为许多工具的默认语法，其中BRE或ERE模式的选择通常是受支持的选项。例如，GNU grep有以下选项:“grep -E”代表ERE，“grep -G”代表BRE(默认)，而“grep -P”代表Perl正则表达式。 </p>\n<p>Perl正则表达式已经成为de事实上的标准，拥有丰富而强大的原子表达式集。Perl没有“基本”或“扩展”级别。与在POSIX EREs中一样， <code>( )</code> 和 <code>{ }</code> 除非转义，否则将被视为元字符；其他元字符仅基于上下文被认为是字面的或符号的。附加功能包括 , 回溯，命名捕获组，以及 递归模式。 </p> \n<p><strong>POSIX基础和扩展</strong></p> \n<p>在 POSIX 标准中，基本正则语法(<b>BRE</b>)要求 元字符 <code>( )</code> 和 <code>{ }</code> 被指定为 <code>\\(\\)</code> 和 <code>\\{\\}</code>，而扩展正则语法(<b>ERE</b>)没有。 </p> \n<table class=\"wikitable\"> \n <tbody>\n  <tr> \n   <th>元字符 </th> \n   <th>描 述 </th>\n  </tr> \n  <tr> \n   <th><code>^</code> </th> \n   <td>匹配字符串中的起始位置。在基于行的工具中，它匹配任何行的起始位置。 </td>\n  </tr> \n  <tr> \n   <th><code>.</code> </th> \n   <td>匹配任何单个字符（许多应用程序不包括换行符，确切地说哪些字符被视为换行符是风格-、字符编码和平台特定的，但可以安全地假定包含换行符）。在POSIX括号表达式中，点字符与字面值点匹配。例如，a.c匹配“abc”等，但[a.c]只匹配“a”、“.”或“c”。 </td>\n  </tr> \n  <tr> \n   <th><code>[ ]</code> </th> \n   <td>括号表达式。匹配括号中包含的单个字符。例如， <code>[abc]</code>匹配“a”、“b”或“c”。 <code>[a-z]</code>指定与“a”到“z”之间的任何小写字母匹配的范围。这些形式可以混合使用：<code>[abcx-z]</code> 与“a”、“b”、“c”、“x”、“y”或“z”匹配，和 <code>[a-cx-z]</code>一样。 <p>如果<code>-</code> 字符是括号内的最后一个或第一个（如果在 <code>^</code>之后）字符，则将字符视为字面值字符： <code>[abc-]</code>，<code>[-abc]</code>。 请注意，不允许使用反斜杠转义。 如果字符 <code>]</code>是第一个（在 <code>^</code>后面）字符，则可以将其括在括号表达式中：<code>[]abc]</code>。 </p> </td>\n  </tr> \n  <tr> \n   <th><code>[^ ]</code> </th> \n   <td>匹配不包含在括号内的单个字符。例如， <code>[^abc]</code>匹配除“a”、“b”或“c”以外的任何字符。 <code>[^a-z]</code> 匹配任何不是从“a”到“z”的小写字母的单个字符。同样，字面值字符和范围可以混合使用。 </td>\n  </tr> \n  <tr> \n   <th><code>$</code> </th> \n   <td>匹配字符串的结束位置或字符串结尾换行符之前的位置。在基于行的工具中，它匹配任何行的结束位置。 </td>\n  </tr> \n  <tr> \n   <th><code>( )</code> </th> \n   <td>定义标记的子表达式。括号内匹配的字符串可以稍后调用。标记的子表达式也称为块或捕获组。<b>BRE模式需要 <code>\\( \\)</code></b>。 </td>\n  </tr> \n  <tr> \n   <th><code>\\<i>n</i></code> </th> \n   <td>匹配第n个标记的子表达式所匹配的内容，其中n是1到9之间的数字。这个构造在posix.2标准中模糊地被定义。有些工具允许引用9个以上的捕获组。 </td>\n  </tr> \n  <tr> \n   <th><code>*</code> </th> \n   <td>与前面的元素匹配零次或多次。例如， <code>ab*c</code> 匹配&#34;ac&#34;、 &#34;abc&#34;、 &#34;abbbc&#34;等。 <code>[xyz]*</code> 匹配&#34;&#34;、&#34;x&#34;、 &#34;y&#34;、&#34;z&#34;、 &#34;zx&#34;、 &#34;zyx&#34;、 &#34;xyzzy&#34;等。 <code>(ab)*</code> 匹配&#34;&#34;、 &#34;ab&#34;、&#34;abab&#34;、&#34;ababab&#34;等。 </td>\n  </tr> \n  <tr> \n   <th><code>{<i>m</i>,<i>n</i>}</code> </th> \n   <td>与前面的元素匹配至少<i>m</i>次，但不超过<i>n</i>次。例如， <code>a{3,5}</code> 仅匹配 &#34;aaa&#34;、 &#34;aaaa&#34;和&#34;aaaaa&#34;。在一些旧版本的正则表达式中找不到。<b>BRE模式需要 <code><span class=\"nowrap\">\\{<i>m</i>,<i>n</i>\\</span>}</code></b>. </td>\n  </tr>\n </tbody>\n</table> \n<p><b>示例:</b> </p> \n<ul>\n <li><code>.at</code> 匹配任何以“at”结尾的三个字符的字符串，包括“hat”、“cat”和“bat”。</li> \n <li><code>[hc]at</code> 匹配“hat”和“cat”。</li> \n <li><code>[^b]at</code> 匹配所有可以由 <code>.at</code>匹配的字符串， 除了“bat”。</li> \n <li><code>[^hc]at</code> 匹配所有可以由 <code>.at</code>匹配的字符串，除了“hat”和“cat”。</li> \n <li><code>^[hc]at</code> 匹配“hat”和“cat”，但仅在字符串或行首。</li> \n <li><code>[hc]at$</code> 匹配“hat”和“cat”，但仅在字符串或行尾。</li> \n <li><code>\\[.\\]</code> 匹配由“[”和“]”包围的任何单个字符，因为括号是被转义的，例如:“[a]”和“[b]”。</li> \n <li><code>s.*</code> 匹配后跟零个或多个字符的s，例如:“s”、“saw”和“seed”。</li>\n</ul> \n<p><strong>POSIX扩展</strong></p> \n<p>在POSIX扩展正则表达式(<b>ERE</b>)语法中，对于某些字符，使用反斜杠转义的元字符的含义是相反的。使用这种语法，反斜杠会导致元字符被视为字面值字符。比如说， <code>\\( \\)</code> 现在是 <code>( )</code> 和 <code>\\{ \\}</code> 现在是 <code>{ }</code>。此外，将移除对 <code>\\<i>n</i></code> 反向引用的支持，并添加以下元字符: </p> \n<table class=\"wikitable\"> \n <tbody>\n  <tr> \n   <th>元字符 </th> \n   <th>描述 </th>\n  </tr> \n  <tr> \n   <th><code>?</code> </th> \n   <td>匹配前面的元素零次或一次。例如， <code>ab?c</code> 只匹配 &#34;ac&#34; 或 &#34;abc&#34;。 </td>\n  </tr> \n  <tr> \n   <th><code>+</code> </th> \n   <td>匹配前面的元素一次或多次。例如， <code>ab+c</code> 匹配 &#34;abc&#34;, &#34;abbc&#34;, &#34;abbbc&#34;等， 但不匹配&#34;ac&#34;. </td>\n  </tr> \n  <tr> \n   <th><code>|</code> </th>\n   <td>选择（也称为间隔或并集）运算符匹配运算符之前的表达式或运算符之后的表达式。例如， <code>abc|def</code> 匹配 &#34;abc&#34; 或 &#34;def&#34;.</td> \n  </tr>\n </tbody>\n</table> \n<p><b>示例:</b> </p> \n<ul>\n <li><code>[hc]?at</code> 匹配“at”、“hat”和“cat”。</li> \n <li><code>[hc]*at</code> 匹配&#34;at&#34;、&#34;hat&#34;、&#34;cat&#34;、 &#34;hhat&#34;、 &#34;chat&#34;、 &#34;hcat&#34;、&#34;cchchat&#34;等。</li> \n <li><code>[hc]+at</code> 匹配&#34;hat&#34;、&#34;cat&#34; 、&#34;hhat&#34;、 &#34;chat&#34;、&#34;hcat&#34;、 &#34;cchchat&#34;等，但不匹配“at”。</li> \n <li><code>cat|dog</code> 匹配&#34;cat&#34; or &#34;dog&#34;。</li>\n</ul> \n<p>通过包含 命令行标志-E，POSIX扩展正则表达式通常可以与现代Unix实用程序一起使用。 </p> \n<p><strong>字符类</strong></p> \n<p>字符类是字面值匹配后最基本的正则表达式概念。它使一个小的字符序列与一组大的字符相匹配。例如， <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Z]</span><span class=\"w\"></span></code> 代表大写字母，并且 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"w\"></span></code> 可能意味着任何数字。字符类适用于两种POSIX级别。 </p>\n<p>指定字符范围时，例如 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[a-Z]</span><span class=\"w\"></span></code> (即小写 <i><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"nv\">a</span><span class=\"w\"></span></code></i>到大写 <i><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"nv\">z</span><span class=\"w\"></span></code></i>)，计算机的区域设置通过字符编码的数字顺序来确定内容。他们可以存储序列中的数字，或者顺序可以是 <i>abc…zABC…Z</i>，或 <i>aAbBcC…zZ</i>。因此POSIX标准定义了一个字符类，它将被安装的regex处理器所知。这些定义见下表: </p> \n<table class=\"wikitable sortable\"> \n <tbody>\n  <tr> \n   <th>POSIX</th> \n   <th>Non-standard</th> \n   <th>Perl/Tcl</th> \n   <th>Vim</th> \n   <th>Java</th> \n   <th>ASCII</th> \n   <th>描述 </th>\n  </tr> \n  <tr> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:ascii:]</span><span class=\"w\"></span></code><sup><a href=\"#quote_29\" class=\"kx_ref\">[29]</a></sup> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">ASCII</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[\\x00-\\x7F]</span><span class=\"w\"></span></code> </td> \n   <td>ASCII 字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:alnum:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Alnum</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Za-z0-9]</span><span class=\"w\"></span></code> </td> \n   <td>字母和数字字符 </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:word:]</span><span class=\"w\"></span></code><sup><a href=\"#quote_29\" class=\"kx_ref\">[29]</a></sup> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Za-z0-9_]</span><span class=\"w\"></span></code> </td> \n   <td>字母和数字字符加上 &#34;_&#34; </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[^A-Za-z0-9_]</span><span class=\"w\"></span></code> </td> \n   <td>非单词字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:alpha:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">a</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Alpha</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Za-z]</span><span class=\"w\"></span></code> </td> \n   <td>字母和数字字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:blank:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">s</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Blank</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[ \\t]</span><span class=\"w\"></span></code> </td> \n   <td>空格和水平制表符 </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">b</span><span class=\"w\"></span></code> </td> \n   <td><code>\\&lt; \\&gt;</code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">b</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"o\">(?</span><span class=\"err\">&lt;</span><span class=\"o\">=</span><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"o\">)(?=</span><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"o\">)|(?</span><span class=\"err\">&lt;</span><span class=\"o\">=</span><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"o\">)(?=</span><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"o\">)</span><span class=\"w\"></span></code> </td> \n   <td>单词边界 </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">B</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"o\">(?</span><span class=\"err\">&lt;</span><span class=\"o\">=</span><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"o\">)(?=</span><span class=\"err\">\\</span><span class=\"nv\">W</span><span class=\"o\">)|(?</span><span class=\"err\">&lt;</span><span class=\"o\">=</span><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"o\">)(?=</span><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"o\">)</span><span class=\"w\"></span></code> </td> \n   <td>非单词边界 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:cntrl:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Cntrl</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[\\x00-\\x1F\\x7F]</span><span class=\"w\"></span></code> </td> \n   <td>控制字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:digit:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Digit</span><span class=\"p\">}</span><span class=\"w\"></span></code> or <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">d</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[0-9]</span><span class=\"w\"></span></code> </td> \n   <td>十进制数字 </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">D</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">D</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">D</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[^0-9]</span><span class=\"w\"></span></code> </td> \n   <td>非十进制数字 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:graph:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Graph</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[\\x21-\\x7E]</span><span class=\"w\"></span></code> </td> \n   <td>可见字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:lower:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">l</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Lower</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[a-z]</span><span class=\"w\"></span></code> </td> \n   <td>小写字母 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:print:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Print</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[\\x20-\\x7E]</span><span class=\"w\"></span></code> </td> \n   <td>可见字符和空格字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:punct:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Punct</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[][!&#34;#$%&amp;&#39;()*+,./:;&lt;=&gt;?@\\^_`{|}~-]</span><span class=\"w\"></span></code> </td> \n   <td>标点符号 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:space:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">s</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">_s</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Space</span><span class=\"p\">}</span><span class=\"w\"></span></code> or <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">s</span><span class=\"w\"></span></code> </td> \n   <td><code>[ ]</code> </td> \n   <td>空白字符 </td>\n  </tr> \n  <tr> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">S</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">S</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">S</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[^ \\t\\r\\n\\v\\f]</span><span class=\"w\"></span></code> </td> \n   <td>非空白字符 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:upper:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">u</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">Upper</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Z]</span><span class=\"w\"></span></code> </td> \n   <td>大写字母 </td>\n  </tr> \n  <tr> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:xdigit:]</span><span class=\"w\"></span></code> </td> \n   <td> </td> \n   <td> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">x</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">p</span><span class=\"p\">{</span><span class=\"x\">XDigit</span><span class=\"p\">}</span><span class=\"w\"></span></code> </td> \n   <td><code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[A-Fa-f0-9]</span><span class=\"w\"></span></code> </td> \n   <td>十六进制数字 </td>\n  </tr>\n </tbody>\n</table> \n<p>POSIX字符类只能在括号表达式中使用。例如， <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[[:upper:]</span><span class=\"nv\">ab</span><span class=\"err\">]</span><span class=\"w\"></span></code> 匹配大写字母和小写字母“a”和“b”。 </p>\n<p>某些工具理解的另一个非POSIX类是 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:word:]</span><span class=\"w\"></span></code>，通常定义为 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"s\">[:alnum:]</span><span class=\"w\"></span></code> 加下划线。这反映了这样一个事实，即在许多编程语言中，这些字符可以用在标识符中。编辑 Vim 进一步区分 <i>word</i> 和 <i>word-head</i> 类(使用符号 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">w</span><span class=\"w\"></span></code> 和 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"err\">\\</span><span class=\"nv\">h</span><span class=\"w\"></span></code>)因为在许多编程语言中，可以开始一个标识符的字符与可以出现在其他位置的字符不同。 </p>\n<p>请注意POSIX正则表达式标准所称的 <i>字符类</i> 通常在其他支持它们的正则表达式风格被称为 <i>POSIX字符类</i> 。对于大多数其他正则表达式风格，术语 <i>字符类</i> 用于描述POSIX所称的<i>括号表达式</i>。 </p> \n<h3>Perl和PCRE</h3> \n<p>由于它的表达能力和(相对)易读性，许多其他实用程序和编程语言都采用了类似于Perl的语法——例如， Java、 JavaScript、 Julia、 Python、 Ruby、 Qt、 微软 的 .NET框架、和 XML模式。一些语言和工具，例如 Boost 和 PHP 支持多种正则表达式风格。Perl派生正则表达式的实现并不相同，通常实现1994年发布的Perl 5.0中的一部分特性，Perl有时会包含了最初在其他语言中发现的特性，例如，Perl 5.10实现了最初在 PCRE和Python中开发的语法扩展。<sup><a href=\"#quote_30\" class=\"kx_ref\">[30]</a></sup> </p> \n<h3>懒惰匹配</h3> \n<p>Python和一些其他实现方式(例如，Java)，三个常用量词(<code>*</code>, <code>+</code> 和 <code>?</code>)默认是贪婪的， 因为它们匹配尽可能多的字符。<sup><a href=\"#quote_31\" class=\"kx_ref\">[31]</a></sup> 正则表达式 <code>&#34;.+&#34;</code> (包括双引号)应用于字符串 </p> \n<pre class=\"kx_code\">&#34;Ganymede,&#34; he continued, &#34;is the largest moon in the Solar System.&#34;\n</pre> \n<p>匹配整行(因为整行以双引号开始和结束),而不是只匹配第一部分， <code>&#34;Ganymede,&#34;</code>。然而，通过添加问号: <code>&#34;.+?&#34;</code> ，来匹配尽可能少的字符，上述量词 可能会变得<i>懒惰</i> 或者<i>最小</i>或者<i>不情愿</i>，仅匹配 <code>&#34;Ganymede,&#34;</code>。<sup><a href=\"#quote_31\" class=\"kx_ref\">[31]</a></sup> </p>\n<p>然而，在某些情况下，整个句子仍然可以匹配。问号运算符不会改变点运算符的含义，因此它仍然可以匹配输入中的双引号。像这样的模式 <code>&#34;.*?&#34; EOF</code> 如果这是字符串，将仍然匹配整个输入: </p> \n<pre class=\"kx_code\">&#34;Ganymede,&#34; he continued, &#34;is the largest moon in the Solar System.&#34; EOF\n</pre> \n<p>为了确保双引号不成为匹配的一部分，必须替换点，例如: <code>&#34;[^&#34;]*&#34;</code> 这将匹配引用的文本部分，其中没有附加双引号。 </p> \n<h3>占有匹配</h3> \n<p>在Java中，通过在量词后面加上一个加号，可以使量词变为<i>占有的</i> ，这会禁止后退，即使这样做会使整个匹配成功:<sup><a href=\"#quote_32\" class=\"kx_ref\">[32]</a></sup> 当正则表达式 <code>&#34;.*&#34;</code> 应用于字符串 </p> \n<pre class=\"kx_code\">&#34;Ganymede,&#34; he continued, &#34;is the largest moon in the Solar System.&#34;\n</pre> \n<p>匹配整行，正则表达式 <code>&#34;.*+&#34;</code> 根本没有匹配，因为 <code>.*+</code> 消耗整个输入，包括最后的<code>&#34;</code>。因此，占有量词对负字符类最有用 ，例如，当应用于同一字符串时，<code>&#34;[^&#34;]*+&#34;</code>匹配 <code>&#34;Ganymede,&#34;</code>。 </p>\n<p>占有量词比贪婪量词和懒惰量词更容易实现，并且通常在运行时效率更高。<sup><a href=\"#quote_32\" class=\"kx_ref\">[32]</a></sup> </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301854802176","title":"非正则语言的模式","versionId":"14996301821247763","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>几乎所有现代正则表达式库中的许多特性都提供了远远超过 正则语言的表达能力。例如，许多实现允许用括号将子表达式分组，并在同一表达式（反向引用）中回忆它们匹配的值。这意味着，除了别的以外，一个模式可以匹配重复单词的字符串，如“papa”或“WikiWiki”，在形式语言理论中叫做 <i>squares</i> 。这些字符串的模式是 <code>(.+)\\1</code>。 </p>\n<p>由于 泵引理，正方形的语言不规则，也不是 上下文无关。然而，在众多现代工具的支持下，模式匹配与无限数量的反向引用仍然是 上下文敏感的。<sup><a href=\"#quote_33\" class=\"kx_ref\">[33]</a></sup> </p>\n<p>然而，许多提供这种结构的工具、库和引擎仍然使用这个术语 <i>正规表达式</i> 作为其模式。这导致了一种命名法，在 形式语言理论和模式匹配中，术语正则表达式具有不同的含义。出于这个原因，有些人已经习惯使用这个术语 <i>regex</i>, <i>regexp</i>，或者简单的<i>模式</i> 来描述后者。Perl编程语言的作者 拉里·沃尔在一篇关于Perl 6设计的文章中写道: </p> \n<p>&#34;Regular expressions&#34; […] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&#39;m not going to try to fight linguistic necessity here. I will, however, generally call them &#34;regexes&#34; (or &#34;regexen&#34;, when I&#39;m in an Anglo-Saxon mood).<sup><a href=\"#quote_17\" class=\"kx_ref\">[17]</a></sup> </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301854802177","title":"实现和运行时间","versionId":"14996301821247764","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>至少有三种不同的算法决定给定正则表达式是否匹配字符串以及如何匹配字符串。 </p>\n<p>在形式语言理论中，一个结果上的最古老和最快的依赖是允许每个非确定有限自动机 (NFA)被转换为确定性有限自动机 (DFA)。DFA可以被显式构建，然后在生成的输入字符串上一次运行一个符号。为大小为m的一个正则表达式构造DFA的时间和内存开销<i>O</i>(2<sup><i>m</i></sup>)，但它可以在时间o（n）内运行在大小为n的字符串上。 </p>\n<p>另一种方法是直接模拟NFA，本质上是按需构建每个DFA状态，然后在下一步丢弃它。这保持了DFA的隐式性，避免了指数级的构建成本，但运行成本上升到 <i>O</i>（<i>mn</i>)。显式方法被称为DFA算法，隐式方法被称为NFA算法。将缓存添加到NFA算法中通常被称为“懒惰DFA”算法，或者只是没有区别的DFA算法。这些算法速度很快，但是使用它们来调用分组的子表达式、懒惰量词和类似的特征是很棘手的。<sup><a href=\"#quote_34\" class=\"kx_ref\">[34]</a></sup><sup><a href=\"#quote_35\" class=\"kx_ref\">[35]</a></sup> </p>\n<p>第三种算法是通过回溯将模式与输入字符串进行匹配。这种算法通常被称为NFA，但这个术语可能会令人困惑。它的运行时间可以是指数级的，当与包含交替和无界量化的表达式（如 <code class=\"mw-highlight\" dir=\"ltr\"><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">|</span><span class=\"n\">aa</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">b</span></code>）匹配时，简单的实现显示出来，并迫使算法考虑数量呈指数增长的子情况。这种行为会导致称为正则表达式拒绝服务 (ReDoS)的安全问题。 </p>\n<p>尽管回溯实现仅在最坏的情况下提供指数保证，但它们提供了更大的灵活性和表达能力。例如，任何允许使用回溯的实现，或者实现Perl引入的各种扩展，都必须包括某种回溯。一些实现<sup class=\"noprint\">[哪个／哪些？]</sup> 尝试通过首先运行一个快速DFA算法来提供两种算法中的最佳算法，并且只有在匹配过程中遇到反向引用时，才恢复到可能较慢的回溯算法。 </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301854802178","title":"Unicode","versionId":"14996301821247765","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>从理论上讲，任何标记集只要是预定义的，都可以通过正则表达式匹配。就历史实现而言，正则表达式最初是用ASCII字符作为标记集编写的，尽管正则表达式库支持许多其他的字符集。许多现代正则表达式引擎至少提供了对 Unicode 的一些支持。在大多数方面，字符集并没有什么区别，但是当扩展正则表达式以支持Unicode时，确实会出现一些问题。 </p> \n<ul>\n <li><b>支持的编码</b>。一些正则表达式库期望在某些特定的编码上，而不是抽象的Unicode字符上工作。其中许多要求 UTF-8 编码，而其他人可能会期望UTF-16或 UTF-32。相比之下，Perl和Java在编码上是不可知的，而是在内部对解码的字符进行操作。</li> \n <li><b>支持的Unicode范围</b>。许多正则表达式引擎只支持 基本多语言平面，即只能用16位编码的字符。目前(截至2016年)，只有少数正则表达式引擎(如Perl和Java)可以处理全部21位Unicode范围。</li> \n <li><b>将面向ASCII的结构扩展到Unicode</b>。例如，在基于ASCII的实现中，如果x和y的代码点在[0x00,0x7f]范围内且代码点（x）≤代码点（y），则形式为<code>[x-y]</code>的字符范围有效。这种字符范围自然扩展到Unicode将端点位于[0x00，0x7F]的要求更改为端点位于[0x0000，0x10FFFF]的要求。然而，实际上情况往往并非如此。某些实现，例如 gawk的实现，不允许字符范围跨越Unicode块。像[0x61，0x7F]这样的范围是有效的，因为两个端点都在基本拉丁文块内，像[0x0530，0x0560]一样，因为两个端点都在亚美尼亚语块内，但是im像[0x0061，0x0532]这样的范围是无效的，因为它包括多个Unicode块。其他引擎，如 Vim 编辑器，允许块交叉，但字符值之间的间隔不得超过256。<sup><a href=\"#quote_36\" class=\"kx_ref\">[36]</a></sup></li> \n <li><b>不区分大小写</b>。一些不区分大小写的标志只影响ASCII字符。其他标志影响所有字符。一些引擎有两个不同的标志，一个用于ASCII，另一个用于Unicode。到底哪些字符属于POSIX类也各不相同。</li> \n <li><b>不区分大小写的表亲</b>。由于ASCII具有区分大小写的特性，不区分大小写成为文本搜索中的一个逻辑特征。Unicode引入了不区分大小写的字母脚本 Devanagari。对于这些， 区分大小写不适用。对于像中文这样的文字，另一个区别看似合乎逻辑:传统和简化之间。在阿拉伯文字中，可能需要对 初始、中间、最终和孤立位置 不敏感。在日语中，平假名 和 片假名 之间的不敏感有时是有用的。</li> \n <li><b>正常化</b>。Unicode具有 组合字符。像旧打字机一样，普通字母后面可以跟随一个或多个非间隔符号(通常是音调符号，如重音符号)，以形成单个打印字符，但也提供预先组合的字符，即已经包括一个或多个组合字符的字符。字符序列+组合字符序列应该与相同的单个预组合字符相匹配。标准化字符序列+组合字符序列的过程被称为标准化。</li> \n <li><b>新的控制代码</b>。其中引入了Unicode，字节顺序标记和文本方向标记。这些代码可能必须以特殊的方式处理。</li> \n <li><b>Unicode块、文字系统和许多其他字符属性的字符类介绍</b>。块属性远不如文字系统属性有用，因为一个块可以有来自几个不同文字系统的代码点，而一个文字系统可以有来自几个不同块的代码点。<sup><a href=\"#quote_37\" class=\"kx_ref\">[37]</a></sup> 在 Perl 还有 <code></code> 库，形式 <code>\\p{InX}</code> 或者 <code>\\p{Block=X}</code> 的属性匹配块中的字符<i>X</i> 和 <code>\\P{InX}</code> 或者 <code>\\P{Block=X}</code> 匹配不在该块中的代码点。同样地， <code>\\p{Armenian}</code>, <code>\\p{IsArmenian}</code>或 <code>\\p{Script=Armenian}</code> 匹配亚美尼亚文字系统中的任何字符。总的来说， <code>\\p{X}</code> 匹配任何具有二进制属性的字符 <i>X</i> 或一般类别 <i>X</i>。例如， <code>\\p{Lu}</code>, <code>\\p{Uppercase_Letter}</code>或 <code>\\p{GC=Lu}</code> 匹配任意大写字母。二进制属性是 <i>不</i> 一般类别包括 <code>\\p{White_Space}</code>, <code>\\p{Alphabetic}</code>, <code>\\p{Math}</code>，和 <code>\\p{Dash}</code>。非二进制属性的例子有 <code>\\p{Bidi_Class=Right_to_Left}</code>, <code>\\p{Word_Break=A_Letter}</code>和 <code>\\p{Numeric_Value=10}</code>。</li>\n</ul>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301854802179","title":"使用","versionId":"14996301821247766","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式在各种各样的 文本处理 任务中很有用，更一般地是字符串处理，其中数据不必是文本的。常见应用程序包括 数据验证、 数据抓取 (尤其是 网页抓取)、 数据打包、简单 解析、 语法突出显示系统的生成和许多其他任务。 </p>\n<p>虽然正则表达式在互联网搜索引擎上很有用，但在整个数据库中处理它们可能会消耗过多的计算机资源，这取决于正则表达式的复杂性和设计。尽管在许多情况下，系统管理员可以在内部运行基于正则表达式的查询，但大多数搜索引擎不向公众提供正则表达式支持。值得注意的例外: 谷歌代码搜索, Exalead。谷歌代码搜索已于2012年1月关闭。<sup><a href=\"#quote_38\" class=\"kx_ref\">[38]</a></sup> 它使用Trigram索引来加速查询。<sup><a href=\"#quote_39\" class=\"kx_ref\">[39]</a></sup> </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301854802180","title":"示例","versionId":"14996301821247767","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>具体的语法规则因具体的实现，编程语言，或使用的 库 而异。此外，正则表达式实现的功能在不同 版本之间可能有所不同。 </p>\n<p>因为如果没有示例，正则表达式很难解释和理解，所以测试正则表达式的交互式网站是通过实验学习正则表达式的有用资源。本节通过示例的方式提供了正则表达式的一些属性的基本描述。 </p>\n<p>示例中使用了以下约定。<sup><a href=\"#quote_40\" class=\"kx_ref\">[40]</a></sup> </p> \n<pre class=\"kx_code\">metacharacter(s)；；元字符列指定正在演示的正则表达式语法\n=~ m//           ；；指Perl中的正则表达式<b>匹配</b>操作\n=~ s//          ；；指Perl中的正则表达式<b>代替</b>操作\n</pre> \n<p>同样值得注意的是，这些正则表达式都是类似Perl的语法。标准  正则表达式是不同的。 </p>\n<p>除非另有说明，以下示例符合 Perl 编程语言，5.8.8版，2006年1月31日。这意味着其他实现可能缺乏对这里所示语法的某些部分的支持(例如，基本正则表达式 vs. 扩展正则表达式， <code>\\( \\)</code> vs . <code>()</code>，或缺乏的 <code>\\d</code> 代替 POSIX <code>[:digit:]</code>)。 </p>\n<p>这些示例中使用的语法和约定也与其他编程环境一致。<sup><a href=\"#quote_41\" class=\"kx_ref\">[41]</a></sup> </p> \n<table class=\"wikitable\"> \n <tbody>\n  <tr> \n   <th>Meta-<br/>character(s) </th> \n   <th>描述 </th> \n   <th>示例<sup><a href=\"#quote_42\" class=\"kx_ref\">[42]</a></sup> </th>\n  </tr> \n  <tr> \n   <th><code>.</code> </th> \n   <td>通常匹配除换行符之外的任何字符。 <p>在方括号内，点是字面值。 </p> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/...../) {\n  print &#34;$string1 has length &gt;= 5.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n has length &gt;= 5.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>( )</code> </th> \n   <td>将一系列模式元素分组到单个元素。 <p>当您在括号内匹配一个模式时，您可以使用$1，$2，……后面参考先前匹配的模式。 </p> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/(H..).(o..)/) {\n  print &#34;We matched &#39;$1&#39; and &#39;$2&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">We matched &#39;Hel&#39; and &#39;o W&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>+</code> </th> \n   <td>匹配前面的模式元素一次或多次。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/l+/) {\n  print &#34;There are one or more consecutive letter \\&#34;l\\&#34;&#39;s in $string1.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There are one or more consecutive letter &#34;l&#34;&#39;s in Hello World.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>?</code> </th> \n   <td>匹配前面的模式元素零次或一次。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/H.?e/) {\n  print &#34;There is an &#39;H&#39; and a &#39;e&#39; separated by &#34;;\n  print &#34;0-1 characters (e.g., He Hue Hee).\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There is an &#39;H&#39; and a &#39;e&#39; separated by 0-1 characters (e.g., He Hue Hee).\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>?</code> </th> \n   <td>修改*, +, ?或者前面出现的{M,N}正则表达式，以尽可能少的匹配。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/(l.+?o)/) {\n  print &#34;The non-greedy match with &#39;l&#39; followed by one or\\n&#34;;\n  print &#34;more characters is &#39;llo&#39; rather than &#39;llo Wo&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">The non-greedy match with &#39;l&#39; followed by one or\nmore characters is &#39;llo&#39; rather than &#39;llo Wo&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>*</code> </th> \n   <td>匹配前面的模式元素零次或多次。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/el*o/) {\n  print &#34;There is an &#39;e&#39; followed by zero to many &#34;;\n  print &#34;&#39;l&#39; followed by &#39;o&#39; (e.g., eo, elo, ello, elllo).\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There is an &#39;e&#39; followed by zero to many &#39;l&#39; followed by &#39;o&#39; (e.g., eo, elo, ello, elllo).\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>{M,N}</code> </th> \n   <td>表示最小M和最大N匹配计数。<br/>N可以省略，M可以是0： <code>{M}</code> 精确匹配M 次; <code>{M,}</code> 匹配至少M次; <code>{0,N}</code> 最多匹配N次。<br/><code>x* y+ z?</code>因此等价于<code>x{0,} y{1,} z{0,1}</code>。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/l{1,2}/) {\n  print &#34;There exists a substring with at least 1 &#34;;\n  print &#34;and at most 2 l&#39;s in $string1\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There exists a substring with at least 1 and at most 2 l&#39;s in Hello World\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>[…]</code> </th> \n   <td>表示一组可能的字符匹配。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/[aeiou]+/) {\n  print &#34;$string1 contains one or more vowels.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n contains one or more vowels.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>|</code> </th> \n   <td>分开备选 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/(Hello|Hi|Pogo)/) {\n  print &#34;$string1 contains at least one of Hello, Hi, or Pogo.&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n contains at least one of Hello, Hi, or Pogo.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\b</code> </th> \n   <td>在一个单词类字符和非单词类字符或一个边界之间匹配一个零宽度边界; 和<code>(^\\w|\\w$|\\W\\w|\\w\\W)</code>一样。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/llo\\b/) {\n  print &#34;There is a word that ends with &#39;llo&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There is a word that ends with &#39;llo&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\w</code> </th> \n   <td>匹配一个包括&#34;_&#34;的字母数字字符；与ASCII中的 <code>[A-Za-z0-9_]</code> , Unicode中的 \n    <dl>\n     <dd>\n      <code>[\\p{Alphabetic}<wbr/>\\p{GC=Mark}<wbr/>\\p{GC=Decimal_Number}<wbr/>\\p{GC=Connector_Punctuation}]相同</code>,\n      <sup><a href=\"#quote_37\" class=\"kx_ref\">[37]</a></sup> 其中\n      <code>Alphabetic</code> 属性包含多个拉丁字母， \n      <code>Decimal_Number</code> 属性包含多个阿拉伯数字。\n     </dd>\n    </dl> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/\\w/) {\n  print &#34;There is at least one alphanumeric &#34;;\n  print &#34;character in $string1 (A-Z, a-z, 0-9, _).\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There is at least one alphanumeric character in Hello World\n (A-Z, a-z, 0-9, _).\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\W</code> </th> \n   <td>匹配一个包括&#34;_&#34;的非字母数字字符；与ASCII中的 <code>[^A-Za-z0-9_]</code> , Unicode中的 \n    <dl>\n     <dd>\n      <code>[^\\p{Alphabetic}<wbr/>\\p{GC=Mark}<wbr/>\\p{GC=Decimal_Number}<wbr/>\\p{GC=Connector_Punctuation}]</code>\n     </dd> \n     <dd>\n      相同。\n     </dd>\n    </dl> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/\\W/) {\n  print &#34;The space between Hello and &#34;;\n  print &#34;World is not alphanumeric.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">The space between Hello and World is not alphanumeric.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\s</code> </th> \n   <td>匹配空白字符， <p>ASCII中包括制表符、换行、换页、回车和空格； </p><p>在Unicode中，还匹配无分隔空格、下一行和可变宽度空格（以及其他空格）。 </p> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/\\s.*\\s/) {\n  print &#34;In $string1 there are TWO whitespace characters, which may&#34;;\n  print &#34; be separated by other characters.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">In Hello World\n there are TWO whitespace characters, which may be separated by other characters.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\S</code> </th> \n   <td>匹配任何非空白字符。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/\\S.*\\S/) {\n  print &#34;In $string1 there are TWO non-whitespace characters, which&#34;;\n  print &#34; may be separated by other characters.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">In Hello World\n there are TWO non-whitespace characters, which may be separated by other characters.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\d</code> </th> \n   <td>匹配一个数字；与ASCII中的[0-9]相同，在Unicode中，与<br/><code>\\p{Digit}</code> 或 <code>\\p{GC=Decimal_Number}</code><br/>的属性相同, 它本身与<code>\\p{Numeric_Type=Decimal}</code> 的属性相同. </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;99 bottles of beer on the wall.&#34;;\nif ($string1 =~ m/(\\d+)/) {\n  print &#34;$1 is the first number in &#39;$string1&#39;\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">99 is the first number in &#39;99 bottles of beer on the wall.&#39;\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\D</code> </th> \n   <td>匹配一个非数字字符；与ASCII中的<br/> <code>[^0-9]</code> 或Unicode中的 <code>\\P{Digit}</code> 相同。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/\\D/) {\n  print &#34;There is at least one character in $string1&#34;;\n  print &#34; that is not a digit.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">There is at least one character in Hello World\n that is not a digit.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>^</code> </th> \n   <td>匹配行或字符串的开始位置。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/^He/) {\n  print &#34;$string1 starts with the characters &#39;He&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n starts with the characters &#39;He&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>$</code> </th> \n   <td>匹配行或字符串的结束位置。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/rld$/) {\n  print &#34;$string1 is a line or string &#34;;\n  print &#34;that ends with &#39;rld&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n is a line or string that ends with &#39;rld&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\A</code> </th> \n   <td>匹配字符串的开头（但不匹配内部行）。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello\\nWorld\\n&#34;;\nif ($string1 =~ m/\\AH/) {\n  print &#34;$string1 is a string &#34;;\n  print &#34;that starts with &#39;H&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello\nWorld\n is a string that starts with &#39;H&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>\\z</code> </th> \n   <td>匹配字符串的结尾（但不匹配内部行）。<sup><a href=\"#quote_43\" class=\"kx_ref\">[43]</a></sup> </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello\\nWorld\\n&#34;;\nif ($string1 =~ m/d\\n\\z/) {\n  print &#34;$string1 is a string &#34;;\n  print &#34;that ends with &#39;d\\\\n&#39;.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello\nWorld\n is a string that ends with &#39;d\\n&#39;.\n</code></pre><p></p> </td>\n  </tr> \n  <tr> \n   <th><code>[^…]</code> </th> \n   <td>匹配除括号内的每个字符。 </td> \n   <td><p></p><pre class=\"kx_code\"><code class=\"text\">$string1 = &#34;Hello World\\n&#34;;\nif ($string1 =~ m/[^abc]/) {\n print &#34;$string1 contains a character other than &#34;;\n print &#34;a, b, and c.\\n&#34;;\n}\n</code></pre><p></p> <p><b>输出:</b> </p> <p></p><pre class=\"kx_code\"><code class=\"text\">Hello World\n contains a character other than a, b, and c.\n</code></pre><p></p> </td>\n  </tr>\n </tbody>\n</table>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301871579400","title":"归纳","versionId":"14996301821247768","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<p>正则表达式通常可以基于一组示例字符串来创建(“归纳”或“学习”)。这就是众所周知的 正则语言的归纳，并且是计算学习理论中语法归纳一般问题的一部分 。形式上，给出了正则语言中字符串的示例，也可能还给出了<i>不</i> 在那种正则语言中的字符串的例子 ，归纳出该语言的语法是可能的，即生成该语言的正则表达式。并非所有的正则语言都可以用这种方式归纳(参见 极限中的语言识别)，但许多人可以。例如，示例集{1，10，100}和负集(反例){11，1001，101，0}可用于归纳正则表达式1⋅0* (1后跟零个或更多个0)。 </p>","pics":null,"card":null,"references":[],"versionCount":0},{"paragraphId":"14996301871579401","title":"笔记","versionId":"14996301821247769","lemmaId":11077,"createType":0,"creator":{"uid":0,"name":null,"pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"createTime":0,"versionEditor":{"uid":56906306,"name":"水吉","pic":null,"introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":null,"jobBrief":null,"role":0,"roleName":null,"title":null,"professionalTitle":null,"phoneNo":null,"editable":false,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false},"editTime":1576234491,"comment":null,"dependVersionId":0,"contentType":1,"content":"<ol> \n <li id=\"cite-ref-2\"> Goyvaerts, Jan. &#34;Regular Expression Tutorial - Learn How to Use Regular Expressions&#34;. <i>www.regular-expressions.info</i>. </li> \n <li id=\"cite-ref-4\"> Ruslan Mitkov (2003). <i>The Oxford Handbook of Computational Linguistics</i>. Oxford University Press. p. 754. ISBN 978-0-19-927634-9. </li> \n <li id=\"cite-ref-6\"> Mark V. Lawson (17 September 2003). <i>Finite Automata</i>. CRC Press. pp. 98–100. ISBN 978-1-58488-255-8. </li> \n <li id=\"cite-ref-8\"> . </li> \n <li id=\"cite-ref-10\"> . </li> \n <li id=\"cite-ref-12\"> . </li> \n <li id=\"cite-ref-14\"> Kernighan, Brian (2007-08-08). &#34;A Regular Expressions Matcher&#34;. <i>Beautiful Code</i>. O&#39;Reilly Media. pp. 1–2. ISBN 978-0-596-51004-6. Retrieved 2013-05-15. </li> \n <li id=\"cite-ref-16\"> Ritchie, Dennis M. &#34;An incomplete history of the QED Text Editor&#34;. Archived from the original on 1999-02-21. Retrieved 9 October 2013. </li> \n <li id=\"cite-ref-18\"> , 10.11 Bibliographic Notes for Chapter 10, p. 589. </li> \n <li id=\"cite-ref-20\"> , 2. JIT Compilation Techniques, 2.1 Genesis, p. 98. </li> \n <li id=\"cite-ref-22\"> Raymond, Eric S. citing Dennis Ritchie (2003). &#34;Jargon File 4.4.7: grep&#34;. </li> \n <li id=\"cite-ref-24\"> &#34;New Regular Expression Features in Tcl 8.1&#34;. Retrieved 2013-10-11. </li> \n <li id=\"cite-ref-26\"> &#34;PostgreSQL 9.3.1 Documentation: 9.7. Pattern Matching&#34;. Retrieved 2013-10-12. </li> \n <li id=\"cite-ref-28\"> Wall, Larry and the Perl 5 development team (2006). &#34;perlre: Perl regular expressions&#34;. </li> \n <li id=\"cite-ref-30\"> &#34;Unicode and Localisation Support&#34;. Retrieved 2013-10-11. </li> \n <li id=\"cite-ref-32\"> Russ Cox (2007). &#34;Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, …)&#34;. Retrieved 2013-10-11. </li> \n <li id=\"cite-ref-34\">  </li> \n <li id=\"cite-ref-36\"> grep(1) man page </li> \n <li id=\"cite-ref-38\">  </li> \n <li id=\"cite-ref-40\">  </li> \n <li id=\"cite-ref-42\">  </li> \n <li id=\"cite-ref-44\">  </li> \n <li id=\"cite-ref-46\"> Jay L. Gischer (1984). <i>(Title unknown)</i> (Technical Report). Stanford Univ., Dept. of Comp. Sc. </li> \n <li id=\"cite-ref-48\"> John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman (2003). <i>Introduction to Automata Theory, Languages, and Computation</i>. Upper Saddle River/NJ: Addison Wesley. ISBN 978-0-201-44124-6. Here: Sect.3.4.6, p.117-120. — This property need not hold for extended regular expressions, even if they describe no larger class than regular languages; cf. p.121. </li> \n <li id=\"cite-ref-50\"> <sup class=\"noprint Inline-Template\">[页码请求]</sup> </li> \n <li id=\"cite-ref-52\"> V.N. Redko (1964). &#34;On defining relations for the algebra of regular events&#34;. <i>Ukrainskii Matematicheskii Zhurnal</i>. <b>16</b> (1): 120–126. (In Russian) </li> \n <li id=\"cite-ref-54\"> ISO/IEC 9945-2:1993 <i>Information technology – Portable Operating System Interface (POSIX) – Part 2: Shell and Utilities</i>, successively revised as ISO/IEC 9945-2:2002 <i>Information technology – Portable Operating System Interface (POSIX) – Part 2: System Interfaces</i>, ISO/IEC 9945-2:2003, and currently ISO/IEC/IEEE 9945:2009 <i>Information technology – Portable Operating System Interface (POSIX®) Base Specifications, Issue 7</i> </li> \n <li id=\"cite-ref-56\"> The Single Unix Specification (Version 2) </li> \n <li id=\"cite-ref-58\"> &#34;33.3.1.2 Character Classes — Emacs lisp manual — Version 25.1&#34;. <i>gnu.org</i>. 2016. Retrieved 2017-04-13. </li> \n <li id=\"cite-ref-60\"> &#34;Perl Regular Expression Documentation&#34;. perldoc.perl.org. Retrieved January 8, 2012. </li> \n <li id=\"cite-ref-62\"> &#34;Regular Expression Syntax&#34;. <i>Python 3.5.0 documentation</i>. Python Software Foundation. Retrieved 10 October 2015. </li> \n <li id=\"cite-ref-64\"> &#34;Essential classes: Regular Expressions: Quantifiers: Differences Among Greedy, Reluctant, and Possessive Quantifiers&#34;. <i>The Java Tutorials</i>. Oracle. Retrieved 23 December 2016. </li> \n <li id=\"cite-ref-66\"> Cezar Câmpeanu and Kai Salomaa, and Sheng Yu (Dec 2003). &#34;A Formal Study of Practical Regular Expressions&#34;. <i>International Journal of Foundations of Computer Science</i>. <b>14</b> (6): 1007–1018. doi:10.1142/S012905410300214X. Theorem 3 (p.9) </li> \n <li id=\"cite-ref-68\">  </li> \n <li id=\"cite-ref-70\">  </li> \n <li id=\"cite-ref-72\"> &#34;Vim documentation: pattern&#34;. Vimdoc.sourceforge.net. Retrieved 2013-09-25. </li> \n <li id=\"cite-ref-74\"> &#34;UTS#18 on Unicode Regular Expressions, Annex A: Character Blocks&#34;. Retrieved 2010-02-05. </li> \n <li id=\"cite-ref-76\"> Horowitz, Bradley (24 October 2011). &#34;A fall sweep&#34;. <i>Google Blog</i>. Retrieved 4 May 2019. </li> \n <li id=\"cite-ref-78\"> Cox, Russ (January 2012). &#34;Regular Expression Matching with a Trigram Index, or How Google Code Search Worked&#34;. <i>swtch.com</i>. Retrieved 4 May 2019. </li> \n <li id=\"cite-ref-80\"> The character &#39;m&#39; is not always required to specify a Perl match operation. For example, <code>m/[^abc]/</code> could also be rendered as <code>/[^abc]/</code>. The &#39;m&#39; is only necessary if the user wishes to specify a match operation without using a forward-slash as the regex delimiter. Sometimes it is useful to specify an alternate regex delimiter in order to avoid &#34;delimiter collision&#34;. See &#39;perldoc perlre&#39; for more details. </li> \n <li id=\"cite-ref-82\"> E.g., see <i>Java in a Nutshell</i>, p. 213; <i>Python Scripting for Computational Science</i>, p. 320; Programming PHP, p. 106. </li> \n <li id=\"cite-ref-84\"> Note that all the if statements return a TRUE value </li> \n <li id=\"cite-ref-86\"> Conway, Damian (2005). &#34;Regular Expressions, End of String&#34;. <i>Perl Best Practices</i>. O&#39;Reilly. p. 240. ISBN 978-0-596-00173-5. </li> \n</ol>","pics":null,"card":null,"references":[],"versionCount":0}],"references":[{"id":1,"type":"book","title":"Goyvaerts, Jan. \"Regular Expression Tutorial - Learn How to Use Regular Expressions\". www.regular-expressions.info.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":2,"type":"book","title":"Ruslan Mitkov (2003). The Oxford Handbook of Computational Linguistics. Oxford University Press. p. 754. ISBN 978-0-19-927634-9.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":3,"type":"book","title":"Mark V. Lawson (17 September 2003). Finite Automata. CRC Press. pp. 98–100. ISBN 978-1-58488-255-8.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":4,"type":"book","title":"Kleene 1951.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":5,"type":"book","title":"Thompson 1968.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":6,"type":"book","title":"Johnson et al. 1968.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":7,"type":"book","title":"Kernighan, Brian (2007-08-08). \"A Regular Expressions Matcher\". Beautiful Code. O'Reilly Media. pp. 1–2. ISBN 978-0-596-51004-6. Retrieved 2013-05-15.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":8,"type":"book","title":"Ritchie, Dennis M. \"An incomplete history of the QED Text Editor\". Archived from the original on 1999-02-21. Retrieved 9 October 2013.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":9,"type":"book","title":"Aho & Ullman 1992, 10.11 Bibliographic Notes for Chapter 10, p. 589.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":10,"type":"book","title":"Aycock 2003, 2. JIT Compilation Techniques, 2.1 Genesis, p. 98.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":11,"type":"book","title":"Raymond, Eric S. citing Dennis Ritchie (2003). \"Jargon File 4.4.7: grep\".","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":12,"type":"book","title":"\"New Regular Expression Features in Tcl 8.1\". Retrieved 2013-10-11.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":13,"type":"book","title":"\"PostgreSQL 9.3.1 Documentation: 9.7. Pattern Matching\". Retrieved 2013-10-12.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":14,"type":"book","title":"Wall, Larry and the Perl 5 development team (2006). \"perlre: Perl regular expressions\".","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":15,"type":"book","title":"\"Unicode and Localisation Support\". Retrieved 2013-10-11.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":16,"type":"book","title":"Russ Cox (2007). \"Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, …)\". Retrieved 2013-10-11.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":17,"type":"book","title":"Wall（2002）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":18,"type":"book","title":"grep(1) man page","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":19,"type":"book","title":"Hopcroft， Motwani & Ullman（2000）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":20,"type":"book","title":"Sipser（1998）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":21,"type":"book","title":"Gelade & Neven（2008）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":22,"type":"book","title":"Gruber & Holzer（2008）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":23,"type":"book","title":"Jay L. Gischer (1984). (Title unknown) (Technical Report). Stanford Univ., Dept. of Comp. Sc.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":24,"type":"book","title":"John E. Hopcroft and Rajeev Motwani and Jeffrey D. Ullman (2003). Introduction to Automata Theory, Languages, and Computation. Upper Saddle River/NJ: Addison Wesley. ISBN 978-0-201-44124-6. Here: Sect.3.4.6, p.117-120. — This property need not hold for extended regular expressions, even if they describe no larger class than regular languages; cf. p.121.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":25,"type":"book","title":"Kozen（1991）[页码请求]","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":26,"type":"book","title":"V.N. Redko (1964). \"On defining relations for the algebra of regular events\". Ukrainskii Matematicheskii Zhurnal. 16 (1): 120–126. (In Russian)","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":27,"type":"book","title":"ISO/IEC 9945-2:1993 Information technology – Portable Operating System Interface (POSIX) – Part 2: Shell and Utilities, successively revised as ISO/IEC 9945-2:2002 Information technology – Portable Operating System Interface (POSIX) – Part 2: System Interfaces, ISO/IEC 9945-2:2003, and currently ISO/IEC/IEEE 9945:2009 Information technology – Portable Operating System Interface (POSIX®) Base Specifications, Issue 7","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":28,"type":"book","title":"The Single Unix Specification (Version 2)","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":29,"type":"book","title":"\"33.3.1.2 Character Classes — Emacs lisp manual — Version 25.1\". gnu.org. 2016. Retrieved 2017-04-13.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":30,"type":"book","title":"\"Perl Regular Expression Documentation\". perldoc.perl.org. Retrieved January 8, 2012.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":31,"type":"book","title":"\"Regular Expression Syntax\". Python 3.5.0 documentation. Python Software Foundation. Retrieved 10 October 2015.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":32,"type":"book","title":"\"Essential classes: Regular Expressions: Quantifiers: Differences Among Greedy, Reluctant, and Possessive Quantifiers\". The Java Tutorials. Oracle. Retrieved 23 December 2016.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":33,"type":"book","title":"Cezar Câmpeanu and Kai Salomaa, and Sheng Yu (Dec 2003). \"A Formal Study of Practical Regular Expressions\". International Journal of Foundations of Computer Science. 14 (6): 1007–1018. doi:10.1142/S012905410300214X. Theorem 3 (p.9)","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":34,"type":"book","title":"Cox（2007）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":35,"type":"book","title":"Laurikari（2009）","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":36,"type":"book","title":"\"Vim documentation: pattern\". Vimdoc.sourceforge.net. Retrieved 2013-09-25.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":37,"type":"book","title":"\"UTS#18 on Unicode Regular Expressions, Annex A: Character Blocks\". Retrieved 2010-02-05.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":38,"type":"book","title":"Horowitz, Bradley (24 October 2011). \"A fall sweep\". Google Blog. Retrieved 4 May 2019.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":39,"type":"book","title":"Cox, Russ (January 2012). \"Regular Expression Matching with a Trigram Index, or How Google Code Search Worked\". swtch.com. Retrieved 4 May 2019.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":40,"type":"book","title":"The character 'm' is not always required to specify a Perl match operation. For example, m/[^abc]/ could also be rendered as /[^abc]/. The 'm' is only necessary if the user wishes to specify a match operation without using a forward-slash as the regex delimiter. Sometimes it is useful to specify an alternate regex delimiter in order to avoid \"delimiter collision\". See 'perldoc perlre' for more details.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":41,"type":"book","title":"E.g., see Java in a Nutshell, p. 213; Python Scripting for Computational Science, p. 320; Programming PHP, p. 106.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":42,"type":"book","title":"Note that all the if statements return a TRUE value","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false},{"id":43,"type":"book","title":"Conway, Damian (2005). \"Regular Expressions, End of String\". Perl Best Practices. O'Reilly. p. 240. ISBN 978-0-596-00173-5.","site":"","url":"","journalName":null,"author":"","press":"","publishYear":"","publishTime":null,"publishPlace":"","page":"","volume":"","quoteTime":null,"quoted":false}],"recommendReferences":null,"auditState":2,"lemmaLevel":1,"origin":0,"originEnTitle":null,"originZhTitle":null,"pv":29964,"auditType":0,"synonyms":["正则式"],"showEditTime":"2019.12.13 18:54","auditors":[{"uid":0,"name":"Ki.κe","pic":"https://web.archive.org/web/20221025114527/https://wx.qlogo.cn/mmopen/vi_32/y67kfr32Doib4wg71Jiau7jVWvharic3nRKgdRRQSl6koeQJCo0GQs2Krw0vwdFRsOWnHIQOwAZsSg5lIkIrFCOcQ/132","introduction":null,"educations":null,"jobs":null,"works":null,"educationBrief":"","jobBrief":"","role":0,"roleName":null,"title":"","professionalTitle":null,"phoneNo":null,"editable":true,"partnerId":0,"partnerIdCreateTime":0,"partnerIdPoped":false}],"hasZhishiNav":false,"auditInfos":{},"isHistory":false};</script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/aegis.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/main_2020092401.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/react.production.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/react-dom.production.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/jquery-1.11.1.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/main_2022062701.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/main_66bbe21.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/react.production.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/react-dom.production.min.js.download"></script><script crossorigin="anonymous" src="./1077.正则表达式 - 搜狗科学百科_files/main_edf0f08.js.download"></script>
</body></html>